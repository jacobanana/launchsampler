{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LaunchSampler","text":"<p>Welcome to LaunchSampler - a powerful, Python-based sampler that transforms your Novation Launchpad into a professional sample playback instrument.</p> <ul> <li> <p> Installation</p> <p>Get started quickly with pip or uv</p> <p> Install now</p> </li> <li> <p> Quick Start</p> <p>Learn the basics in 5 minutes</p> <p> Quick start guide</p> </li> <li> <p> User Guide</p> <p>Master edit mode, play mode, and shortcuts</p> <p> Read the guide</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation for developers</p> <p> API docs</p> </li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#professional-sampler","title":"Professional Sampler","text":"<ul> <li>64 pads - Full 8x8 grid support for all Launchpad models</li> <li>Multiple playback modes - One-shot, Loop, Hold, and Loop Toggle</li> <li>Real-time control - Low-latency audio playback and MIDI triggering</li> <li>Sample management - Organize samples in sets, load from directories</li> </ul>"},{"location":"#dual-ui","title":"Dual UI","text":"<ul> <li>Terminal UI (TUI) - Powerful Textual-based interface for editing and playback</li> <li>LED Feedback - Hardware LED synchronization for visual feedback</li> <li>Edit Mode - Build and configure your sample sets</li> <li>Play Mode - Live performance with full MIDI integration</li> </ul>"},{"location":"#developer-friendly","title":"Developer-Friendly","text":"<ul> <li>Clean architecture - SOLID principles, observer patterns, event-driven</li> <li>Type-safe - Full type hints with Pydantic models</li> <li>Well-tested - Comprehensive test suite with 377+ tests</li> <li>Extensible - Protocol-based design for easy customization</li> </ul>"},{"location":"#high-performance","title":"High Performance","text":"<ul> <li>Lock-free audio - Sub-millisecond trigger latency</li> <li>Thread-safe - Robust multi-threaded architecture</li> <li>Optimized mixing - Efficient audio rendering for multiple voices</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Version 0.1.0</p> <p>LaunchSampler is in active development. The core features are stable, but the API may change before 1.0.</p> <ul> <li>\u2705 Core audio engine with lock-free triggering</li> <li>\u2705 TUI with edit and play modes</li> <li>\u2705 MIDI integration for all Launchpad models</li> <li>\u2705 Sample set management (load, save, organize)</li> <li>\u2705 Comprehensive test coverage (377 tests)</li> <li>\ud83d\udea7 LED hardware synchronization (in progress)</li> <li>\ud83d\udea7 Advanced features (effects, automation)</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from launchsampler.app import LaunchpadSamplerApp\nfrom launchsampler.models import AppConfig\n\n# Create and run the app\nconfig = AppConfig.load_or_default()\napp = LaunchpadSamplerApp(config)\napp.run()\n</code></pre>"},{"location":"#architecture-highlights","title":"Architecture Highlights","text":"<p>LaunchSampler follows SOLID principles and uses an event-driven architecture:</p> <pre><code>graph TB\n    A[TUI / LED UI] --&gt; B[Orchestrator]\n    B --&gt; C[Player]\n    B --&gt; D[Editor Service]\n    B --&gt; E[Set Manager]\n    C --&gt; F[Sampler Engine]\n    C --&gt; G[MIDI Controller]\n    F --&gt; H[Audio Device]\n    G --&gt; I[Launchpad]\n\n    style B fill:#673ab7\n    style C fill:#9c27b0\n    style F fill:#e91e63</code></pre> <ul> <li>Observer Pattern - Event-driven synchronization between UI, audio, and MIDI</li> <li>Service Layer - Clear separation of concerns (Editor, Player, SetManager)</li> <li>Device Abstraction - Protocol-based design for audio and MIDI devices</li> <li>Thread Safety - Careful lock management for real-time performance</li> </ul>"},{"location":"#get-involved","title":"Get Involved","text":"<p>LaunchSampler is open source! We welcome contributions:</p> <ul> <li> GitHub Repository</li> <li> Report Issues</li> <li> Discussions</li> <li> Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>LaunchSampler is licensed under the MIT License. See License for details.</p>"},{"location":"DOCUMENTATION/","title":"Documentation Guide","text":"<p>This document explains how the LaunchSampler documentation is structured and how to work with it.</p>"},{"location":"DOCUMENTATION/#structure","title":"Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 api/              # Auto-generated API documentation\n\u251c\u2500\u2500 getting-started/  # Installation and quick start guides\n\u251c\u2500\u2500 user-guide/       # User documentation\n\u251c\u2500\u2500 architecture/     # Architecture documentation\n\u251c\u2500\u2500 contributing/     # Contributing guidelines\n\u2514\u2500\u2500 index.md         # Documentation homepage\n\nmkdocs.yml           # MkDocs configuration\nscripts/\n\u2514\u2500\u2500 generate_api_docs.py  # API docs generator\n</code></pre>"},{"location":"DOCUMENTATION/#building-documentation-locally","title":"Building Documentation Locally","text":""},{"location":"DOCUMENTATION/#prerequisites","title":"Prerequisites","text":"<p>Install development dependencies:</p> <pre><code>uv sync --group dev\n</code></pre>"},{"location":"DOCUMENTATION/#generate-api-documentation","title":"Generate API Documentation","text":"<p>The API documentation is automatically generated from Python docstrings:</p> <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre> <p>This will: - Scan all Python modules in <code>src/launchsampler/</code> - Generate markdown files with <code>:::</code> directives in <code>docs/api/</code> - Create package overview pages - Automatically update the API Reference section in <code>mkdocs.yml</code> using PyYAML for proper formatting - Save navigation structure to <code>docs/api_nav.yml</code> (for reference)</p> <p>When to regenerate: - After adding new modules or packages - After restructuring the codebase - When you want the latest docstrings in docs</p> <p>No manual copying needed! The script automatically updates <code>mkdocs.yml</code> for you.</p>"},{"location":"DOCUMENTATION/#serve-documentation","title":"Serve Documentation","text":"<p>Start a local development server with live reload:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation.</p> <p>Changes to markdown files are reflected immediately. If you modify Python docstrings, re-run the API docs generator.</p>"},{"location":"DOCUMENTATION/#build-static-site","title":"Build Static Site","text":"<p>Build the complete documentation site:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>Output is generated in <code>site/</code> directory (ignored by git).</p>"},{"location":"DOCUMENTATION/#deployment","title":"Deployment","text":"<p>Documentation is automatically built and deployed to GitHub Pages via GitHub Actions:</p> <ul> <li>On push to <code>main</code>: Docs are built and deployed</li> <li>On pull requests: Docs are built (but not deployed) to check for errors</li> </ul> <p>The workflow (<code>.github/workflows/docs.yml</code>) does: 1. Install dependencies with <code>uv</code> 2. Generate API documentation 3. Build docs with <code>mkdocs build --strict</code> 4. Deploy to GitHub Pages (on main branch only)</p>"},{"location":"DOCUMENTATION/#manual-deployment","title":"Manual Deployment","text":"<p>To manually deploy to GitHub Pages:</p> <pre><code>uv run mkdocs gh-deploy\n</code></pre> <p>This builds and pushes to the <code>gh-pages</code> branch.</p>"},{"location":"DOCUMENTATION/#writing-documentation","title":"Writing Documentation","text":""},{"location":"DOCUMENTATION/#markdown-files","title":"Markdown Files","text":"<p>Standard markdown files in <code>docs/</code> are written manually: - User guides - Tutorials - Architecture docs - Contributing guidelines</p>"},{"location":"DOCUMENTATION/#api-documentation","title":"API Documentation","text":"<p>API docs are auto-generated from Python docstrings. To document code:</p> <ol> <li>Write Google-style docstrings in your Python modules:</li> </ol> <pre><code>def my_function(param: str) -&gt; int:\n    \"\"\"\n    Short description.\n\n    Longer description with details.\n\n    Args:\n        param: Description of parameter\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When something goes wrong\n    \"\"\"\n</code></pre> <ol> <li>Add architecture diagrams in module docstrings:</li> </ol> <pre><code>\"\"\"\nModule description.\n\nArchitecture Diagram\n--------------------\n\n::\n\n    Component A\n        \u2193\n    Component B\n        \u2193\n    Component C\n\"\"\"\n</code></pre> <ol> <li>Regenerate API docs to see changes:</li> </ol> <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre>"},{"location":"DOCUMENTATION/#adding-new-documentation-pages","title":"Adding New Documentation Pages","text":"<ol> <li>Create markdown file in appropriate <code>docs/</code> subdirectory</li> <li>Add entry to <code>nav:</code> section in <code>mkdocs.yml</code></li> <li>Preview with <code>uv run mkdocs serve</code></li> </ol>"},{"location":"DOCUMENTATION/#configuration","title":"Configuration","text":""},{"location":"DOCUMENTATION/#mkdocsyml","title":"mkdocs.yml","text":"<p>Main configuration file. Key sections:</p> <ul> <li><code>site_name</code>, <code>site_description</code>: Site metadata</li> <li><code>theme</code>: Material theme configuration</li> <li><code>plugins</code>: Enabled plugins (search, mkdocstrings, etc.)</li> <li><code>markdown_extensions</code>: Markdown features</li> <li><code>nav</code>: Documentation navigation structure</li> </ul>"},{"location":"DOCUMENTATION/#mkdocstrings-configuration","title":"mkdocstrings Configuration","text":"<p>API documentation is configured in <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n            show_source: true\n            # ... other options\n</code></pre>"},{"location":"DOCUMENTATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"DOCUMENTATION/#api-docs-not-updating","title":"API docs not updating","text":"<p>Re-run the generator: <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre></p>"},{"location":"DOCUMENTATION/#build-warnings","title":"Build warnings","text":"<p>Run strict build to catch all issues: <pre><code>uv run mkdocs build --strict\n</code></pre></p>"},{"location":"DOCUMENTATION/#type-annotation-warnings","title":"Type annotation warnings","text":"<p>Ensure all public APIs have proper type hints. See: - <code>src/launchsampler/audio/device.py</code> - <code>src/launchsampler/devices/registry.py</code> - <code>src/launchsampler/utils/observer_manager.py</code></p> <p>For examples of proper type annotations.</p>"},{"location":"DOCUMENTATION/#best-practices","title":"Best Practices","text":"<ol> <li>Commit <code>docs/</code>, not <code>site/</code></li> <li>Source files belong in git</li> <li> <p>Build output is regenerated by CI</p> </li> <li> <p>Regenerate API docs after code changes</p> </li> <li>Keep documentation in sync with code</li> <li> <p>Run generator before committing</p> </li> <li> <p>Write descriptive docstrings</p> </li> <li>They become your API documentation</li> <li> <p>Include examples when helpful</p> </li> <li> <p>Use diagrams in docstrings</p> </li> <li>ASCII diagrams render well in docs</li> <li> <p>Great for explaining architecture</p> </li> <li> <p>Test docs build before committing <pre><code>uv run mkdocs build --strict\n</code></pre></p> </li> </ol>"},{"location":"DOCUMENTATION/#resources","title":"Resources","text":"<ul> <li>MkDocs Documentation</li> <li>Material for MkDocs</li> <li>mkdocstrings</li> <li>Google Style Python Docstrings</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to LaunchSampler will be documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>\ud83d\udea7 LED hardware synchronization</li> <li>\ud83d\udea7 Advanced effects and automation</li> <li>\ud83d\udea7 Multiple Launchpad support</li> </ul>"},{"location":"changelog/#010-2025-01-17","title":"0.1.0 - 2025-01-17","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>\u2705 Core audio engine with lock-free triggering</li> <li>\u2705 Terminal UI (TUI) with Textual</li> <li>\u2705 Edit mode with full sample management</li> <li>\u2705 Play mode with MIDI integration</li> <li>\u2705 Support for all Launchpad models (Mini MK3, Pro MK3, X)</li> <li>\u2705 Four playback modes (One-shot, Loop, Hold, Loop Toggle)</li> <li>\u2705 Sample set management (load, save, organize)</li> <li>\u2705 Keyboard shortcuts for all operations</li> <li>\u2705 Directional operations (copy, move, duplicate)</li> <li>\u2705 Comprehensive test suite (377 tests)</li> <li>\u2705 NavigationService refactoring (extracted from app.py)</li> <li>\u2705 Material for MkDocs documentation</li> </ul>"},{"location":"changelog/#architecture","title":"Architecture","text":"<ul> <li>\u2705 SOLID design principles</li> <li>\u2705 Observer pattern for event-driven sync</li> <li>\u2705 Service layer pattern</li> <li>\u2705 Device abstraction with protocols</li> <li>\u2705 Thread-safe multi-threaded architecture</li> <li>\u2705 Single source of truth for state management</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>\u2705 Architecture documentation</li> <li>\u2705 API reference structure</li> <li>\u2705 User guide structure</li> <li>\u2705 Quick start guide</li> <li>\u2705 Installation guide</li> <li>\u2705 Configuration guide</li> </ul>"},{"location":"license/","title":"License","text":"<p>LaunchSampler is released under the MIT License.</p>"},{"location":"license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 LaunchSampler Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>LaunchSampler uses the following open-source libraries:</p> <ul> <li>Textual - MIT License</li> <li>Pydantic - MIT License</li> <li>sounddevice - MIT License</li> <li>mido - MIT License</li> <li>numpy - BSD License</li> <li>click - BSD License</li> </ul> <p>See each package's license file for full details.</p>"},{"location":"api/audio/","title":"Audio","text":"<p>Low-level audio primitives and sample loading</p>"},{"location":"api/audio/#launchsampler.audio","title":"<code>audio</code>","text":"<p>Audio engine for sample playback.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData","title":"<code>AudioData(data, sample_rate, num_channels, num_frames, format=None, subtype=None)</code>  <code>dataclass</code>","text":"<p>Raw audio data storage.</p> <p>This is kept separate from Pydantic models for performance. Contains the actual audio buffer that will be played back.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Duration in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of audio data array.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.from_array","title":"<code>from_array(data, sample_rate)</code>  <code>classmethod</code>","text":"<p>Create AudioData from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float32]</code> <p>Audio data as float32 array   Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData instance</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>@classmethod\ndef from_array(\n    cls,\n    data: npt.NDArray[np.float32],\n    sample_rate: int\n) -&gt; \"AudioData\":\n    \"\"\"\n    Create AudioData from a NumPy array.\n\n    Args:\n        data: Audio data as float32 array\n              Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel\n        sample_rate: Sample rate in Hz\n\n    Returns:\n        AudioData instance\n    \"\"\"\n    if data.ndim == 1:\n        # Mono audio\n        num_channels = 1\n        num_frames = len(data)\n    elif data.ndim == 2:\n        # Multi-channel audio\n        num_frames, num_channels = data.shape\n    else:\n        raise ValueError(f\"Audio data must be 1D or 2D, got {data.ndim}D\")\n\n    # Ensure float32 dtype\n    if data.dtype != np.float32:\n        data = data.astype(np.float32)\n\n    return cls(\n        data=data,\n        sample_rate=sample_rate,\n        num_channels=num_channels,\n        num_frames=num_frames\n    )\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.get_mono","title":"<code>get_mono()</code>","text":"<p>Get mono version of audio data.</p> <p>If already mono, returns original data. If stereo/multi-channel, returns average of all channels.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_mono(self) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Get mono version of audio data.\n\n    If already mono, returns original data.\n    If stereo/multi-channel, returns average of all channels.\n    \"\"\"\n    if self.num_channels == 1:\n        return self.data\n    else:\n        return np.mean(self.data, axis=1, dtype=np.float32)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.normalize","title":"<code>normalize(target_level=0.95)</code>","text":"<p>Normalize audio data to target level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target peak level (0.0 to 1.0)</p> <code>0.95</code> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def normalize(self, target_level: float = 0.95) -&gt; None:\n    \"\"\"\n    Normalize audio data to target level.\n\n    Args:\n        target_level: Target peak level (0.0 to 1.0)\n    \"\"\"\n    peak = np.abs(self.data).max()\n    if peak &gt; 0:\n        self.data *= (target_level / peak)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.get_info","title":"<code>get_info()</code>","text":"<p>Get comprehensive audio file information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with audio metadata including duration, sample rate, </p> <code>dict</code> <p>channels, format, file size, etc.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_info(self) -&gt; dict:\n    \"\"\"\n    Get comprehensive audio file information.\n\n    Returns:\n        Dictionary with audio metadata including duration, sample rate, \n        channels, format, file size, etc.\n    \"\"\"\n    # Calculate file size in bytes (based on loaded data in memory)\n    size_bytes = self.data.nbytes\n\n    info = {\n        'duration': self.duration,\n        'sample_rate': self.sample_rate,\n        'num_channels': self.num_channels,\n        'num_frames': self.num_frames,\n        'size_bytes': size_bytes,\n        'size_str': format_bytes(size_bytes),\n    }\n\n    # Add format info if available\n    if self.format:\n        info['format'] = self.format\n    if self.subtype:\n        info['subtype'] = self.subtype\n\n    return info\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState","title":"<code>PlaybackState(is_playing=False, position=0.0, mode=PlaybackMode.ONE_SHOT, volume=1.0, audio_data=None)</code>  <code>dataclass</code>","text":"<p>Runtime playback state for a single pad.</p> <p>This is NOT a Pydantic model because it's purely internal state that changes rapidly during audio playback and should have minimal overhead.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Get playback progress as fraction (0.0 to 1.0).</p> <p>Returns 0.0 if no audio data.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.time_elapsed","title":"<code>time_elapsed</code>  <code>property</code>","text":"<p>Get elapsed playback time in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.time_remaining","title":"<code>time_remaining</code>  <code>property</code>","text":"<p>Get remaining playback time in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.start","title":"<code>start()</code>","text":"<p>Start playback from the beginning.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start playback from the beginning.\"\"\"\n    if self.audio_data is None:\n        raise ValueError(\"Cannot start playback without audio data\")\n\n    self.is_playing = True\n    self.position = 0.0\n    self._loop_count = 0\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.stop","title":"<code>stop()</code>","text":"<p>Stop playback.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop playback.\"\"\"\n    self.is_playing = False\n    # Reset toggle state when stopping\n    if self.mode == PlaybackMode.LOOP_TOGGLE:\n        self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.reset","title":"<code>reset()</code>","text":"<p>Reset to initial state.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to initial state.\"\"\"\n    self.is_playing = False\n    self.position = 0.0\n    self._loop_count = 0\n    self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.advance","title":"<code>advance(num_frames)</code>","text":"<p>Advance playback position by num_frames.</p> <p>Handles looping and stopping based on playback mode.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to advance</p> required Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def advance(self, num_frames: int) -&gt; None:\n    \"\"\"\n    Advance playback position by num_frames.\n\n    Handles looping and stopping based on playback mode.\n\n    Args:\n        num_frames: Number of frames to advance\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return\n\n    self.position += num_frames\n\n    # Check if we've reached the end\n    if self.position &gt;= self.audio_data.num_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Loop back to start\n            self.position = self.position % self.audio_data.num_frames\n            self._loop_count += 1\n        else:\n            # ONE_SHOT or HOLD - stop at end\n            self.stop()\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.get_frames","title":"<code>get_frames(num_frames)</code>","text":"<p>Get next audio frames for playback.</p> <p>Handles seamless looping when in LOOP mode by wrapping around the end of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to get</p> required <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Audio frames as float32 array, or None if not playing</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_frames(self, num_frames: int) -&gt; Optional[npt.NDArray[np.float32]]:\n    \"\"\"\n    Get next audio frames for playback.\n\n    Handles seamless looping when in LOOP mode by wrapping around\n    the end of the buffer.\n\n    Args:\n        num_frames: Number of frames to get\n\n    Returns:\n        Audio frames as float32 array, or None if not playing\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return None\n\n    start_pos = int(self.position)\n    total_frames = self.audio_data.num_frames\n\n    # Handle end of buffer for non-loop modes\n    if start_pos &gt;= total_frames:\n        return None\n\n    end_pos = start_pos + num_frames\n\n    # Check if we need to wrap around (for LOOP mode)\n    if end_pos &gt; total_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Seamlessly wrap around for looping\n            # Get frames from current position to end\n            if self.audio_data.num_channels == 1:\n                first_part = self.audio_data.data[start_pos:total_frames]\n            else:\n                first_part = self.audio_data.data[start_pos:total_frames, :]\n\n            # Calculate how many frames we need from the beginning\n            remaining_frames = num_frames - (total_frames - start_pos)\n\n            # Get frames from beginning\n            if self.audio_data.num_channels == 1:\n                second_part = self.audio_data.data[0:remaining_frames]\n                frames = np.concatenate([first_part, second_part])\n            else:\n                second_part = self.audio_data.data[0:remaining_frames, :]\n                frames = np.concatenate([first_part, second_part], axis=0)\n        else:\n            # For ONE_SHOT and HOLD, truncate at end\n            end_pos = total_frames\n            if self.audio_data.num_channels == 1:\n                frames = self.audio_data.data[start_pos:end_pos]\n            else:\n                frames = self.audio_data.data[start_pos:end_pos, :]\n    else:\n        # Normal case - extract frames\n        if self.audio_data.num_channels == 1:\n            frames = self.audio_data.data[start_pos:end_pos]\n        else:\n            frames = self.audio_data.data[start_pos:end_pos, :]\n\n    # Apply volume\n    if self.volume != 1.0:\n        frames = frames * self.volume\n\n    return frames\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice","title":"<code>AudioDevice(buffer_size=128, num_channels=2, device=None, low_latency=True)</code>","text":"<p>Generic low-latency audio output device and stream management.</p> <p>Handles device querying, validation, and stream lifecycle. No application-specific logic - purely generic audio I/O.</p> <p>Initialize audio device.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>Audio buffer size in frames (lower = less latency)</p> <code>128</code> <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> <code>device</code> <code>Optional[int]</code> <p>Output device ID (None for default)</p> <code>None</code> <code>low_latency</code> <code>bool</code> <p>Enable low-latency optimizations</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If device doesn't use low-latency API</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __init__(\n    self,\n    buffer_size: int = 128,\n    num_channels: int = 2,\n    device: Optional[int] = None,\n    low_latency: bool = True\n):\n    \"\"\"\n    Initialize audio device.\n\n    Args:\n        buffer_size: Audio buffer size in frames (lower = less latency)\n        num_channels: Number of output channels (1=mono, 2=stereo)\n        device: Output device ID (None for default)\n        low_latency: Enable low-latency optimizations\n\n    Raises:\n        ValueError: If device doesn't use low-latency API\n    \"\"\"\n    self.buffer_size = buffer_size\n    self.num_channels = num_channels\n    self.low_latency = low_latency\n\n    # Validate device if specified\n    if device is not None:\n        self._validate_device(device)\n\n    self.device = device\n\n    # Stream state\n    self._stream: Optional[sd.OutputStream] = None\n    self._is_running = False\n    self._callback: Optional[Callable[[np.ndarray, int], None]] = None\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio stream is running.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.latency","title":"<code>latency</code>  <code>property</code>","text":"<p>Get current stream latency in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.sample_rate","title":"<code>sample_rate</code>  <code>property</code>","text":"<p>Get current sample rate.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the name of the current audio device.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.set_callback","title":"<code>set_callback(callback)</code>","text":"<p>Set audio callback function.</p> <p>The callback will be called with (outdata, frames) for each audio block.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ndarray, int], None]</code> <p>Function(outdata: np.ndarray, frames: int) -&gt; None</p> required Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def set_callback(self, callback: Callable[[np.ndarray, int], None]) -&gt; None:\n    \"\"\"\n    Set audio callback function.\n\n    The callback will be called with (outdata, frames) for each audio block.\n\n    Args:\n        callback: Function(outdata: np.ndarray, frames: int) -&gt; None\n    \"\"\"\n    self._callback = callback\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.start","title":"<code>start()</code>","text":"<p>Start audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio stream.\"\"\"\n    if self._is_running:\n        return\n\n    if self._callback is None:\n        raise RuntimeError(\"No audio callback set. Call set_callback() first.\")\n\n    device_id = self.device or sd.default.device[1]\n    self._validate_low_latency_device(device_id)\n    self._log_device_info(device_id)\n\n    # Select stream configuration\n    stream_kwargs = self._get_stream_config(device_id)\n\n    # Try to start the stream\n    self._start_stream(stream_kwargs)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.stop","title":"<code>stop()</code>","text":"<p>Stop audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio stream.\"\"\"\n    if not self._is_running:\n        return\n\n    if self._stream:\n        self._stream.stop()\n        self._stream.close()\n        self._stream = None\n\n    self._is_running = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.list_output_devices","title":"<code>list_output_devices()</code>  <code>staticmethod</code>","text":"<p>List all available low-latency audio output devices.</p> <p>On Windows: ASIO and WASAPI devices On macOS: Core Audio devices On Linux: ALSA and JACK devices</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str, str, Any]]</code> <p>Tuple of (devices, api_names) where:</p> <code>str</code> <ul> <li>devices: List of tuples (device_id, device_name, host_api_name, device_info)</li> </ul> <code>Tuple[List[Tuple[int, str, str, Any]], str]</code> <ul> <li>api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")</li> </ul> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef list_output_devices() -&gt; Tuple[List[Tuple[int, str, str, Any]], str]:\n    \"\"\"\n    List all available low-latency audio output devices.\n\n    On Windows: ASIO and WASAPI devices\n    On macOS: Core Audio devices\n    On Linux: ALSA and JACK devices\n\n    Returns:\n        Tuple of (devices, api_names) where:\n        - devices: List of tuples (device_id, device_name, host_api_name, device_info)\n        - api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")\n    \"\"\"\n    devices = sd.query_devices()\n    hostapis = sd.query_hostapis()\n\n    low_latency_apis, api_names = AudioDevice._get_platform_apis()\n    available_devices = []\n\n    for i, device in enumerate(devices):\n        if device['max_output_channels'] &gt; 0:\n            hostapi = hostapis[device['hostapi']]\n            hostapi_name = hostapi['name']\n\n            if any(api in hostapi_name for api in low_latency_apis):\n                available_devices.append((i, device['name'], hostapi_name, device))\n\n    return available_devices, api_names\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.get_default_device","title":"<code>get_default_device()</code>  <code>staticmethod</code>","text":"<p>Get default output device ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>Device ID</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_default_device() -&gt; int:\n    \"\"\"\n    Get default output device ID.\n\n    Returns:\n        Device ID\n    \"\"\"\n    return sd.default.device[1]  # Output device\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader","title":"<code>SampleLoader(target_sample_rate=None)</code>","text":"<p>Load audio files into AudioData structures.</p> <p>Handles WAV, FLAC, OGG, and other formats supported by soundfile.</p> <p>Initialize sample loader.</p> <p>Parameters:</p> Name Type Description Default <code>target_sample_rate</code> <code>Optional[int]</code> <p>If set, resample all audio to this rate.                If None, use original sample rate.</p> <code>None</code> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def __init__(self, target_sample_rate: Optional[int] = None):\n    \"\"\"\n    Initialize sample loader.\n\n    Args:\n        target_sample_rate: If set, resample all audio to this rate.\n                           If None, use original sample rate.\n    \"\"\"\n    self.target_sample_rate = target_sample_rate\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader.load","title":"<code>load(path)</code>","text":"<p>Load audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData containing the loaded audio</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>RuntimeError</code> <p>If file cannot be loaded</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def load(self, path: Path) -&gt; AudioData:\n    \"\"\"\n    Load audio file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        AudioData containing the loaded audio\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        RuntimeError: If file cannot be loaded\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    try:\n        # Get file info for metadata\n        info = sf.info(str(path))\n\n        # Load audio file\n        data, sample_rate = sf.read(str(path), dtype='float32')\n\n        # Handle empty files\n        if len(data) == 0:\n            raise RuntimeError(f\"Audio file is empty: {path}\")\n\n        # Resample if needed\n        if self.target_sample_rate and sample_rate != self.target_sample_rate:\n            data = self._resample(data, sample_rate, self.target_sample_rate)\n            sample_rate = self.target_sample_rate\n\n        # Create AudioData with metadata\n        audio_data = AudioData.from_array(data, sample_rate)\n        audio_data.format = info.format\n        audio_data.subtype = info.subtype\n        return audio_data\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load audio file {path}: {e}\") from e\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader.get_info","title":"<code>get_info(path)</code>  <code>staticmethod</code>","text":"<p>Get audio file info without loading the full file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'sample_rate', 'channels', 'frames', 'duration'</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>@staticmethod\ndef get_info(path: Path) -&gt; dict:\n    \"\"\"\n    Get audio file info without loading the full file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        Dictionary with 'sample_rate', 'channels', 'frames', 'duration'\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    info = sf.info(str(path))\n    return {\n        'sample_rate': info.samplerate,\n        'channels': info.channels,\n        'frames': info.frames,\n        'duration': info.duration,\n        'format': info.format,\n        'subtype': info.subtype,\n    }\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer","title":"<code>AudioMixer(num_channels=2)</code>","text":"<p>Mix multiple audio sources into a single output.</p> <p>Thread-safe for use in audio callbacks.</p> <p>Initialize audio mixer.</p> <p>Parameters:</p> Name Type Description Default <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def __init__(self, num_channels: int = 2):\n    \"\"\"\n    Initialize audio mixer.\n\n    Args:\n        num_channels: Number of output channels (1=mono, 2=stereo)\n    \"\"\"\n    self.num_channels = num_channels\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.mix","title":"<code>mix(playback_states, num_frames)</code>","text":"<p>Mix multiple playback states into a single buffer.</p> <p>Parameters:</p> Name Type Description Default <code>playback_states</code> <code>List[PlaybackState]</code> <p>List of PlaybackState objects to mix</p> required <code>num_frames</code> <code>int</code> <p>Number of frames to generate</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono</p> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def mix(\n    self,\n    playback_states: List[PlaybackState],\n    num_frames: int\n) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Mix multiple playback states into a single buffer.\n\n    Args:\n        playback_states: List of PlaybackState objects to mix\n        num_frames: Number of frames to generate\n\n    Returns:\n        Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono\n    \"\"\"\n    # Create output buffer\n    if self.num_channels == 1:\n        output = np.zeros(num_frames, dtype=np.float32)\n    else:\n        output = np.zeros((num_frames, self.num_channels), dtype=np.float32)\n\n    # Mix each playing source\n    for state in playback_states:\n        if not state.is_playing or state.audio_data is None:\n            continue\n\n        # Get frames from this source\n        frames = state.get_frames(num_frames)\n        if frames is None:\n            continue\n\n        # Handle channel mismatch\n        frames_to_add = self._match_channels(frames, state.audio_data.num_channels)\n\n        # Add to output (clip to available length)\n        add_length = min(len(frames_to_add), num_frames)\n        if self.num_channels == 1:\n            output[:add_length] += frames_to_add[:add_length]\n        else:\n            output[:add_length, :] += frames_to_add[:add_length, :]\n\n        # Advance the playback position\n        state.advance(add_length)\n\n    return output\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.apply_master_volume","title":"<code>apply_master_volume(buffer, volume)</code>  <code>staticmethod</code>","text":"<p>Apply master volume to buffer in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to modify</p> required <code>volume</code> <code>float</code> <p>Volume multiplier (0.0 to 1.0)</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef apply_master_volume(\n    buffer: npt.NDArray[np.float32],\n    volume: float\n) -&gt; None:\n    \"\"\"\n    Apply master volume to buffer in-place.\n\n    Args:\n        buffer: Audio buffer to modify\n        volume: Volume multiplier (0.0 to 1.0)\n    \"\"\"\n    if volume != 1.0:\n        buffer *= volume\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.clip","title":"<code>clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Clip audio buffer to valid range [-1.0, 1.0] in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Clip audio buffer to valid range [-1.0, 1.0] in-place.\n\n    Args:\n        buffer: Audio buffer to clip\n    \"\"\"\n    np.clip(buffer, -1.0, 1.0, out=buffer)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.soft_clip","title":"<code>soft_clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Apply soft clipping (tanh) to prevent harsh distortion.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to soft clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef soft_clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Apply soft clipping (tanh) to prevent harsh distortion.\n\n    Args:\n        buffer: Audio buffer to soft clip\n    \"\"\"\n    np.tanh(buffer, out=buffer)\n</code></pre>"},{"location":"api/audio/data/","title":"Data","text":""},{"location":"api/audio/data/#launchsampler.audio.data","title":"<code>data</code>","text":"<p>Audio data structures using dataclasses for performance.</p> <p>These dataclasses store actual audio data (NumPy arrays) and runtime state. They are NOT Pydantic models because: - They contain non-serializable data (NumPy arrays) - They need minimal overhead for real-time audio processing - They are internal to the audio engine, not part of the API</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData","title":"<code>AudioData(data, sample_rate, num_channels, num_frames, format=None, subtype=None)</code>  <code>dataclass</code>","text":"<p>Raw audio data storage.</p> <p>This is kept separate from Pydantic models for performance. Contains the actual audio buffer that will be played back.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Duration in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of audio data array.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.from_array","title":"<code>from_array(data, sample_rate)</code>  <code>classmethod</code>","text":"<p>Create AudioData from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float32]</code> <p>Audio data as float32 array   Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData instance</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>@classmethod\ndef from_array(\n    cls,\n    data: npt.NDArray[np.float32],\n    sample_rate: int\n) -&gt; \"AudioData\":\n    \"\"\"\n    Create AudioData from a NumPy array.\n\n    Args:\n        data: Audio data as float32 array\n              Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel\n        sample_rate: Sample rate in Hz\n\n    Returns:\n        AudioData instance\n    \"\"\"\n    if data.ndim == 1:\n        # Mono audio\n        num_channels = 1\n        num_frames = len(data)\n    elif data.ndim == 2:\n        # Multi-channel audio\n        num_frames, num_channels = data.shape\n    else:\n        raise ValueError(f\"Audio data must be 1D or 2D, got {data.ndim}D\")\n\n    # Ensure float32 dtype\n    if data.dtype != np.float32:\n        data = data.astype(np.float32)\n\n    return cls(\n        data=data,\n        sample_rate=sample_rate,\n        num_channels=num_channels,\n        num_frames=num_frames\n    )\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.get_mono","title":"<code>get_mono()</code>","text":"<p>Get mono version of audio data.</p> <p>If already mono, returns original data. If stereo/multi-channel, returns average of all channels.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_mono(self) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Get mono version of audio data.\n\n    If already mono, returns original data.\n    If stereo/multi-channel, returns average of all channels.\n    \"\"\"\n    if self.num_channels == 1:\n        return self.data\n    else:\n        return np.mean(self.data, axis=1, dtype=np.float32)\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.normalize","title":"<code>normalize(target_level=0.95)</code>","text":"<p>Normalize audio data to target level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target peak level (0.0 to 1.0)</p> <code>0.95</code> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def normalize(self, target_level: float = 0.95) -&gt; None:\n    \"\"\"\n    Normalize audio data to target level.\n\n    Args:\n        target_level: Target peak level (0.0 to 1.0)\n    \"\"\"\n    peak = np.abs(self.data).max()\n    if peak &gt; 0:\n        self.data *= (target_level / peak)\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.get_info","title":"<code>get_info()</code>","text":"<p>Get comprehensive audio file information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with audio metadata including duration, sample rate, </p> <code>dict</code> <p>channels, format, file size, etc.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_info(self) -&gt; dict:\n    \"\"\"\n    Get comprehensive audio file information.\n\n    Returns:\n        Dictionary with audio metadata including duration, sample rate, \n        channels, format, file size, etc.\n    \"\"\"\n    # Calculate file size in bytes (based on loaded data in memory)\n    size_bytes = self.data.nbytes\n\n    info = {\n        'duration': self.duration,\n        'sample_rate': self.sample_rate,\n        'num_channels': self.num_channels,\n        'num_frames': self.num_frames,\n        'size_bytes': size_bytes,\n        'size_str': format_bytes(size_bytes),\n    }\n\n    # Add format info if available\n    if self.format:\n        info['format'] = self.format\n    if self.subtype:\n        info['subtype'] = self.subtype\n\n    return info\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState","title":"<code>PlaybackState(is_playing=False, position=0.0, mode=PlaybackMode.ONE_SHOT, volume=1.0, audio_data=None)</code>  <code>dataclass</code>","text":"<p>Runtime playback state for a single pad.</p> <p>This is NOT a Pydantic model because it's purely internal state that changes rapidly during audio playback and should have minimal overhead.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Get playback progress as fraction (0.0 to 1.0).</p> <p>Returns 0.0 if no audio data.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.time_elapsed","title":"<code>time_elapsed</code>  <code>property</code>","text":"<p>Get elapsed playback time in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.time_remaining","title":"<code>time_remaining</code>  <code>property</code>","text":"<p>Get remaining playback time in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.start","title":"<code>start()</code>","text":"<p>Start playback from the beginning.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start playback from the beginning.\"\"\"\n    if self.audio_data is None:\n        raise ValueError(\"Cannot start playback without audio data\")\n\n    self.is_playing = True\n    self.position = 0.0\n    self._loop_count = 0\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.stop","title":"<code>stop()</code>","text":"<p>Stop playback.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop playback.\"\"\"\n    self.is_playing = False\n    # Reset toggle state when stopping\n    if self.mode == PlaybackMode.LOOP_TOGGLE:\n        self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.reset","title":"<code>reset()</code>","text":"<p>Reset to initial state.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to initial state.\"\"\"\n    self.is_playing = False\n    self.position = 0.0\n    self._loop_count = 0\n    self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.advance","title":"<code>advance(num_frames)</code>","text":"<p>Advance playback position by num_frames.</p> <p>Handles looping and stopping based on playback mode.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to advance</p> required Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def advance(self, num_frames: int) -&gt; None:\n    \"\"\"\n    Advance playback position by num_frames.\n\n    Handles looping and stopping based on playback mode.\n\n    Args:\n        num_frames: Number of frames to advance\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return\n\n    self.position += num_frames\n\n    # Check if we've reached the end\n    if self.position &gt;= self.audio_data.num_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Loop back to start\n            self.position = self.position % self.audio_data.num_frames\n            self._loop_count += 1\n        else:\n            # ONE_SHOT or HOLD - stop at end\n            self.stop()\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.get_frames","title":"<code>get_frames(num_frames)</code>","text":"<p>Get next audio frames for playback.</p> <p>Handles seamless looping when in LOOP mode by wrapping around the end of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to get</p> required <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Audio frames as float32 array, or None if not playing</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_frames(self, num_frames: int) -&gt; Optional[npt.NDArray[np.float32]]:\n    \"\"\"\n    Get next audio frames for playback.\n\n    Handles seamless looping when in LOOP mode by wrapping around\n    the end of the buffer.\n\n    Args:\n        num_frames: Number of frames to get\n\n    Returns:\n        Audio frames as float32 array, or None if not playing\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return None\n\n    start_pos = int(self.position)\n    total_frames = self.audio_data.num_frames\n\n    # Handle end of buffer for non-loop modes\n    if start_pos &gt;= total_frames:\n        return None\n\n    end_pos = start_pos + num_frames\n\n    # Check if we need to wrap around (for LOOP mode)\n    if end_pos &gt; total_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Seamlessly wrap around for looping\n            # Get frames from current position to end\n            if self.audio_data.num_channels == 1:\n                first_part = self.audio_data.data[start_pos:total_frames]\n            else:\n                first_part = self.audio_data.data[start_pos:total_frames, :]\n\n            # Calculate how many frames we need from the beginning\n            remaining_frames = num_frames - (total_frames - start_pos)\n\n            # Get frames from beginning\n            if self.audio_data.num_channels == 1:\n                second_part = self.audio_data.data[0:remaining_frames]\n                frames = np.concatenate([first_part, second_part])\n            else:\n                second_part = self.audio_data.data[0:remaining_frames, :]\n                frames = np.concatenate([first_part, second_part], axis=0)\n        else:\n            # For ONE_SHOT and HOLD, truncate at end\n            end_pos = total_frames\n            if self.audio_data.num_channels == 1:\n                frames = self.audio_data.data[start_pos:end_pos]\n            else:\n                frames = self.audio_data.data[start_pos:end_pos, :]\n    else:\n        # Normal case - extract frames\n        if self.audio_data.num_channels == 1:\n            frames = self.audio_data.data[start_pos:end_pos]\n        else:\n            frames = self.audio_data.data[start_pos:end_pos, :]\n\n    # Apply volume\n    if self.volume != 1.0:\n        frames = frames * self.volume\n\n    return frames\n</code></pre>"},{"location":"api/audio/device/","title":"Device","text":""},{"location":"api/audio/device/#launchsampler.audio.device","title":"<code>device</code>","text":"<p>Generic audio device and stream management.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice","title":"<code>AudioDevice(buffer_size=128, num_channels=2, device=None, low_latency=True)</code>","text":"<p>Generic low-latency audio output device and stream management.</p> <p>Handles device querying, validation, and stream lifecycle. No application-specific logic - purely generic audio I/O.</p> <p>Initialize audio device.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>Audio buffer size in frames (lower = less latency)</p> <code>128</code> <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> <code>device</code> <code>Optional[int]</code> <p>Output device ID (None for default)</p> <code>None</code> <code>low_latency</code> <code>bool</code> <p>Enable low-latency optimizations</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If device doesn't use low-latency API</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __init__(\n    self,\n    buffer_size: int = 128,\n    num_channels: int = 2,\n    device: Optional[int] = None,\n    low_latency: bool = True\n):\n    \"\"\"\n    Initialize audio device.\n\n    Args:\n        buffer_size: Audio buffer size in frames (lower = less latency)\n        num_channels: Number of output channels (1=mono, 2=stereo)\n        device: Output device ID (None for default)\n        low_latency: Enable low-latency optimizations\n\n    Raises:\n        ValueError: If device doesn't use low-latency API\n    \"\"\"\n    self.buffer_size = buffer_size\n    self.num_channels = num_channels\n    self.low_latency = low_latency\n\n    # Validate device if specified\n    if device is not None:\n        self._validate_device(device)\n\n    self.device = device\n\n    # Stream state\n    self._stream: Optional[sd.OutputStream] = None\n    self._is_running = False\n    self._callback: Optional[Callable[[np.ndarray, int], None]] = None\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio stream is running.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.latency","title":"<code>latency</code>  <code>property</code>","text":"<p>Get current stream latency in seconds.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.sample_rate","title":"<code>sample_rate</code>  <code>property</code>","text":"<p>Get current sample rate.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the name of the current audio device.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.set_callback","title":"<code>set_callback(callback)</code>","text":"<p>Set audio callback function.</p> <p>The callback will be called with (outdata, frames) for each audio block.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ndarray, int], None]</code> <p>Function(outdata: np.ndarray, frames: int) -&gt; None</p> required Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def set_callback(self, callback: Callable[[np.ndarray, int], None]) -&gt; None:\n    \"\"\"\n    Set audio callback function.\n\n    The callback will be called with (outdata, frames) for each audio block.\n\n    Args:\n        callback: Function(outdata: np.ndarray, frames: int) -&gt; None\n    \"\"\"\n    self._callback = callback\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.start","title":"<code>start()</code>","text":"<p>Start audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio stream.\"\"\"\n    if self._is_running:\n        return\n\n    if self._callback is None:\n        raise RuntimeError(\"No audio callback set. Call set_callback() first.\")\n\n    device_id = self.device or sd.default.device[1]\n    self._validate_low_latency_device(device_id)\n    self._log_device_info(device_id)\n\n    # Select stream configuration\n    stream_kwargs = self._get_stream_config(device_id)\n\n    # Try to start the stream\n    self._start_stream(stream_kwargs)\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.stop","title":"<code>stop()</code>","text":"<p>Stop audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio stream.\"\"\"\n    if not self._is_running:\n        return\n\n    if self._stream:\n        self._stream.stop()\n        self._stream.close()\n        self._stream = None\n\n    self._is_running = False\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.list_output_devices","title":"<code>list_output_devices()</code>  <code>staticmethod</code>","text":"<p>List all available low-latency audio output devices.</p> <p>On Windows: ASIO and WASAPI devices On macOS: Core Audio devices On Linux: ALSA and JACK devices</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str, str, Any]]</code> <p>Tuple of (devices, api_names) where:</p> <code>str</code> <ul> <li>devices: List of tuples (device_id, device_name, host_api_name, device_info)</li> </ul> <code>Tuple[List[Tuple[int, str, str, Any]], str]</code> <ul> <li>api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")</li> </ul> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef list_output_devices() -&gt; Tuple[List[Tuple[int, str, str, Any]], str]:\n    \"\"\"\n    List all available low-latency audio output devices.\n\n    On Windows: ASIO and WASAPI devices\n    On macOS: Core Audio devices\n    On Linux: ALSA and JACK devices\n\n    Returns:\n        Tuple of (devices, api_names) where:\n        - devices: List of tuples (device_id, device_name, host_api_name, device_info)\n        - api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")\n    \"\"\"\n    devices = sd.query_devices()\n    hostapis = sd.query_hostapis()\n\n    low_latency_apis, api_names = AudioDevice._get_platform_apis()\n    available_devices = []\n\n    for i, device in enumerate(devices):\n        if device['max_output_channels'] &gt; 0:\n            hostapi = hostapis[device['hostapi']]\n            hostapi_name = hostapi['name']\n\n            if any(api in hostapi_name for api in low_latency_apis):\n                available_devices.append((i, device['name'], hostapi_name, device))\n\n    return available_devices, api_names\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.get_default_device","title":"<code>get_default_device()</code>  <code>staticmethod</code>","text":"<p>Get default output device ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>Device ID</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_default_device() -&gt; int:\n    \"\"\"\n    Get default output device ID.\n\n    Returns:\n        Device ID\n    \"\"\"\n    return sd.default.device[1]  # Output device\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/audio/loader/","title":"Loader","text":""},{"location":"api/audio/loader/#launchsampler.audio.loader","title":"<code>loader</code>","text":"<p>Sample loader for loading audio files.</p>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader","title":"<code>SampleLoader(target_sample_rate=None)</code>","text":"<p>Load audio files into AudioData structures.</p> <p>Handles WAV, FLAC, OGG, and other formats supported by soundfile.</p> <p>Initialize sample loader.</p> <p>Parameters:</p> Name Type Description Default <code>target_sample_rate</code> <code>Optional[int]</code> <p>If set, resample all audio to this rate.                If None, use original sample rate.</p> <code>None</code> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def __init__(self, target_sample_rate: Optional[int] = None):\n    \"\"\"\n    Initialize sample loader.\n\n    Args:\n        target_sample_rate: If set, resample all audio to this rate.\n                           If None, use original sample rate.\n    \"\"\"\n    self.target_sample_rate = target_sample_rate\n</code></pre>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader.load","title":"<code>load(path)</code>","text":"<p>Load audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData containing the loaded audio</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>RuntimeError</code> <p>If file cannot be loaded</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def load(self, path: Path) -&gt; AudioData:\n    \"\"\"\n    Load audio file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        AudioData containing the loaded audio\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        RuntimeError: If file cannot be loaded\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    try:\n        # Get file info for metadata\n        info = sf.info(str(path))\n\n        # Load audio file\n        data, sample_rate = sf.read(str(path), dtype='float32')\n\n        # Handle empty files\n        if len(data) == 0:\n            raise RuntimeError(f\"Audio file is empty: {path}\")\n\n        # Resample if needed\n        if self.target_sample_rate and sample_rate != self.target_sample_rate:\n            data = self._resample(data, sample_rate, self.target_sample_rate)\n            sample_rate = self.target_sample_rate\n\n        # Create AudioData with metadata\n        audio_data = AudioData.from_array(data, sample_rate)\n        audio_data.format = info.format\n        audio_data.subtype = info.subtype\n        return audio_data\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load audio file {path}: {e}\") from e\n</code></pre>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader.get_info","title":"<code>get_info(path)</code>  <code>staticmethod</code>","text":"<p>Get audio file info without loading the full file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'sample_rate', 'channels', 'frames', 'duration'</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>@staticmethod\ndef get_info(path: Path) -&gt; dict:\n    \"\"\"\n    Get audio file info without loading the full file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        Dictionary with 'sample_rate', 'channels', 'frames', 'duration'\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    info = sf.info(str(path))\n    return {\n        'sample_rate': info.samplerate,\n        'channels': info.channels,\n        'frames': info.frames,\n        'duration': info.duration,\n        'format': info.format,\n        'subtype': info.subtype,\n    }\n</code></pre>"},{"location":"api/audio/mixer/","title":"Mixer","text":""},{"location":"api/audio/mixer/#launchsampler.audio.mixer","title":"<code>mixer</code>","text":"<p>Audio mixer for combining multiple playback states.</p>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer","title":"<code>AudioMixer(num_channels=2)</code>","text":"<p>Mix multiple audio sources into a single output.</p> <p>Thread-safe for use in audio callbacks.</p> <p>Initialize audio mixer.</p> <p>Parameters:</p> Name Type Description Default <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def __init__(self, num_channels: int = 2):\n    \"\"\"\n    Initialize audio mixer.\n\n    Args:\n        num_channels: Number of output channels (1=mono, 2=stereo)\n    \"\"\"\n    self.num_channels = num_channels\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.mix","title":"<code>mix(playback_states, num_frames)</code>","text":"<p>Mix multiple playback states into a single buffer.</p> <p>Parameters:</p> Name Type Description Default <code>playback_states</code> <code>List[PlaybackState]</code> <p>List of PlaybackState objects to mix</p> required <code>num_frames</code> <code>int</code> <p>Number of frames to generate</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono</p> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def mix(\n    self,\n    playback_states: List[PlaybackState],\n    num_frames: int\n) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Mix multiple playback states into a single buffer.\n\n    Args:\n        playback_states: List of PlaybackState objects to mix\n        num_frames: Number of frames to generate\n\n    Returns:\n        Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono\n    \"\"\"\n    # Create output buffer\n    if self.num_channels == 1:\n        output = np.zeros(num_frames, dtype=np.float32)\n    else:\n        output = np.zeros((num_frames, self.num_channels), dtype=np.float32)\n\n    # Mix each playing source\n    for state in playback_states:\n        if not state.is_playing or state.audio_data is None:\n            continue\n\n        # Get frames from this source\n        frames = state.get_frames(num_frames)\n        if frames is None:\n            continue\n\n        # Handle channel mismatch\n        frames_to_add = self._match_channels(frames, state.audio_data.num_channels)\n\n        # Add to output (clip to available length)\n        add_length = min(len(frames_to_add), num_frames)\n        if self.num_channels == 1:\n            output[:add_length] += frames_to_add[:add_length]\n        else:\n            output[:add_length, :] += frames_to_add[:add_length, :]\n\n        # Advance the playback position\n        state.advance(add_length)\n\n    return output\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.apply_master_volume","title":"<code>apply_master_volume(buffer, volume)</code>  <code>staticmethod</code>","text":"<p>Apply master volume to buffer in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to modify</p> required <code>volume</code> <code>float</code> <p>Volume multiplier (0.0 to 1.0)</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef apply_master_volume(\n    buffer: npt.NDArray[np.float32],\n    volume: float\n) -&gt; None:\n    \"\"\"\n    Apply master volume to buffer in-place.\n\n    Args:\n        buffer: Audio buffer to modify\n        volume: Volume multiplier (0.0 to 1.0)\n    \"\"\"\n    if volume != 1.0:\n        buffer *= volume\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.clip","title":"<code>clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Clip audio buffer to valid range [-1.0, 1.0] in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Clip audio buffer to valid range [-1.0, 1.0] in-place.\n\n    Args:\n        buffer: Audio buffer to clip\n    \"\"\"\n    np.clip(buffer, -1.0, 1.0, out=buffer)\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.soft_clip","title":"<code>soft_clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Apply soft clipping (tanh) to prevent harsh distortion.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to soft clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef soft_clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Apply soft clipping (tanh) to prevent harsh distortion.\n\n    Args:\n        buffer: Audio buffer to soft clip\n    \"\"\"\n    np.tanh(buffer, out=buffer)\n</code></pre>"},{"location":"api/core/","title":"Core","text":"<p>Audio playback engine and state management</p>"},{"location":"api/core/#launchsampler.core","title":"<code>core</code>","text":"<p>Core sampler engine.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine","title":"<code>SamplerEngine(audio_device, num_pads=64, state_machine=None)</code>","text":"<p>Audio playback engine for multi-pad samplers.</p> <p>Device-agnostic engine that manages audio playback for N pads. Works with any MIDI controller that provides pad triggers.</p> <p>Composes generic audio primitives (device, loader, mixer) with pad-based playback management.</p> Threading Model <p>This engine operates across multiple threads:</p> <ol> <li>UI Thread (Textual):</li> <li>Calls load_sample() / unload_sample() via EditObserver pattern</li> <li> <p>Uses self._lock to safely modify _playback_states</p> </li> <li> <p>MIDI Thread:</p> </li> <li>Calls trigger_pad() / release_pad()</li> <li> <p>Lock-free: writes to _trigger_queue (Queue is thread-safe)</p> </li> <li> <p>Audio Callback Thread (sounddevice):</p> </li> <li>Runs _audio_callback() to mix and render audio</li> <li>Reads from _trigger_queue (lock-free)</li> <li>Reads/writes _playback_states WITHOUT lock (owns playback state)</li> </ol> <p>Lock Strategy:     - self._lock protects _playback_states during load/unload (rare ops)     - Triggers use lock-free queue for minimal latency (frequent ops)     - Audio callback avoids locks entirely to prevent audio glitches     - Stale reads during concurrent modifications are acceptable       (affects at most one 5ms audio block)</p> <p>Initialize sampler engine.</p> <p>Parameters:</p> Name Type Description Default <code>audio_device</code> <code>AudioDevice</code> <p>Configured AudioDevice instance</p> required <code>num_pads</code> <code>int</code> <p>Number of pads to manage (default: 64 for Launchpad)</p> <code>64</code> <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __init__(\n    self,\n    audio_device: AudioDevice,\n    num_pads: int = 64,\n    state_machine: Optional[SamplerStateMachine] = None\n):\n    \"\"\"\n    Initialize sampler engine.\n\n    Args:\n        audio_device: Configured AudioDevice instance\n        num_pads: Number of pads to manage (default: 64 for Launchpad)\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self._device = audio_device\n    self._num_pads = num_pads\n    self._loader = SampleLoader(target_sample_rate=audio_device.sample_rate)\n    self._mixer = AudioMixer(num_channels=audio_device.num_channels)\n\n    # Application state\n    self._audio_cache: Dict[str, AudioData] = {}  # path -&gt; AudioData\n    self._playback_states: Dict[int, PlaybackState] = {}  # pad_index -&gt; PlaybackState\n    self._master_volume = 1.0\n\n    # State machine for event dispatch (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Thread safety\n    self._lock = Lock()  # Only for sample loading/unloading, not for triggers\n\n    # Lock-free trigger queue for low-latency pad triggering\n    # Sized generously to handle burst inputs without blocking\n    self._trigger_queue: Queue[tuple[str, int]] = Queue(maxsize=256)\n\n    # Register audio callback\n    self._device.set_callback(self._audio_callback)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio device is running.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads managed by this engine.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.load_sample","title":"<code>load_sample(pad_index, pad, normalize=True)</code>","text":"<p>Load audio sample for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>pad</code> <code>Pad</code> <p>Pad model with sample information</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize audio after loading</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict from concurrent modification with the audio callback thread. File I/O occurs outside the lock for better performance.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def load_sample(self, pad_index: int, pad: Pad, normalize: bool = True) -&gt; bool:\n    \"\"\"\n    Load audio sample for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        pad: Pad model with sample information\n        normalize: Whether to normalize audio after loading\n\n    Returns:\n        True if loaded successfully, False otherwise\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict from\n        concurrent modification with the audio callback thread.\n        File I/O occurs outside the lock for better performance.\n    \"\"\"\n    if pad_index &lt; 0 or pad_index &gt;= self._num_pads:\n        logger.error(f\"Invalid pad index: {pad_index} (valid: 0-{self._num_pads-1})\")\n        return False\n\n    if not pad.is_assigned or pad.sample is None:\n        return False\n\n    path_str = str(pad.sample.path)\n\n    try:\n        # Check cache first\n        if path_str not in self._audio_cache:\n            audio_data = self._loader.load(pad.sample.path)\n            self._audio_cache[path_str] = audio_data\n        else:\n            audio_data = self._audio_cache[path_str]\n\n        # Normalize audio if needed\n        if normalize:\n            audio_data.normalize()\n\n        # Create or update playback state\n        with self._lock:\n            if pad_index not in self._playback_states:\n                self._playback_states[pad_index] = PlaybackState()\n\n            state = self._playback_states[pad_index]\n            state.audio_data = audio_data\n            state.mode = pad.mode\n            state.volume = pad.volume\n            state.reset()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error loading sample for pad {pad_index}: {e}\")\n        return False\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.unload_sample","title":"<code>unload_sample(pad_index)</code>","text":"<p>Unload sample from pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict. If a pad is triggered after unloading but before the audio callback processes it, the callback safely skips missing pads (see _audio_callback line ~347).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unload_sample(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Unload sample from pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict.\n        If a pad is triggered after unloading but before the\n        audio callback processes it, the callback safely skips\n        missing pads (see _audio_callback line ~347).\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            was_playing = self._playback_states[pad_index].is_playing\n            self._playback_states[pad_index].stop()\n            # Remove the entry entirely to ensure fresh state when reloading\n            del self._playback_states[pad_index]\n\n            # Notify state machine if pad was playing\n            if was_playing:\n                self._state_machine.notify_pad_stopped(pad_index)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger playback for a pad.</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger playback for a pad.\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write - if queue is full, drop the trigger\n        # This should never happen with a 256-entry queue unless system is severely overloaded\n        self._trigger_queue.put_nowait((\"trigger\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} trigger\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release pad (for HOLD and LOOP modes).</p> <p>For HOLD mode: Stops playback immediately For LOOP mode: Stops looping For ONE_SHOT mode: Does nothing (sample plays fully)</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release pad (for HOLD and LOOP modes).\n\n    For HOLD mode: Stops playback immediately\n    For LOOP mode: Stops looping\n    For ONE_SHOT mode: Does nothing (sample plays fully)\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"release\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} release\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop playback for a pad (works for all modes).</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop playback for a pad (works for all modes).\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"stop\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> <p>Uses the queue mechanism to ensure proper playback events are fired.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"\n    Stop all playing pads.\n\n    Uses the queue mechanism to ensure proper playback events are fired.\n    \"\"\"\n    # Get all pad indices (need lock to safely read keys)\n    with self._lock:\n        pad_indices = list(self._playback_states.keys())\n\n    # Queue stop actions for all pads (lock-free)\n    for pad_index in pad_indices:\n        try:\n            self._trigger_queue.put_nowait((\"stop\", pad_index))\n        except Full:\n            logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop during stop_all\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.update_pad_volume","title":"<code>update_pad_volume(pad_index, volume)</code>","text":"<p>Update volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_volume(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Update volume for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        volume: New volume (0.0-1.0)\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].volume = volume\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.update_pad_mode","title":"<code>update_pad_mode(pad_index, mode)</code>","text":"<p>Update playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; None:\n    \"\"\"\n    Update playback mode for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        mode: New playback mode\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].mode = mode\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    self._master_volume = max(0.0, min(1.0, volume))\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_machine.register_observer(observer)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_machine.unregister_observer(observer)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing, False otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        True if pad is playing, False otherwise\n    \"\"\"\n    return self._state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pad indices.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pad indices.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    return self._state_machine.get_playing_pads()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_playback_info","title":"<code>get_playback_info(pad_index)</code>","text":"<p>Get playback information for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with playback info or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playback_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get playback information for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with playback info or None\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return {\n            'is_playing': state.is_playing,\n            'progress': state.progress,\n            'time_elapsed': state.time_elapsed,\n            'time_remaining': state.time_remaining,\n            'mode': state.mode.value,\n            'volume': state.volume,\n        }\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get AudioData for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get AudioData for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return state.audio_data\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_audio_info","title":"<code>get_audio_info(pad_index)</code>","text":"<p>Get audio file information for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with audio info including duration, sample rate, channels, format, etc., or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get audio file information for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with audio info including duration, sample rate, channels, format, etc., or None\n    \"\"\"\n    audio_data = self.get_audio_data(pad_index)\n    return audio_data.get_info() if audio_data else None\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear audio cache (useful to free memory).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear audio cache (useful to free memory).\"\"\"\n    with self._lock:\n        self._audio_cache.clear()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.start","title":"<code>start()</code>","text":"<p>Start audio device and begin playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio device and begin playback.\"\"\"\n    self._device.start()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop","title":"<code>stop()</code>","text":"<p>Stop audio device and all playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio device and all playback.\"\"\"\n    self.stop_all()\n    self._device.stop()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/player/","title":"Player","text":""},{"location":"api/core/player/#launchsampler.core.player","title":"<code>player</code>","text":"<p>Core player logic - UI-agnostic.</p> <p>This can be used in: - TUI application - GUI application - Headless server - CLI tool - Test environment</p>"},{"location":"api/core/player/#launchsampler.core.player.Player","title":"<code>Player(config, state_machine=None)</code>","text":"<p>               Bases: <code>StateObserver</code>, <code>EditObserver</code>, <code>MidiObserver</code></p> <p>Core player for Launchpad sampling.</p> <p>This class manages audio playback without any UI dependencies. It can be used in any application (TUI, GUI, CLI, headless).</p> <p>Implements: - StateObserver: for playback events from audio engine - EditObserver: for editing events from editor service - MidiObserver: for MIDI input events (triggered by orchestrator)</p> <p>Responsibilities: - Audio engine lifecycle - Playback state observation - Edit event observation and audio sync - MIDI input observation and audio triggering - Set loading into audio engine</p> <p>NOT responsible for: - MIDI controller lifecycle (managed by orchestrator) - UI rendering - User input beyond MIDI - Editing operations - File browsing</p> <p>Initialize player.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __init__(self, config: AppConfig, state_machine: Optional[SamplerStateMachine] = None):\n    \"\"\"\n    Initialize player.\n\n    Args:\n        config: Application configuration\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self.config = config\n    self.current_set: Optional[Set] = None\n\n    # State machine (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Audio components\n    self._audio_device: Optional[AudioDevice] = None\n    self._engine: Optional[SamplerEngine] = None\n\n    # Callbacks for external notification (deprecated - use register_state_observer)\n    self._on_playback_change: Optional[Callable[[PlaybackEvent, int], None]] = None\n\n    # State observers (multiple observers supported)\n    self._state_observers = ObserverManager[StateObserver](observer_type_name=\"state\")\n\n    # State\n    self._is_running = False\n    logger.info(\"Player initialized\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if player is running.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.audio_device_name","title":"<code>audio_device_name</code>  <code>property</code>","text":"<p>Get name of audio device.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.engine","title":"<code>engine</code>  <code>property</code>","text":"<p>Get the sampler engine (read-only access).</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.start","title":"<code>start(initial_set=None)</code>","text":"<p>Start player (audio only - MIDI is managed by orchestrator).</p> <p>Parameters:</p> Name Type Description Default <code>initial_set</code> <code>Optional[Set]</code> <p>Optional set to load on startup</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if started successfully</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def start(self, initial_set: Optional[Set] = None) -&gt; bool:\n    \"\"\"\n    Start player (audio only - MIDI is managed by orchestrator).\n\n    Args:\n        initial_set: Optional set to load on startup\n\n    Returns:\n        True if started successfully\n    \"\"\"\n    if self._is_running:\n        logger.warning(\"Player already running\")\n        return True\n\n    # Load initial set if provided\n    if initial_set:\n        self.current_set = initial_set\n\n    # Start audio engine\n    if not self._start_audio():\n        logger.error(\"Failed to start audio\")\n        return False\n\n    self._is_running = True\n    logger.info(\"Player started\")\n    return True\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop","title":"<code>stop()</code>","text":"<p>Stop player (audio only - MIDI is managed by orchestrator).</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop player (audio only - MIDI is managed by orchestrator).\"\"\"\n    if not self._is_running:\n        return\n\n    self._stop_audio()\n\n    self._is_running = False\n    logger.info(\"Player stopped\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.load_set","title":"<code>load_set(set_obj)</code>","text":"<p>Load a new set.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>Set to load</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def load_set(self, set_obj: Set) -&gt; None:\n    \"\"\"\n    Load a new set.\n\n    Args:\n        set_obj: Set to load\n    \"\"\"\n    self.current_set = set_obj\n\n    # Load into engine if running\n    if self._engine and self._is_running:\n        self._load_set_into_engine(set_obj)\n\n    logger.info(f\"Loaded set: {set_obj.name} with {len(set_obj.launchpad.assigned_pads)} samples\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger a pad (from any source: MIDI, keyboard, UI, etc).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to trigger (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger a pad (from any source: MIDI, keyboard, UI, etc).\n\n    Args:\n        pad_index: Index of pad to trigger (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.trigger_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release a pad (for HOLD/LOOP modes).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to release (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release a pad (for HOLD/LOOP modes).\n\n    Args:\n        pad_index: Index of pad to release (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.release_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop a specific pad immediately (works for all modes).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to stop (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop a specific pad immediately (works for all modes).\n\n    Args:\n        pad_index: Index of pad to stop (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.stop_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"Stop all playing pads.\"\"\"\n    if self._engine:\n        self._engine.stop_all()\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    if self._engine:\n        self._engine.set_master_volume(volume)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>This is called from the MIDI thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_midi_event(self, event: MidiEvent, pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    This is called from the MIDI thread.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    if event == MidiEvent.NOTE_ON:\n        # MIDI pad pressed - trigger audio if sample is assigned\n        if self.current_set and pad_index &gt;= 0:\n            pad = self.current_set.launchpad.pads[pad_index]\n            if pad.is_assigned:\n                self.trigger_pad(pad_index)\n        else:\n            logger.warning(f\"MIDI NOTE_ON received but cannot trigger: current_set={self.current_set is not None}, pad_index={pad_index}\")\n\n    elif event == MidiEvent.NOTE_OFF:\n        # MIDI pad released - release audio if mode supports it\n        if self.current_set and pad_index &gt;= 0:\n            pad = self.current_set.launchpad.pads[pad_index]\n            if pad.is_assigned and pad.mode in (PlaybackMode.LOOP, PlaybackMode.HOLD):\n                self.release_pad(pad_index)\n\n    elif event == MidiEvent.CONTROL_CHANGE:\n        # Handle panic button (stop all audio)\n        if (control == self.config.panic_button_cc_control and\n            value == self.config.panic_button_cc_value):\n            logger.info(f\"Panic button triggered via MIDI CC (control={control}, value={value})\")\n            self.stop_all()\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>This is called from the audio thread, so we forward to all observers.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    This is called from the audio thread, so we forward to all observers.\n    \"\"\"\n    # Legacy callback support (deprecated)\n    if self._on_playback_change:\n        self._on_playback_change(event, pad_index)\n\n    # Notify all state observers\n    self._state_observers.notify('on_playback_event', event, pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and sync audio engine.</p> <p>This eliminates the need for manual _reload_pad() calls throughout the codebase. When any editing operation occurs (assign, clear, move, etc.), this observer automatically syncs the audio engine.</p> Threading <p>Called from the UI thread (Textual's main loop). Delegates to SamplerEngine methods which use locks for thread safety.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_edit_event(\n    self,\n    event: EditEvent,\n    pad_indices: list[int],\n    pads: list\n) -&gt; None:\n    \"\"\"\n    Handle editing events and sync audio engine.\n\n    This eliminates the need for manual _reload_pad() calls throughout\n    the codebase. When any editing operation occurs (assign, clear, move,\n    etc.), this observer automatically syncs the audio engine.\n\n    Threading:\n        Called from the UI thread (Textual's main loop).\n        Delegates to SamplerEngine methods which use locks for thread safety.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    if not self._engine:\n        return\n\n    logger.debug(f\"Player received edit event: {event.value} for pads {pad_indices}\")\n\n    for pad_index, pad in zip(pad_indices, pads):\n        if event in (\n            EditEvent.PAD_ASSIGNED,\n            EditEvent.PAD_DUPLICATED,\n            EditEvent.PAD_MODE_CHANGED\n        ):\n            # Reload sample into engine\n            if pad.is_assigned:\n                logger.info(f\"Loading sample '{pad.sample.name}' into pad {pad_index} (event: {event.value})\")\n                self._engine.load_sample(pad_index, pad)\n            else:\n                logger.info(f\"Unloading pad {pad_index} (event: {event.value})\")\n                self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_MOVED:\n            # For moves, reload both pads (source and target)\n            if pad.is_assigned:\n                logger.info(f\"Loading sample '{pad.sample.name}' into pad {pad_index} (moved)\")\n                self._engine.load_sample(pad_index, pad)\n            else:\n                logger.info(f\"Unloading pad {pad_index} (moved)\")\n                self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_CLEARED:\n            # Unload sample\n            logger.info(f\"Unloading pad {pad_index} (cleared)\")\n            self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_VOLUME_CHANGED:\n            # Update volume without reloading (more efficient)\n            logger.debug(f\"Updating volume for pad {pad_index} to {pad.volume}\")\n            self._engine.update_pad_volume(pad_index, pad.volume)\n\n        elif event == EditEvent.PADS_CLEARED:\n            # Multiple pads cleared - reload each\n            logger.info(f\"Unloading multiple pads: {pad_indices}\")\n            for idx, p in zip(pad_indices, pads):\n                self._engine.unload_sample(idx)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.register_state_observer","title":"<code>register_state_observer(observer)</code>","text":"<p>Register an observer for playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def register_state_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer for playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_observers.register(observer)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.unregister_state_observer","title":"<code>unregister_state_observer(observer)</code>","text":"<p>Unregister a state observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def unregister_state_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister a state observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_observers.unregister(observer)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.set_playback_callback","title":"<code>set_playback_callback(callback)</code>","text":"<p>Register callback for playback events (DEPRECATED).</p> <p>Use register_state_observer() instead for proper observer pattern support.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[PlaybackEvent, int], None]</code> <p>Function to call on playback events (from audio engine)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def set_playback_callback(self, callback: Callable[[PlaybackEvent, int], None]) -&gt; None:\n    \"\"\"\n    Register callback for playback events (DEPRECATED).\n\n    Use register_state_observer() instead for proper observer pattern support.\n\n    Args:\n        callback: Function to call on playback events (from audio engine)\n    \"\"\"\n    self._on_playback_change = callback\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Index of pad to check\n\n    Returns:\n        True if pad is playing\n    \"\"\"\n    return self._engine.is_pad_playing(pad_index) if self._engine else False\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pads.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pads.\n\n    Returns:\n        List of pad indices\n    \"\"\"\n    return self._engine.get_playing_pads() if self._engine else []\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get audio waveform data for a pad (for visualization).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get audio data for</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get audio waveform data for a pad (for visualization).\n\n    Args:\n        pad_index: Index of pad to get audio data for\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    if self._engine:\n        return self._engine.get_audio_data(pad_index)\n    return None\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/sampler_engine/","title":"Sampler Engine","text":""},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine","title":"<code>sampler_engine</code>","text":"<p>Device-agnostic audio playback engine for multi-pad samplers.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine","title":"<code>SamplerEngine(audio_device, num_pads=64, state_machine=None)</code>","text":"<p>Audio playback engine for multi-pad samplers.</p> <p>Device-agnostic engine that manages audio playback for N pads. Works with any MIDI controller that provides pad triggers.</p> <p>Composes generic audio primitives (device, loader, mixer) with pad-based playback management.</p> Threading Model <p>This engine operates across multiple threads:</p> <ol> <li>UI Thread (Textual):</li> <li>Calls load_sample() / unload_sample() via EditObserver pattern</li> <li> <p>Uses self._lock to safely modify _playback_states</p> </li> <li> <p>MIDI Thread:</p> </li> <li>Calls trigger_pad() / release_pad()</li> <li> <p>Lock-free: writes to _trigger_queue (Queue is thread-safe)</p> </li> <li> <p>Audio Callback Thread (sounddevice):</p> </li> <li>Runs _audio_callback() to mix and render audio</li> <li>Reads from _trigger_queue (lock-free)</li> <li>Reads/writes _playback_states WITHOUT lock (owns playback state)</li> </ol> <p>Lock Strategy:     - self._lock protects _playback_states during load/unload (rare ops)     - Triggers use lock-free queue for minimal latency (frequent ops)     - Audio callback avoids locks entirely to prevent audio glitches     - Stale reads during concurrent modifications are acceptable       (affects at most one 5ms audio block)</p> <p>Initialize sampler engine.</p> <p>Parameters:</p> Name Type Description Default <code>audio_device</code> <code>AudioDevice</code> <p>Configured AudioDevice instance</p> required <code>num_pads</code> <code>int</code> <p>Number of pads to manage (default: 64 for Launchpad)</p> <code>64</code> <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __init__(\n    self,\n    audio_device: AudioDevice,\n    num_pads: int = 64,\n    state_machine: Optional[SamplerStateMachine] = None\n):\n    \"\"\"\n    Initialize sampler engine.\n\n    Args:\n        audio_device: Configured AudioDevice instance\n        num_pads: Number of pads to manage (default: 64 for Launchpad)\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self._device = audio_device\n    self._num_pads = num_pads\n    self._loader = SampleLoader(target_sample_rate=audio_device.sample_rate)\n    self._mixer = AudioMixer(num_channels=audio_device.num_channels)\n\n    # Application state\n    self._audio_cache: Dict[str, AudioData] = {}  # path -&gt; AudioData\n    self._playback_states: Dict[int, PlaybackState] = {}  # pad_index -&gt; PlaybackState\n    self._master_volume = 1.0\n\n    # State machine for event dispatch (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Thread safety\n    self._lock = Lock()  # Only for sample loading/unloading, not for triggers\n\n    # Lock-free trigger queue for low-latency pad triggering\n    # Sized generously to handle burst inputs without blocking\n    self._trigger_queue: Queue[tuple[str, int]] = Queue(maxsize=256)\n\n    # Register audio callback\n    self._device.set_callback(self._audio_callback)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio device is running.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads managed by this engine.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.load_sample","title":"<code>load_sample(pad_index, pad, normalize=True)</code>","text":"<p>Load audio sample for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>pad</code> <code>Pad</code> <p>Pad model with sample information</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize audio after loading</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict from concurrent modification with the audio callback thread. File I/O occurs outside the lock for better performance.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def load_sample(self, pad_index: int, pad: Pad, normalize: bool = True) -&gt; bool:\n    \"\"\"\n    Load audio sample for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        pad: Pad model with sample information\n        normalize: Whether to normalize audio after loading\n\n    Returns:\n        True if loaded successfully, False otherwise\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict from\n        concurrent modification with the audio callback thread.\n        File I/O occurs outside the lock for better performance.\n    \"\"\"\n    if pad_index &lt; 0 or pad_index &gt;= self._num_pads:\n        logger.error(f\"Invalid pad index: {pad_index} (valid: 0-{self._num_pads-1})\")\n        return False\n\n    if not pad.is_assigned or pad.sample is None:\n        return False\n\n    path_str = str(pad.sample.path)\n\n    try:\n        # Check cache first\n        if path_str not in self._audio_cache:\n            audio_data = self._loader.load(pad.sample.path)\n            self._audio_cache[path_str] = audio_data\n        else:\n            audio_data = self._audio_cache[path_str]\n\n        # Normalize audio if needed\n        if normalize:\n            audio_data.normalize()\n\n        # Create or update playback state\n        with self._lock:\n            if pad_index not in self._playback_states:\n                self._playback_states[pad_index] = PlaybackState()\n\n            state = self._playback_states[pad_index]\n            state.audio_data = audio_data\n            state.mode = pad.mode\n            state.volume = pad.volume\n            state.reset()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error loading sample for pad {pad_index}: {e}\")\n        return False\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.unload_sample","title":"<code>unload_sample(pad_index)</code>","text":"<p>Unload sample from pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict. If a pad is triggered after unloading but before the audio callback processes it, the callback safely skips missing pads (see _audio_callback line ~347).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unload_sample(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Unload sample from pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict.\n        If a pad is triggered after unloading but before the\n        audio callback processes it, the callback safely skips\n        missing pads (see _audio_callback line ~347).\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            was_playing = self._playback_states[pad_index].is_playing\n            self._playback_states[pad_index].stop()\n            # Remove the entry entirely to ensure fresh state when reloading\n            del self._playback_states[pad_index]\n\n            # Notify state machine if pad was playing\n            if was_playing:\n                self._state_machine.notify_pad_stopped(pad_index)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger playback for a pad.</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger playback for a pad.\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write - if queue is full, drop the trigger\n        # This should never happen with a 256-entry queue unless system is severely overloaded\n        self._trigger_queue.put_nowait((\"trigger\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} trigger\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release pad (for HOLD and LOOP modes).</p> <p>For HOLD mode: Stops playback immediately For LOOP mode: Stops looping For ONE_SHOT mode: Does nothing (sample plays fully)</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release pad (for HOLD and LOOP modes).\n\n    For HOLD mode: Stops playback immediately\n    For LOOP mode: Stops looping\n    For ONE_SHOT mode: Does nothing (sample plays fully)\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"release\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} release\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop playback for a pad (works for all modes).</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop playback for a pad (works for all modes).\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"stop\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> <p>Uses the queue mechanism to ensure proper playback events are fired.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"\n    Stop all playing pads.\n\n    Uses the queue mechanism to ensure proper playback events are fired.\n    \"\"\"\n    # Get all pad indices (need lock to safely read keys)\n    with self._lock:\n        pad_indices = list(self._playback_states.keys())\n\n    # Queue stop actions for all pads (lock-free)\n    for pad_index in pad_indices:\n        try:\n            self._trigger_queue.put_nowait((\"stop\", pad_index))\n        except Full:\n            logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop during stop_all\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.update_pad_volume","title":"<code>update_pad_volume(pad_index, volume)</code>","text":"<p>Update volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_volume(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Update volume for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        volume: New volume (0.0-1.0)\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].volume = volume\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.update_pad_mode","title":"<code>update_pad_mode(pad_index, mode)</code>","text":"<p>Update playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; None:\n    \"\"\"\n    Update playback mode for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        mode: New playback mode\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].mode = mode\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    self._master_volume = max(0.0, min(1.0, volume))\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_machine.register_observer(observer)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_machine.unregister_observer(observer)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing, False otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        True if pad is playing, False otherwise\n    \"\"\"\n    return self._state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pad indices.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pad indices.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    return self._state_machine.get_playing_pads()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_playback_info","title":"<code>get_playback_info(pad_index)</code>","text":"<p>Get playback information for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with playback info or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playback_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get playback information for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with playback info or None\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return {\n            'is_playing': state.is_playing,\n            'progress': state.progress,\n            'time_elapsed': state.time_elapsed,\n            'time_remaining': state.time_remaining,\n            'mode': state.mode.value,\n            'volume': state.volume,\n        }\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get AudioData for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get AudioData for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return state.audio_data\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_audio_info","title":"<code>get_audio_info(pad_index)</code>","text":"<p>Get audio file information for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with audio info including duration, sample rate, channels, format, etc., or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get audio file information for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with audio info including duration, sample rate, channels, format, etc., or None\n    \"\"\"\n    audio_data = self.get_audio_data(pad_index)\n    return audio_data.get_info() if audio_data else None\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear audio cache (useful to free memory).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear audio cache (useful to free memory).\"\"\"\n    with self._lock:\n        self._audio_cache.clear()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.start","title":"<code>start()</code>","text":"<p>Start audio device and begin playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio device and begin playback.\"\"\"\n    self._device.start()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop","title":"<code>stop()</code>","text":"<p>Stop audio device and all playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio device and all playback.\"\"\"\n    self.stop_all()\n    self._device.stop()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/state_machine/","title":"State Machine","text":""},{"location":"api/core/state_machine/#launchsampler.core.state_machine","title":"<code>state_machine</code>","text":"<p>State machine for managing sampler playback state and event dispatch.</p>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine","title":"<code>SamplerStateMachine()</code>","text":"<p>Manages playback state and dispatches events to observers.</p> <p>This class acts as the single source of truth for playback state and coordinates event dispatch to registered observers. It is thread-safe and designed to be called from the audio thread.</p> <p>The state machine tracks: - Which pads are currently playing - Which pads are triggered but not yet playing - Registered observers that receive events</p> <p>Initialize the state machine.</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the state machine.\"\"\"\n    self._lock = Lock()\n    self._playing_pads: set[int] = set()\n    self._triggered_pads: set[int] = set()\n    # ObserverManager has its own lock - don't share to avoid deadlock when notifying while holding _lock\n    self._observers = ObserverManager[StateObserver](observer_type_name=\"state\")\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_triggered","title":"<code>notify_pad_triggered(pad_index)</code>","text":"<p>Notify that a pad trigger event occurred (note on received).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of triggered pad</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_triggered(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad trigger event occurred (note on received).\n\n    Args:\n        pad_index: Index of triggered pad\n    \"\"\"\n    with self._lock:\n        self._triggered_pads.add(pad_index)\n    # Notify observers AFTER releasing lock to avoid deadlock\n    self._notify_observers(PlaybackEvent.PAD_TRIGGERED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_playing","title":"<code>notify_pad_playing(pad_index)</code>","text":"<p>Notify that a pad playing event occurred (audio started).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that started playing</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_playing(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad playing event occurred (audio started).\n\n    Args:\n        pad_index: Index of pad that started playing\n    \"\"\"\n    with self._lock:\n        self._triggered_pads.discard(pad_index)\n        self._playing_pads.add(pad_index)\n    # Notify observers AFTER releasing lock to avoid deadlock\n    self._notify_observers(PlaybackEvent.PAD_PLAYING, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_stopped","title":"<code>notify_pad_stopped(pad_index)</code>","text":"<p>Notify that a pad stopped event occurred (note off or interrupt).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that was stopped</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_stopped(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad stopped event occurred (note off or interrupt).\n\n    Args:\n        pad_index: Index of pad that was stopped\n    \"\"\"\n    with self._lock:\n        was_playing = pad_index in self._playing_pads\n        self._triggered_pads.discard(pad_index)\n        self._playing_pads.discard(pad_index)\n\n    # Notify observers AFTER releasing lock to avoid deadlock\n    if was_playing:\n        self._notify_observers(PlaybackEvent.PAD_STOPPED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_finished","title":"<code>notify_pad_finished(pad_index)</code>","text":"<p>Notify that a pad finished event occurred (playback completed naturally).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that finished playing</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_finished(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad finished event occurred (playback completed naturally).\n\n    Args:\n        pad_index: Index of pad that finished playing\n    \"\"\"\n    with self._lock:\n        was_playing = pad_index in self._playing_pads\n        self._playing_pads.discard(pad_index)\n\n    # Notify observers AFTER releasing lock to avoid deadlock\n    if was_playing:\n        self._notify_observers(PlaybackEvent.PAD_FINISHED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Index of pad to check\n\n    Returns:\n        True if pad is playing\n    \"\"\"\n    with self._lock:\n        return pad_index in self._playing_pads\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pads.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pads.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    with self._lock:\n        return list(self._playing_pads)\n</code></pre>"},{"location":"api/devices/","title":"Devices","text":"<p>MIDI device interface and hardware adapters</p>"},{"location":"api/devices/#launchsampler.devices","title":"<code>devices</code>","text":"<p>Generic device infrastructure for grid-based MIDI controllers.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController","title":"<code>DeviceController(poll_interval=5.0)</code>","text":"<p>High-level controller for grid-based MIDI devices.</p> <p>Composes MidiManager with device registry to provide a clean, user-facing API for controlling any supported grid device (Launchpad, APC, etc.).</p> <p>The controller automatically detects connected devices using the registry and provides a unified API regardless of the specific hardware model.</p> <p>Initialize device controller.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __init__(self, poll_interval: float = 5.0):\n    \"\"\"\n    Initialize device controller.\n\n    Args:\n        poll_interval: How often to check for device changes (seconds)\n    \"\"\"\n    # Create device registry\n    self._registry = DeviceRegistry()\n\n    # Detected device config (set when device is detected)\n    self._detected_config: Optional[DeviceConfig] = None\n\n    # Use generic MidiManager with config-driven device filter and port selectors\n    self._midi = MidiManager(\n        device_filter=self._device_filter,\n        poll_interval=poll_interval,\n        input_port_selector=self._select_input_port,\n        output_port_selector=self._select_output_port\n    )\n    self._midi.on_message(self._handle_message)\n    self._midi.on_connection_changed(self._handle_connection_changed)\n\n    # Observer pattern for MIDI events\n    self._observers = ObserverManager[MidiObserver](observer_type_name=\"MIDI\")\n\n    # Device instance (created when connected)\n    self._device: Optional[GenericDevice] = None\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if a device is connected.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the model name of the connected device.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.start","title":"<code>start()</code>","text":"<p>Start monitoring for supported MIDI devices.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for supported MIDI devices.\"\"\"\n    self._midi.start()\n    logger.info(\"DeviceController started\")\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    # Shutdown device output (exit programmer mode) before stopping MIDI\n    if self._device:\n        try:\n            self._device.output.shutdown()\n            logger.info(\"Device shut down\")\n        except Exception as e:\n            logger.error(f\"Error shutting down device: {e}\")\n        self._device = None\n\n    self._midi.stop()\n    logger.info(\"DeviceController stopped\")\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register observer for MIDI events.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def register_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Register observer for MIDI events.\"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister observer.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def unregister_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Unregister observer.\"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_color","title":"<code>set_pad_color(pad_index, color)</code>","text":"<p>Set LED color for a pad (RGB mode).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_color(self, pad_index: int, color: Color) -&gt; bool:\n    \"\"\"\n    Set LED color for a pad (RGB mode).\n\n    Args:\n        pad_index: Pad 0-63\n        color: RGB color\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad color: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad color: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Bulk update multiple LED colors (more efficient than individual updates).</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[tuple[int, Color]]</code> <p>List of (pad_index, color) tuples</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_leds_bulk(self, updates: list[tuple[int, Color]]) -&gt; bool:\n    \"\"\"\n    Bulk update multiple LED colors (more efficient than individual updates).\n\n    Args:\n        updates: List of (pad_index, color) tuples\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set LEDs bulk: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_leds_bulk(updates)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting LEDs bulk: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_static","title":"<code>set_pad_static(pad_index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_static(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad static: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_static(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad static: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_flashing","title":"<code>set_pad_flashing(pad_index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_flashing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad flashing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_flashing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad flashing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_pulsing","title":"<code>set_pad_pulsing(pad_index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_pulsing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad pulsing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_pulsing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad pulsing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceEvent","title":"<code>DeviceEvent</code>","text":"<p>Generic device event (input from hardware).</p>"},{"location":"api/devices/#launchsampler.devices.PadPressEvent","title":"<code>PadPressEvent(pad_index, velocity)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was pressed.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int, velocity: int):\n    self.pad_index = pad_index  # Logical 0-63\n    self.velocity = velocity\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.PadReleaseEvent","title":"<code>PadReleaseEvent(pad_index)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was released.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int):\n    self.pad_index = pad_index  # Logical 0-63\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceInput","title":"<code>DeviceInput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device input handling.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming message into device event.</p> <p>Must handle hardware-specific note mapping internally and return events with logical pad indices (0-63).</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def parse_message(self, msg) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming message into device event.\n\n    Must handle hardware-specific note mapping internally and\n    return events with logical pad indices (0-63).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput","title":"<code>DeviceOutput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device output/display control.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the output device.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the output device.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown and cleanup.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown and cleanup.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED by logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_led(self, index: int, color: 'Color') -&gt; None:\n    \"\"\"\n    Set single LED by logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, 'Color']]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/config/","title":"Config","text":""},{"location":"api/devices/config/#launchsampler.devices.config","title":"<code>config</code>","text":"<p>Pydantic-based device configuration for runtime use.</p> <p>This module defines DeviceConfig, which is the flattened runtime representation created by merging family defaults with device-specific overrides.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig","title":"<code>DeviceConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Flattened device configuration (family + device merged).</p> <p>This is the runtime representation used by the application. Created by merging family defaults with device-specific overrides.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Human-readable device name.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Number of pads on device.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Grid size.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.matches","title":"<code>matches(port_name)</code>","text":"<p>Check if port name matches this device's detection patterns.</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def matches(self, port_name: str) -&gt; bool:\n    \"\"\"Check if port name matches this device's detection patterns.\"\"\"\n    return any(pattern in port_name for pattern in self.detection_patterns)\n</code></pre>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.select_input_port","title":"<code>select_input_port(matching_ports)</code>","text":"<p>Select best input port from matching ports using OS-specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>matching_ports</code> <code>list[str]</code> <p>List of port names that already match detection patterns</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Selected port name or None if list is empty</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def select_input_port(self, matching_ports: list[str]) -&gt; Optional[str]:\n    \"\"\"\n    Select best input port from matching ports using OS-specific rules.\n\n    Args:\n        matching_ports: List of port names that already match detection patterns\n\n    Returns:\n        Selected port name or None if list is empty\n    \"\"\"\n    if not matching_ports:\n        return None\n\n    rules = self.input_port_selection.get_for_current_os()\n    return self._apply_port_rules(matching_ports, rules)\n</code></pre>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.select_output_port","title":"<code>select_output_port(matching_ports)</code>","text":"<p>Select best output port from matching ports using OS-specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>matching_ports</code> <code>list[str]</code> <p>List of port names that already match detection patterns</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Selected port name or None if list is empty</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def select_output_port(self, matching_ports: list[str]) -&gt; Optional[str]:\n    \"\"\"\n    Select best output port from matching ports using OS-specific rules.\n\n    Args:\n        matching_ports: List of port names that already match detection patterns\n\n    Returns:\n        Selected port name or None if list is empty\n    \"\"\"\n    if not matching_ports:\n        return None\n\n    rules = self.output_port_selection.get_for_current_os()\n    return self._apply_port_rules(matching_ports, rules)\n</code></pre>"},{"location":"api/devices/controller/","title":"Controller","text":""},{"location":"api/devices/controller/#launchsampler.devices.controller","title":"<code>controller</code>","text":"<p>Generic device controller for grid-based MIDI controllers.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--architecture-overview","title":"Architecture Overview","text":"<p>The DeviceController is the main user-facing API for interacting with MIDI grid controllers. It sits at the top of the device architecture and hides all hardware complexity from the application.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--connection-flow","title":"Connection Flow","text":"<p>::</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         USER APPLICATION                            \u2502\n\u2502                    (Your Sampler Software)                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                    Uses high-level API\n                             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DeviceController                                 \u2502\n\u2502                  (devices/controller.py)                            \u2502\n\u2502                                                                     \u2502\n\u2502  \ud83c\udfae What it does:                                                   \u2502\n\u2502    - Manages connection to the device                              \u2502\n\u2502    - Provides user-friendly methods (set_pad_color, etc.)          \u2502\n\u2502    - Handles observers (notify when buttons pressed)               \u2502\n\u2502    - Hides all the complexity below                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                 \u2502                        \u2502\n    Asks for help    Detects devices         Sends messages\n           \u2193                 \u2193                        \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 DeviceRegistry\u2502 \u2502 MidiManager  \u2502      \u2502  MidiManager    \u2502\n   \u2502 (registry.py) \u2502 \u2502 (generic)    \u2502      \u2502  (output)       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n    Loads config &amp;\n    creates device\n           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        GenericDevice                                 \u2502\n\u2502                         (device.py)                                  \u2502\n\u2502                                                                      \u2502\n\u2502  Two sides:                                                          \u2502\n\u2502    - Input: MIDI messages \u2192 Events (button presses)                 \u2502\n\u2502    - Output: Commands \u2192 MIDI messages (LED control)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller--key-design-principle","title":"Key Design Principle","text":"<p>The DeviceController knows NOTHING about: - MIDI note numbers - SysEx messages - Hardware-specific quirks</p> <p>It only deals with logical pad indices (0-63) and abstract colors. All hardware translation happens in the layers below.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--usage-example","title":"Usage Example","text":"<p>.. code-block:: python</p> <pre><code>controller = DeviceController()\ncontroller.start()\ncontroller.set_pad_color(21, Color(255, 0, 0))  # Works with ANY device!\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController","title":"<code>DeviceController(poll_interval=5.0)</code>","text":"<p>High-level controller for grid-based MIDI devices.</p> <p>Composes MidiManager with device registry to provide a clean, user-facing API for controlling any supported grid device (Launchpad, APC, etc.).</p> <p>The controller automatically detects connected devices using the registry and provides a unified API regardless of the specific hardware model.</p> <p>Initialize device controller.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __init__(self, poll_interval: float = 5.0):\n    \"\"\"\n    Initialize device controller.\n\n    Args:\n        poll_interval: How often to check for device changes (seconds)\n    \"\"\"\n    # Create device registry\n    self._registry = DeviceRegistry()\n\n    # Detected device config (set when device is detected)\n    self._detected_config: Optional[DeviceConfig] = None\n\n    # Use generic MidiManager with config-driven device filter and port selectors\n    self._midi = MidiManager(\n        device_filter=self._device_filter,\n        poll_interval=poll_interval,\n        input_port_selector=self._select_input_port,\n        output_port_selector=self._select_output_port\n    )\n    self._midi.on_message(self._handle_message)\n    self._midi.on_connection_changed(self._handle_connection_changed)\n\n    # Observer pattern for MIDI events\n    self._observers = ObserverManager[MidiObserver](observer_type_name=\"MIDI\")\n\n    # Device instance (created when connected)\n    self._device: Optional[GenericDevice] = None\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if a device is connected.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the model name of the connected device.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.start","title":"<code>start()</code>","text":"<p>Start monitoring for supported MIDI devices.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for supported MIDI devices.\"\"\"\n    self._midi.start()\n    logger.info(\"DeviceController started\")\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    # Shutdown device output (exit programmer mode) before stopping MIDI\n    if self._device:\n        try:\n            self._device.output.shutdown()\n            logger.info(\"Device shut down\")\n        except Exception as e:\n            logger.error(f\"Error shutting down device: {e}\")\n        self._device = None\n\n    self._midi.stop()\n    logger.info(\"DeviceController stopped\")\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register observer for MIDI events.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def register_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Register observer for MIDI events.\"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister observer.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def unregister_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Unregister observer.\"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_color","title":"<code>set_pad_color(pad_index, color)</code>","text":"<p>Set LED color for a pad (RGB mode).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_color(self, pad_index: int, color: Color) -&gt; bool:\n    \"\"\"\n    Set LED color for a pad (RGB mode).\n\n    Args:\n        pad_index: Pad 0-63\n        color: RGB color\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad color: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad color: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Bulk update multiple LED colors (more efficient than individual updates).</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[tuple[int, Color]]</code> <p>List of (pad_index, color) tuples</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_leds_bulk(self, updates: list[tuple[int, Color]]) -&gt; bool:\n    \"\"\"\n    Bulk update multiple LED colors (more efficient than individual updates).\n\n    Args:\n        updates: List of (pad_index, color) tuples\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set LEDs bulk: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_leds_bulk(updates)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting LEDs bulk: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_static","title":"<code>set_pad_static(pad_index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_static(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad static: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_static(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad static: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_flashing","title":"<code>set_pad_flashing(pad_index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_flashing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad flashing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_flashing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad flashing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_pulsing","title":"<code>set_pad_pulsing(pad_index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_pulsing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad pulsing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_pulsing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad pulsing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/device/","title":"Device","text":""},{"location":"api/devices/device/#launchsampler.devices.device","title":"<code>device</code>","text":"<p>Generic device implementation using config-driven architecture.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice","title":"<code>GenericDevice(config, input_handler, output_handler)</code>","text":"<p>Generic MIDI device implementation.</p> <p>Composes generic input parsing with device-specific output control and note mapping, configured via DeviceConfig.</p> <p>Initialize generic device.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required <code>input_handler</code> <code>DeviceInput</code> <p>Device input parser (usually GenericInput with device mapper)</p> required <code>output_handler</code> <code>DeviceOutput</code> <p>Device-specific output controller</p> required Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>def __init__(\n    self,\n    config: DeviceConfig,\n    input_handler: DeviceInput,\n    output_handler: DeviceOutput\n):\n    \"\"\"\n    Initialize generic device.\n\n    Args:\n        config: Device configuration\n        input_handler: Device input parser (usually GenericInput with device mapper)\n        output_handler: Device-specific output controller\n    \"\"\"\n    self.config = config\n    self._input = input_handler\n    self._output = output_handler\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.input","title":"<code>input</code>  <code>property</code>","text":"<p>Get input handler.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.output","title":"<code>output</code>  <code>property</code>","text":"<p>Get output controller.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get grid size.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Get human-readable device name.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.matches","title":"<code>matches(port_name, config)</code>  <code>staticmethod</code>","text":"<p>Check if port name matches device.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef matches(port_name: str, config: DeviceConfig) -&gt; bool:\n    \"\"\"Check if port name matches device.\"\"\"\n    return config.matches(port_name)\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.select_input_port","title":"<code>select_input_port(matching_ports, config)</code>  <code>staticmethod</code>","text":"<p>Select best input port using device config.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef select_input_port(matching_ports: list[str], config: DeviceConfig) -&gt; Optional[str]:\n    \"\"\"Select best input port using device config.\"\"\"\n    return config.select_input_port(matching_ports)\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.select_output_port","title":"<code>select_output_port(matching_ports, config)</code>  <code>staticmethod</code>","text":"<p>Select best output port using device config.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef select_output_port(matching_ports: list[str], config: DeviceConfig) -&gt; Optional[str]:\n    \"\"\"Select best output port using device config.\"\"\"\n    return config.select_output_port(matching_ports)\n</code></pre>"},{"location":"api/devices/input/","title":"Input","text":""},{"location":"api/devices/input/#launchsampler.devices.input","title":"<code>input</code>","text":"<p>Generic MIDI input parsing for all devices.</p>"},{"location":"api/devices/input/#launchsampler.devices.input--input-flow-button-press-your-code","title":"Input Flow: Button Press \u2192 Your Code","text":"<p>This module handles the INPUT SIDE of device communication - transforming hardware MIDI messages into logical application events.</p>"},{"location":"api/devices/input/#launchsampler.devices.input--the-flow","title":"The Flow","text":"<p>::</p> <pre><code>Hardware Button Press\n      \u2193\n[MIDI Message: note_on 36, velocity 100]\n      \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      GenericInput                    \u2502\n\u2502       (input.py)                     \u2502\n\u2502                                      \u2502\n\u2502  parse_message(msg):                 \u2502\n\u2502    if msg.type == 'note_on':         \u2502\n\u2502      index = mapper.note_to_index(36)\u2502\n\u2502      return PadPressEvent(index=5)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502 Uses mapper\n             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   LaunchpadMK3Mapper                 \u2502\n\u2502   (adapters/launchpad_mk3.py)        \u2502\n\u2502                                      \u2502\n\u2502  note_to_index(36):                  \u2502\n\u2502    offset = 11                       \u2502\n\u2502    row_spacing = 10                  \u2502\n\u2502    note_index = note - offset = 25   \u2502\n\u2502    row = 25 // 10 = 2                \u2502\n\u2502    col = 25 % 10 = 5                 \u2502\n\u2502    return row * 8 + col = 21         \u2502\n\u2502                                      \u2502\n\u2502  Hardware layout:                    \u2502\n\u2502    Note 11 = bottom-left (0,0)       \u2502\n\u2502    Note 36 = pad at (2,5)            \u2502\n\u2502    Logical index 21                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2193\n[PadPressEvent(pad_index=21, velocity=100)]\n      \u2193\nYour application observers get notified\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input--key-concepts","title":"Key Concepts","text":"<p>Hardware Independence: GenericInput knows nothing about specific devices. It just asks the mapper \"what logical index is this MIDI note?\"</p> <p>Logical vs Hardware Indices: - Hardware: MIDI note 36 (device-specific) - Logical: Pad index 21 (universal across all devices)</p> <p>Velocity Handling: MIDI velocity (0-127) is preserved for pressure-sensitive applications. Note that velocity=0 on note_on is actually a note_off.</p>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper","title":"<code>NoteMapper</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device-specific note mapping.</p>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper.note_to_index","title":"<code>note_to_index(note)</code>","text":"<p>Convert hardware MIDI note to logical pad index.</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def note_to_index(self, note: int) -&gt; Optional[int]:\n    \"\"\"Convert hardware MIDI note to logical pad index.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper.index_to_note","title":"<code>index_to_note(index)</code>","text":"<p>Convert logical pad index to hardware MIDI note.</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def index_to_note(self, index: int) -&gt; int:\n    \"\"\"Convert logical pad index to hardware MIDI note.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.GenericInput","title":"<code>GenericInput(mapper)</code>","text":"<p>               Bases: <code>DeviceInput</code></p> <p>Generic MIDI input parser.</p> <p>Handles standard MIDI messages (note_on, note_off, control_change) and delegates hardware-specific note mapping to a device mapper.</p> <p>Initialize generic input parser.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>NoteMapper</code> <p>Device-specific note mapper for converting    hardware MIDI notes to logical pad indices</p> required Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def __init__(self, mapper: NoteMapper):\n    \"\"\"\n    Initialize generic input parser.\n\n    Args:\n        mapper: Device-specific note mapper for converting\n               hardware MIDI notes to logical pad indices\n    \"\"\"\n    self.mapper = mapper\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.GenericInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming MIDI message into device events.</p> <p>Transforms hardware MIDI note numbers to logical pad indices using the device-specific note mapper.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Message</code> <p>MIDI message</p> required <p>Returns:</p> Type Description <code>Optional[DeviceEvent]</code> <p>DeviceEvent with logical pad index, or None if message</p> <code>Optional[DeviceEvent]</code> <p>should be ignored or is not supported</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def parse_message(self, msg: mido.Message) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming MIDI message into device events.\n\n    Transforms hardware MIDI note numbers to logical pad indices\n    using the device-specific note mapper.\n\n    Args:\n        msg: MIDI message\n\n    Returns:\n        DeviceEvent with logical pad index, or None if message\n        should be ignored or is not supported\n    \"\"\"\n    # Filter out clock messages\n    if msg.type == 'clock':\n        return None\n\n    # Handle note on/off\n    if msg.type == 'note_on':\n        # Convert note to logical index using device mapper\n        pad_index = self.mapper.note_to_index(msg.note)\n        if pad_index is None:\n            return None  # Invalid note, not a grid pad\n\n        # Note on with velocity 0 is actually note off\n        if msg.velocity &gt; 0:\n            return PadPressEvent(pad_index, msg.velocity)\n        else:\n            return PadReleaseEvent(pad_index)\n\n    elif msg.type == 'note_off':\n        pad_index = self.mapper.note_to_index(msg.note)\n        if pad_index is None:\n            return None\n        return PadReleaseEvent(pad_index)\n\n    elif msg.type == 'control_change':\n        return ControlChangeEvent(msg.control, msg.value)\n\n    return None\n</code></pre>"},{"location":"api/devices/midi-controller/","title":"MIDI Controller","text":"<p>The MIDI Controller handles communication with Novation Launchpad devices.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller","title":"<code>controller</code>","text":"<p>Generic device controller for grid-based MIDI controllers.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller--architecture-overview","title":"Architecture Overview","text":"<p>The DeviceController is the main user-facing API for interacting with MIDI grid controllers. It sits at the top of the device architecture and hides all hardware complexity from the application.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller--connection-flow","title":"Connection Flow","text":"<p>::</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         USER APPLICATION                            \u2502\n\u2502                    (Your Sampler Software)                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                    Uses high-level API\n                             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DeviceController                                 \u2502\n\u2502                  (devices/controller.py)                            \u2502\n\u2502                                                                     \u2502\n\u2502  \ud83c\udfae What it does:                                                   \u2502\n\u2502    - Manages connection to the device                              \u2502\n\u2502    - Provides user-friendly methods (set_pad_color, etc.)          \u2502\n\u2502    - Handles observers (notify when buttons pressed)               \u2502\n\u2502    - Hides all the complexity below                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                 \u2502                        \u2502\n    Asks for help    Detects devices         Sends messages\n           \u2193                 \u2193                        \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 DeviceRegistry\u2502 \u2502 MidiManager  \u2502      \u2502  MidiManager    \u2502\n   \u2502 (registry.py) \u2502 \u2502 (generic)    \u2502      \u2502  (output)       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n    Loads config &amp;\n    creates device\n           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        GenericDevice                                 \u2502\n\u2502                         (device.py)                                  \u2502\n\u2502                                                                      \u2502\n\u2502  Two sides:                                                          \u2502\n\u2502    - Input: MIDI messages \u2192 Events (button presses)                 \u2502\n\u2502    - Output: Commands \u2192 MIDI messages (LED control)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller--key-design-principle","title":"Key Design Principle","text":"<p>The DeviceController knows NOTHING about: - MIDI note numbers - SysEx messages - Hardware-specific quirks</p> <p>It only deals with logical pad indices (0-63) and abstract colors. All hardware translation happens in the layers below.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller--usage-example","title":"Usage Example","text":"<p>.. code-block:: python</p> <pre><code>controller = DeviceController()\ncontroller.start()\ncontroller.set_pad_color(21, Color(255, 0, 0))  # Works with ANY device!\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController","title":"<code>DeviceController(poll_interval=5.0)</code>","text":"<p>High-level controller for grid-based MIDI devices.</p> <p>Composes MidiManager with device registry to provide a clean, user-facing API for controlling any supported grid device (Launchpad, APC, etc.).</p> <p>The controller automatically detects connected devices using the registry and provides a unified API regardless of the specific hardware model.</p> <p>Initialize device controller.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __init__(self, poll_interval: float = 5.0):\n    \"\"\"\n    Initialize device controller.\n\n    Args:\n        poll_interval: How often to check for device changes (seconds)\n    \"\"\"\n    # Create device registry\n    self._registry = DeviceRegistry()\n\n    # Detected device config (set when device is detected)\n    self._detected_config: Optional[DeviceConfig] = None\n\n    # Use generic MidiManager with config-driven device filter and port selectors\n    self._midi = MidiManager(\n        device_filter=self._device_filter,\n        poll_interval=poll_interval,\n        input_port_selector=self._select_input_port,\n        output_port_selector=self._select_output_port\n    )\n    self._midi.on_message(self._handle_message)\n    self._midi.on_connection_changed(self._handle_connection_changed)\n\n    # Observer pattern for MIDI events\n    self._observers = ObserverManager[MidiObserver](observer_type_name=\"MIDI\")\n\n    # Device instance (created when connected)\n    self._device: Optional[GenericDevice] = None\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if a device is connected.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the model name of the connected device.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.start","title":"<code>start()</code>","text":"<p>Start monitoring for supported MIDI devices.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for supported MIDI devices.\"\"\"\n    self._midi.start()\n    logger.info(\"DeviceController started\")\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    # Shutdown device output (exit programmer mode) before stopping MIDI\n    if self._device:\n        try:\n            self._device.output.shutdown()\n            logger.info(\"Device shut down\")\n        except Exception as e:\n            logger.error(f\"Error shutting down device: {e}\")\n        self._device = None\n\n    self._midi.stop()\n    logger.info(\"DeviceController stopped\")\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register observer for MIDI events.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def register_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Register observer for MIDI events.\"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister observer.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def unregister_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Unregister observer.\"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.set_pad_color","title":"<code>set_pad_color(pad_index, color)</code>","text":"<p>Set LED color for a pad (RGB mode).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_color(self, pad_index: int, color: Color) -&gt; bool:\n    \"\"\"\n    Set LED color for a pad (RGB mode).\n\n    Args:\n        pad_index: Pad 0-63\n        color: RGB color\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad color: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad color: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Bulk update multiple LED colors (more efficient than individual updates).</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[tuple[int, Color]]</code> <p>List of (pad_index, color) tuples</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_leds_bulk(self, updates: list[tuple[int, Color]]) -&gt; bool:\n    \"\"\"\n    Bulk update multiple LED colors (more efficient than individual updates).\n\n    Args:\n        updates: List of (pad_index, color) tuples\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set LEDs bulk: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_leds_bulk(updates)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting LEDs bulk: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.set_pad_static","title":"<code>set_pad_static(pad_index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_static(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad static: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_static(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad static: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.set_pad_flashing","title":"<code>set_pad_flashing(pad_index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_flashing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad flashing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_flashing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad flashing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/midi-controller/#launchsampler.devices.controller.DeviceController.set_pad_pulsing","title":"<code>set_pad_pulsing(pad_index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_pulsing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad pulsing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_pulsing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad pulsing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/protocols/","title":"Protocols","text":""},{"location":"api/devices/protocols/#launchsampler.devices.protocols","title":"<code>protocols</code>","text":"<p>Generic device protocols and abstractions.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceEvent","title":"<code>DeviceEvent</code>","text":"<p>Generic device event (input from hardware).</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.PadPressEvent","title":"<code>PadPressEvent(pad_index, velocity)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was pressed.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int, velocity: int):\n    self.pad_index = pad_index  # Logical 0-63\n    self.velocity = velocity\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.PadReleaseEvent","title":"<code>PadReleaseEvent(pad_index)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was released.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int):\n    self.pad_index = pad_index  # Logical 0-63\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.ControlChangeEvent","title":"<code>ControlChangeEvent(control, value)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>MIDI control change received.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, control: int, value: int):\n    self.control = control\n    self.value = value\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceInput","title":"<code>DeviceInput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device input handling.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming message into device event.</p> <p>Must handle hardware-specific note mapping internally and return events with logical pad indices (0-63).</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def parse_message(self, msg) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming message into device event.\n\n    Must handle hardware-specific note mapping internally and\n    return events with logical pad indices (0-63).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput","title":"<code>DeviceOutput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device output/display control.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the output device.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the output device.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown and cleanup.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown and cleanup.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED by logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_led(self, index: int, color: 'Color') -&gt; None:\n    \"\"\"\n    Set single LED by logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, 'Color']]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/registry/","title":"Registry","text":""},{"location":"api/devices/registry/#launchsampler.devices.registry","title":"<code>registry</code>","text":"<p>Device registry using Pydantic models for configuration validation.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry--the-smart-factory","title":"The Smart Factory","text":"<p>The DeviceRegistry is the \"factory\" that knows how to build the right device controller based on what's plugged into USB. It reads configuration from devices.json and assembles complete devices from modular components.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry--how-device-detection-works","title":"How Device Detection Works","text":"<p>::</p> <pre><code>USB Device Connected: \"Launchpad Pro MK3 MIDI\"\n                              \u2193\nRegistry checks devices.json: \"Does 'LPProMK3' match patterns?\"\n                              \u2193 YES\nRegistry: \"This is a Launchpad Pro MK3\"\n         \"It implements: LaunchpadMK3\"\n         \"Prefer port: LPProMK3 MIDI 0\"\n                              \u2193\nRegistry looks up implementation: get_implementation(\"LaunchpadMK3\")\n                              \u2193 Returns\n         (LaunchpadMK3Mapper, LaunchpadMK3Output)\n                              \u2193\nRegistry creates: GenericDevice(\n    mapper=LaunchpadMK3Mapper(),\n    input=GenericInput(mapper),\n    output=LaunchpadMK3Output(midi_manager, config)\n)\n                              \u2193\nReturns fully assembled device to DeviceController\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry--device-creation-flow","title":"Device Creation Flow","text":"<p>::</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        DeviceRegistry                                \u2502\n\u2502                       (registry.py)                                  \u2502\n\u2502                                                                      \u2502\n\u2502  \ud83c\udfed What it does:                                                    \u2502\n\u2502    1. Loads devices.json at startup                                 \u2502\n\u2502    2. When USB device appears, checks if name matches patterns      \u2502\n\u2502    3. Selects the right USB ports (OS-specific rules)               \u2502\n\u2502    4. Assembles a GenericDevice from parts:                         \u2502\n\u2502       - Mapper (note translation)                                   \u2502\n\u2502       - Input handler (MIDI parser)                                 \u2502\n\u2502       - Output handler (LED controller)                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Reads configuration\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        devices.json                                \u2502\n\u2502                     (Configuration File)                           \u2502\n\u2502                                                                    \u2502\n\u2502  \ud83d\udccb Contains:                                                      \u2502\n\u2502    - Family: \"launchpad_mk3\"                                       \u2502\n\u2502    - Detection patterns: [\"Launchpad Pro\", \"LPProMK3\"]            \u2502\n\u2502    - Capabilities: {num_pads: 64, grid_size: 8}                   \u2502\n\u2502    - Port selection rules (Windows/Mac/Linux)                     \u2502\n\u2502    - SysEx header: [0, 32, 41, 2, 14]                             \u2502\n\u2502    - Implements: \"LaunchpadMK3\" \u2190 Links to code                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Points to implementation\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              adapters/__init__.py                                  \u2502\n\u2502              (Implementation Registry)                             \u2502\n\u2502                                                                    \u2502\n\u2502  \ud83d\udd0d Registry lookup:                                               \u2502\n\u2502    \"LaunchpadMK3\" \u2192 (LaunchpadMK3Mapper, LaunchpadMK3Output)      \u2502\n\u2502                                                                    \u2502\n\u2502  To add new device:                                                \u2502\n\u2502    register_implementation(\"APC40\", APC40Mapper, APC40Output)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry--key-features","title":"Key Features","text":"<p>Open/Closed Principle: Add new devices without modifying registry code. Simply add a new entry to devices.json and register the implementation.</p> <p>OS-Specific Port Selection: Handles platform differences in MIDI port naming. Different rules for Windows, macOS, and Linux.</p> <p>Declarative Configuration: All device capabilities and quirks defined in JSON, not scattered through if/else statements in code.</p> <p>Validation: Pydantic models ensure devices.json is always valid at runtime.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry","title":"<code>DeviceRegistry(config_path=None)</code>","text":"<p>Registry of all supported MIDI devices.</p> <p>Loads device configurations from JSON using Pydantic validation and provides device detection and instantiation services.</p> <p>Initialize device registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Path]</code> <p>Path to devices.json config file.         If None, uses default location.</p> <code>None</code> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def __init__(self, config_path: Optional[Path] = None):\n    \"\"\"\n    Initialize device registry.\n\n    Args:\n        config_path: Path to devices.json config file.\n                    If None, uses default location.\n    \"\"\"\n    if config_path is None:\n        config_path = Path(__file__).parent / \"devices.json\"\n\n    self.config_path = config_path\n    self.schema: DeviceRegistrySchema = self._load_schema()\n    self.devices: list[DeviceConfig] = self._flatten_configs()\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.detect_device","title":"<code>detect_device(port_name)</code>","text":"<p>Detect which device config matches a port name.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>MIDI port name string</p> required <p>Returns:</p> Type Description <code>Optional[DeviceConfig]</code> <p>Matching DeviceConfig or None if no match found</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def detect_device(self, port_name: str) -&gt; Optional[DeviceConfig]:\n    \"\"\"\n    Detect which device config matches a port name.\n\n    Args:\n        port_name: MIDI port name string\n\n    Returns:\n        Matching DeviceConfig or None if no match found\n    \"\"\"\n    for config in self.devices:\n        if config.matches(port_name):\n            logger.debug(f\"Detected {config.model} from port: {port_name}\")\n            return config\n\n    logger.debug(f\"No device matched port: {port_name}\")\n    return None\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.get_all_patterns","title":"<code>get_all_patterns()</code>","text":"<p>Get all detection patterns across all devices.</p> <p>Useful for creating a device_filter function for MidiManager.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of all detection patterns</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def get_all_patterns(self) -&gt; list[str]:\n    \"\"\"\n    Get all detection patterns across all devices.\n\n    Useful for creating a device_filter function for MidiManager.\n\n    Returns:\n        List of all detection patterns\n    \"\"\"\n    patterns = set()\n    for config in self.devices:\n        patterns.update(config.detection_patterns)\n    return list(patterns)\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.matches_any_device","title":"<code>matches_any_device(port_name)</code>","text":"<p>Check if port name matches any registered device.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>MIDI port name string</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if port matches any device</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def matches_any_device(self, port_name: str) -&gt; bool:\n    \"\"\"\n    Check if port name matches any registered device.\n\n    Args:\n        port_name: MIDI port name string\n\n    Returns:\n        True if port matches any device\n    \"\"\"\n    return self.detect_device(port_name) is not None\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.create_device","title":"<code>create_device(config, midi_manager)</code>","text":"<p>Create a device instance from configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required <code>midi_manager</code> <code>MidiManager</code> <p>MIDI manager instance</p> required <p>Returns:</p> Type Description <code>GenericDevice</code> <p>GenericDevice instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If implementation not found</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def create_device(\n    self,\n    config: DeviceConfig,\n    midi_manager: \"MidiManager\"\n) -&gt; \"GenericDevice\":\n    \"\"\"\n    Create a device instance from configuration.\n\n    Args:\n        config: Device configuration\n        midi_manager: MIDI manager instance\n\n    Returns:\n        GenericDevice instance\n\n    Raises:\n        ValueError: If implementation not found\n    \"\"\"\n    from .adapters import get_adapter\n    from .device import GenericDevice\n    from .input import GenericInput\n\n    # Look up adapter classes\n    adapter = get_adapter(config.implements)\n    if adapter is None:\n        raise ValueError(f\"Unknown adapter: {config.implements}\")\n\n    MapperClass, OutputClass = adapter\n\n    # Instantiate device-specific components\n    mapper = MapperClass(config)\n    input_handler = GenericInput(mapper)\n    output_handler = OutputClass(midi_manager, config)\n\n    # Wrap in GenericDevice\n    return GenericDevice(config, input_handler, output_handler)\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.get_registry","title":"<code>get_registry()</code>","text":"<p>Get singleton DeviceRegistry instance.</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def get_registry() -&gt; DeviceRegistry:\n    \"\"\"Get singleton DeviceRegistry instance.\"\"\"\n    global _registry\n    if _registry is None:\n        _registry = DeviceRegistry()\n    return _registry\n</code></pre>"},{"location":"api/devices/schema/","title":"Schema","text":""},{"location":"api/devices/schema/#launchsampler.devices.schema","title":"<code>schema</code>","text":"<p>Pydantic models for device configuration schema.</p> <p>This module defines the structure of the devices.json configuration file using Pydantic v2 for type safety and validation.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.PortSelectionRules","title":"<code>PortSelectionRules</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Port selection rules for a specific OS.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.OSPortSelection","title":"<code>OSPortSelection</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>OS-specific port selection rules.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.OSPortSelection.get_for_current_os","title":"<code>get_for_current_os()</code>","text":"<p>Get rules for current operating system.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>def get_for_current_os(self) -&gt; PortSelectionRules:\n    \"\"\"Get rules for current operating system.\"\"\"\n    os_name = platform.system().lower()\n    return getattr(self, os_name, PortSelectionRules())\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceCapabilities","title":"<code>DeviceCapabilities</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device hardware capabilities.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceOverrides","title":"<code>DeviceOverrides</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device-specific overrides for family defaults.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Individual device configuration within a family.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.Device.validate_sysex_header","title":"<code>validate_sysex_header(v)</code>  <code>classmethod</code>","text":"<p>Validate SysEx header bytes are in valid range.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@field_validator(\"sysex_header\")\n@classmethod\ndef validate_sysex_header(cls, v: Optional[list[int]]) -&gt; Optional[list[int]]:\n    \"\"\"Validate SysEx header bytes are in valid range.\"\"\"\n    if v is not None:\n        for byte in v:\n            if not 0 &lt;= byte &lt;= 127:\n                raise ValueError(f\"SysEx byte {byte} out of range (0-127)\")\n    return v\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceFamily","title":"<code>DeviceFamily</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device family configuration (e.g., Launchpad MK3 family).</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema","title":"<code>DeviceRegistrySchema</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root schema for the devices.json configuration file.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.from_json_file","title":"<code>from_json_file(path)</code>  <code>classmethod</code>","text":"<p>Load registry from JSON file with validation.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@classmethod\ndef from_json_file(cls, path: Path) -&gt; \"DeviceRegistrySchema\":\n    \"\"\"Load registry from JSON file with validation.\"\"\"\n    with open(path, \"r\") as f:\n        return cls.model_validate_json(f.read())\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.to_json_file","title":"<code>to_json_file(path, indent=2)</code>","text":"<p>Save registry to JSON file.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>def to_json_file(self, path: Path, indent: int = 2) -&gt; None:\n    \"\"\"Save registry to JSON file.\"\"\"\n    with open(path, \"w\") as f:\n        f.write(self.model_dump_json(indent=indent))\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.generate_json_schema","title":"<code>generate_json_schema(path)</code>  <code>classmethod</code>","text":"<p>Generate JSON schema for documentation and IDE support.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@classmethod\ndef generate_json_schema(cls, path: Path) -&gt; None:\n    \"\"\"Generate JSON schema for documentation and IDE support.\"\"\"\n    import json\n    schema = cls.model_json_schema()\n    with open(path, \"w\") as f:\n        json.dump(schema, f, indent=2)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/","title":"Launchpad Mk3","text":""},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3","title":"<code>launchpad_mk3</code>","text":"<p>Launchpad MK3 family implementation (Pro, Mini, X).</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--hardware-specific-implementation","title":"Hardware-Specific Implementation","text":"<p>This module contains the device-specific \"brains\" for Launchpad MK3 devices. It translates between logical pad indices and hardware MIDI notes, and builds SysEx messages for LED control.</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--mapper-logical-hardware-translation","title":"Mapper: Logical \u2194 Hardware Translation","text":"<p>The LaunchpadMK3Mapper translates between logical indices and MIDI notes.</p> <p>Input Side (Button Press)::</p> <pre><code>Hardware Button Press \u2192 MIDI note 36\n                            \u2193\nLaunchpadMK3Mapper.note_to_index(36):\n  offset = 11\n  row_spacing = 10\n  note_index = 36 - 11 = 25\n  row = 25 // 10 = 2\n  col = 25 % 10 = 5\n  return row * 8 + col = 21\n                            \u2193\nLogical pad index 21\n</code></pre> <p>Output Side (LED Control)::</p> <pre><code>Your code: set_pad_color(index=21, Color(255, 0, 0))\n                            \u2193\nLaunchpadMK3Mapper.index_to_note(21):\n  row = 21 // 8 = 2\n  col = 21 % 8 = 5\n  note = 11 + (row * 10) + col\n  return 11 + 20 + 5 = 36\n                            \u2193\nMIDI note 36\n                            \u2193\nLaunchpadSysEx.led_lighting([(RGB, 36, 255, 0, 0)])\n                            \u2193\n[0xF0, 0, 32, 41, 2, 14, 0x03, 3, 36, 255, 0, 0, 0xF7]\n                            \u2193\nHardware LED turns RED\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--hardware-layout","title":"Hardware Layout","text":"<p>Launchpad MK3 in programmer mode uses this note layout::</p> <pre><code>Row 7: 81 82 83 84 85 86 87 88    (top row)\nRow 6: 71 72 73 74 75 76 77 78\nRow 5: 61 62 63 64 65 66 67 68\nRow 4: 51 52 53 54 55 56 57 58\nRow 3: 41 42 43 44 45 46 47 48\nRow 2: 31 32 33 34 35 36 37 38\nRow 1: 21 22 23 24 25 26 27 28\nRow 0: 11 12 13 14 15 16 17 18    (bottom row)\n       \u2514\u2500 bottom-left pad\n</code></pre> <p>Note the row spacing of 10 (includes gaps like 19, 29, etc.)</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--key-design-decisions","title":"Key Design Decisions","text":"<p>Why separate Mapper from Output?</p> <ul> <li>Mapper: Pure mathematical translation (no side effects)</li> <li>Output: Manages hardware state and sends MIDI messages</li> </ul> <p>This separation makes testing trivial - you can verify note mapping without needing actual hardware.</p> <p>Why store offset/spacing as constants?</p> <p>All MK3 devices (Pro, Mini, X) use the same programmer mode layout. If Novation releases an MK4 with different layout, create a new mapper class.</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper","title":"<code>LaunchpadMK3Mapper(config)</code>","text":"<p>Note mapper for Launchpad MK3 family devices.</p> <p>Maps between MIDI notes and logical pad indices/coordinates. All MK3 models (Pro, Mini, X) use the same note layout in programmer mode.</p> <p>Initialize note mapper.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def __init__(self, config: DeviceConfig):\n    \"\"\"\n    Initialize note mapper.\n\n    Args:\n        config: Device configuration\n    \"\"\"\n    self.config = config\n    self.offset = self.PROGRAMMER_MODE_OFFSET\n    self.row_spacing = self.PROGRAMMER_MODE_ROW_SPACING\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.note_to_index","title":"<code>note_to_index(note)</code>","text":"<p>Convert MIDI note to logical pad index (0-63).</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>MIDI note number</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Pad index (0-63) or None if invalid note</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def note_to_index(self, note: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert MIDI note to logical pad index (0-63).\n\n    Args:\n        note: MIDI note number\n\n    Returns:\n        Pad index (0-63) or None if invalid note\n    \"\"\"\n    x, y = self.note_to_xy(note)\n    if x is None or y is None:\n        return None\n\n    return y * 8 + x\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>MIDI note number</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[int], Optional[int]]</code> <p>(x, y) tuple or (None, None) if invalid</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; Tuple[Optional[int], Optional[int]]:\n    \"\"\"\n    Convert MIDI note to (x, y) coordinates.\n\n    Args:\n        note: MIDI note number\n\n    Returns:\n        (x, y) tuple or (None, None) if invalid\n    \"\"\"\n    if note &lt; self.offset or note &gt; (self.offset + 7 * self.row_spacing + 7):\n        return (None, None)\n\n    adjusted = note - self.offset\n    row = adjusted // self.row_spacing\n    col = adjusted % self.row_spacing\n\n    if col &gt; 7 or row &gt; 7:\n        return (None, None)\n\n    return (col, row)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.index_to_note","title":"<code>index_to_note(index)</code>","text":"<p>Convert logical pad index to MIDI note.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Pad index (0-63)</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>MIDI note number or None if invalid index</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def index_to_note(self, index: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert logical pad index to MIDI note.\n\n    Args:\n        index: Pad index (0-63)\n\n    Returns:\n        MIDI note number or None if invalid index\n    \"\"\"\n    if not 0 &lt;= index &lt; 64:\n        return None\n\n    row = index // 8\n    col = index % 8\n\n    return self.xy_to_note(col, row)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>column (0-7)</p> required <code>y</code> <code>int</code> <p>row (0-7)</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>MIDI note number or None if invalid coordinates</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert (x, y) coordinates to MIDI note.\n\n    Args:\n        x: column (0-7)\n        y: row (0-7)\n\n    Returns:\n        MIDI note number or None if invalid coordinates\n    \"\"\"\n    if not (0 &lt;= x &lt; 8 and 0 &lt;= y &lt; 8):\n        return None\n\n    return self.offset + (y * self.row_spacing) + x\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output","title":"<code>LaunchpadMK3Output(midi_manager, config)</code>","text":"<p>               Bases: <code>DeviceOutput</code></p> <p>Output controller for Launchpad MK3 family.</p> <p>Handles LED control and device initialization for Launchpad Pro MK3, Mini MK3, and X models.</p> <p>Initialize Launchpad MK3 output controller.</p> <p>Parameters:</p> Name Type Description Default <code>midi_manager</code> <code>MidiManager</code> <p>MIDI manager for sending messages</p> required <code>config</code> <code>DeviceConfig</code> <p>Device configuration with SysEx header</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def __init__(self, midi_manager: MidiManager, config: DeviceConfig):\n    \"\"\"\n    Initialize Launchpad MK3 output controller.\n\n    Args:\n        midi_manager: MIDI manager for sending messages\n        config: Device configuration with SysEx header\n    \"\"\"\n    self.midi = midi_manager\n    self.config = config\n    self.mapper = LaunchpadMK3Mapper(config)\n    self.sysex = LaunchpadSysEx.from_header(config.sysex_header)\n    self._initialized = False\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.initialize","title":"<code>initialize()</code>","text":"<p>Enter programmer mode.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Enter programmer mode.\"\"\"\n    if self._initialized:\n        logger.warning(f\"{self.config.model} already initialized\")\n        return\n\n    msg = self.sysex.programmer_mode(enable=True)\n    if self.midi.send(msg):\n        logger.info(f\"Entered programmer mode ({self.config.model})\")\n        self._initialized = True\n    else:\n        logger.error(\"Failed to enter programmer mode\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.shutdown","title":"<code>shutdown()</code>","text":"<p>Exit programmer mode and clear LEDs.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Exit programmer mode and clear LEDs.\"\"\"\n    if not self._initialized:\n        return\n\n    self.clear_all()\n\n    msg = self.sysex.programmer_mode(enable=False)\n    if self.midi.send(msg):\n        logger.info(\"Exited programmer mode\")\n        self._initialized = False\n    else:\n        logger.error(\"Failed to exit programmer mode\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED using logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color (0-127 per channel)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led(self, index: int, color: Color) -&gt; None:\n    \"\"\"\n    Set single LED using logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color (0-127 per channel)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.RGB.value, note, color.r, color.g, color.b)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, Color]]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    if not updates:\n        return\n\n    specs = []\n    for index, color in updates:\n        note = self.mapper.index_to_note(index)\n        if note is None:\n            logger.warning(f\"Skipping invalid pad index: {index}\")\n            continue\n        specs.append((LightingMode.RGB.value, note, color.r, color.g, color.b))\n\n    if not specs:\n        return\n\n    msg = self.sysex.led_lighting(specs)\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set {len(specs)} LEDs in bulk\")\n    else:\n        logger.debug(f\"Set {len(specs)} LEDs in bulk\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_flashing","title":"<code>set_led_flashing(index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_flashing(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.FLASHING.value, note, 0, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} flashing (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_pulsing","title":"<code>set_led_pulsing(index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_pulsing(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.PULSING.value, note, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} pulsing (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_static","title":"<code>set_led_static(index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_static(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.STATIC.value, note, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} static (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_control_led","title":"<code>set_control_led(cc_number, color)</code>","text":"<p>Set LED for control button using RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>cc_number</code> <code>int</code> <p>MIDI CC control number</p> required <code>color</code> <code>Color</code> <p>RGB color (0-127 per channel)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_control_led(self, cc_number: int, color: Color) -&gt; None:\n    \"\"\"\n    Set LED for control button using RGB color.\n\n    Args:\n        cc_number: MIDI CC control number\n        color: RGB color (0-127 per channel)\n    \"\"\"\n    spec = (LightingMode.RGB.value, cc_number, color.r, color.g, color.b)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set control LED for CC {cc_number}\")\n    else:\n        logger.debug(f\"Set control LED for CC {cc_number}\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_control_led_static","title":"<code>set_control_led_static(cc_number, palette_color)</code>","text":"<p>Set LED for control button using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>cc_number</code> <code>int</code> <p>MIDI CC control number</p> required <code>palette_color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_control_led_static(self, cc_number: int, palette_color: int) -&gt; None:\n    \"\"\"\n    Set LED for control button using palette color.\n\n    Args:\n        cc_number: MIDI CC control number\n        palette_color: Palette color index (0-127)\n    \"\"\"\n    spec = (LightingMode.STATIC.value, cc_number, palette_color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set control LED for CC {cc_number}\")\n    else:\n        logger.debug(f\"Set control LED for CC {cc_number} to palette {palette_color}\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs (set to black).</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs (set to black).\"\"\"\n    specs = []\n    for index in range(64):\n        note = self.mapper.index_to_note(index)\n        if note is not None:\n            specs.append((LightingMode.STATIC.value, note, 0))\n\n    msg = self.sysex.led_lighting(specs)\n\n    if not self.midi.send(msg):\n        logger.warning(\"Failed to clear all LEDs\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/","title":"Launchpad Sysex","text":""},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex","title":"<code>launchpad_sysex</code>","text":"<p>Low-level SysEx message builder for Launchpad devices.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--sysex-the-launchpads-secret-language","title":"SysEx: The Launchpad's Secret Language","text":"<p>This module builds System Exclusive (SysEx) MIDI messages that control Launchpad hardware features like LED colors and device modes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--what-is-sysex","title":"What is SysEx?","text":"<p>SysEx messages are manufacturer-specific MIDI messages that allow control beyond standard MIDI. They follow this format::</p> <pre><code>[0xF0] [Manufacturer ID] [Device-specific data...] [0xF7]\n Start                                              End\n</code></pre> <p>For Novation Launchpad devices::</p> <pre><code>[0xF0, 0x00, 0x20, 0x29, 0x02, 0x0E, ...]\n \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2514\u2500 Model ID (0x0E = MK3)\n \u2502         Novation      \u2514\u2500 SysEx command type\n Start of SysEx\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--led-lighting-message-flow","title":"LED Lighting Message Flow","text":"<p>::</p> <pre><code>Your code calls:\nset_pad_color(index=21, Color(255, 0, 0))\n      \u2193\nLaunchpadMK3Output.set_led(21, color):\n  note = mapper.index_to_note(21)  # Returns 36\n  sysex = LaunchpadSysEx.led_lighting([\n    (RGB, 36, 255, 0, 0)\n  ])\n      \u2193\nLaunchpadSysEx.led_lighting(...):\n  Build message:\n    header = [0x00, 0x20, 0x29, 0x02, 0x0E]\n    command = 0x03  (LED lighting command)\n    data = [3, 36, 255, 0, 0]\n           \u2502  \u2502   \u2514\u2500\u2500\u2500 RGB values\n           \u2502  \u2514\u2500 MIDI note (hardware-specific)\n           \u2514\u2500 Lighting mode (3 = RGB)\n      \u2193\nComplete SysEx message:\n[0xF0, 0x00, 0x20, 0x29, 0x02, 0x0E, 0x03, 3, 36, 255, 0, 0, 0xF7]\n      \u2193\nSent via MIDI output\n      \u2193\nHardware LED turns RED\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--sysex-commands","title":"SysEx Commands","text":"<p>The Launchpad MK3 supports these SysEx commands:</p> <ul> <li>0x03: LED Lighting (set LED colors)</li> <li>0x0E: Programmer Mode (enable/disable custom mode)</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--lighting-modes","title":"Lighting Modes","text":"<p>When setting LED colors, you can use different modes:</p> <ul> <li>STATIC (0): Use a color from the device palette (0-127)</li> <li>FLASHING (1): Flash between two palette colors</li> <li>PULSING (2): Pulse a palette color</li> <li>RGB (3): Direct RGB color (most common, used by this implementation)</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--example-rgb-message","title":"Example RGB Message","text":"<p>To light pad at MIDI note 36 with red color::</p> <pre><code>Data: [3, 36, 255, 0, 0]\n       \u2502  \u2502   \u2502   \u2502  \u2502\n       \u2502  \u2502   \u2502   \u2502  \u2514\u2500 Blue: 0\n       \u2502  \u2502   \u2502   \u2514\u2500 Green: 0\n       \u2502  \u2502   \u2514\u2500 Red: 255\n       \u2502  \u2514\u2500 MIDI note: 36\n       \u2514\u2500 Mode: RGB (3)\n</code></pre> <p>You can send multiple LED specs in one message::</p> <pre><code>led_lighting([\n    (RGB, 36, 255, 0, 0),    # Note 36: Red\n    (RGB, 37, 0, 255, 0),    # Note 37: Green\n    (RGB, 38, 0, 0, 255),    # Note 38: Blue\n])\n</code></pre> <p>This is more efficient than sending three separate messages.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--key-design-principle","title":"Key Design Principle","text":"<p>Hardware abstraction boundary: This module is the LOWEST level of hardware interaction. It knows about MIDI notes (not logical indices) and SysEx byte sequences (not Color objects).</p> <p>The layer above (LaunchpadMK3Output) handles the translation from high-level concepts to low-level bytes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--references","title":"References","text":"<ul> <li>Launchpad Pro MK3 Programmer's Reference Manual</li> <li>MIDI System Exclusive specification</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LightingMode","title":"<code>LightingMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>LED lighting modes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx","title":"<code>LaunchpadSysEx(header)</code>","text":"<p>Low-level SysEx message builder for Launchpad devices.</p> <p>Initialize with SysEx header.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>list[int]</code> <p>Raw SysEx header bytes</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def __init__(self, header: list[int]):\n    \"\"\"\n    Initialize with SysEx header.\n\n    Args:\n        header: Raw SysEx header bytes\n    \"\"\"\n    self.header = header\n    self.model = None  # Kept for backwards compatibility\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.from_header","title":"<code>from_header(header)</code>  <code>classmethod</code>","text":"<p>Create LaunchpadSysEx from raw SysEx header.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>list[int]</code> <p>Raw SysEx header bytes</p> required <p>Returns:</p> Type Description <code>LaunchpadSysEx</code> <p>LaunchpadSysEx instance</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>@classmethod\ndef from_header(cls, header: list[int]) -&gt; 'LaunchpadSysEx':\n    \"\"\"\n    Create LaunchpadSysEx from raw SysEx header.\n\n    Args:\n        header: Raw SysEx header bytes\n\n    Returns:\n        LaunchpadSysEx instance\n    \"\"\"\n    return cls(header)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.programmer_mode","title":"<code>programmer_mode(enable)</code>","text":"<p>Build programmer mode toggle message.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def programmer_mode(self, enable: bool) -&gt; mido.Message:\n    \"\"\"Build programmer mode toggle message.\"\"\"\n    data = self.header + [0x0E, 0x01 if enable else 0x00]\n    return mido.Message('sysex', data=data)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.led_lighting","title":"<code>led_lighting(specs)</code>","text":"<p>Build LED lighting SysEx message.</p> <p>Parameters:</p> Name Type Description Default <code>specs</code> <code>List[Tuple]</code> <p>List of (lighting_type, led_note, *data_bytes)    NOTE: led_note is hardware MIDI note, not logical index</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def led_lighting(self, specs: List[Tuple]) -&gt; mido.Message:\n    \"\"\"\n    Build LED lighting SysEx message.\n\n    Args:\n        specs: List of (lighting_type, led_note, *data_bytes)\n               NOTE: led_note is hardware MIDI note, not logical index\n    \"\"\"\n    data = self.header + [0x03]\n    for spec in specs:\n        data.extend(spec)\n    return mido.Message('sysex', data=data)\n</code></pre>"},{"location":"api/led_ui/","title":"Led_ui","text":"<p>Hardware LED grid user interface support</p>"},{"location":"api/led_ui/#launchsampler.led_ui","title":"<code>led_ui</code>","text":"<p>LED UI for Launchpad hardware.</p>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI","title":"<code>LaunchpadLEDUI(orchestrator, poll_interval=5.0)</code>","text":"<p>               Bases: <code>UIAdapter</code></p> <p>LED UI implementation that displays the pad grid on Launchpad hardware.</p> <p>This UI adapter implements the UIAdapter protocol and runs in the background, mirroring the TUI's grid state on the physical Launchpad LEDs.</p> <p>The LED UI: - Runs in background (non-blocking) - Mirrors the 8x8 grid state from the TUI - Shows pad assignments with configured colors - Shows playing pads with pulsing yellow animation - Automatically syncs with all state changes</p> <p>Lifecycle: 1. init: Create controller and service, register as observer 2. initialize(): Start LED controller 3. run(): Non-blocking (returns immediately) 4. shutdown(): Stop controller and clean up</p> <p>Initialize the LED UI.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp orchestrator</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for Launchpad device (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def __init__(self, orchestrator: \"LaunchpadSamplerApp\", poll_interval: float = 5.0):\n    \"\"\"\n    Initialize the LED UI.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp orchestrator\n        poll_interval: How often to check for Launchpad device (seconds)\n    \"\"\"\n    self.orchestrator = orchestrator\n    self.poll_interval = poll_interval\n\n    # We'll use the orchestrator's LaunchpadController (shared resource)\n    # This avoids MIDI port conflicts\n    self.controller = None  # Will be set in register_with_services()\n\n    # Create LED renderer (stateless) - controller will be set later\n    self.renderer = LEDRenderer(None)\n\n    # Create LED event handler (observer) - pass renderer and shared state machine\n    self.event_handler = LEDEventHandler(self.renderer, orchestrator, orchestrator.state_machine)\n\n    # Register service with orchestrator services\n    self._register_with_services()\n\n    logger.info(\"LaunchpadLEDUI initialized\")\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the LED UI before the orchestrator starts.</p> <p>The LED UI uses the orchestrator's LaunchpadController (shared resource), so there's nothing to initialize here. The controller is created by the orchestrator.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the LED UI before the orchestrator starts.\n\n    The LED UI uses the orchestrator's LaunchpadController (shared resource),\n    so there's nothing to initialize here. The controller is created by the orchestrator.\n    \"\"\"\n    logger.info(\"Initializing LED UI (using orchestrator's LaunchpadController)\")\n    # Nothing to do - we use the orchestrator's controller\n    pass\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register LED event handler with all orchestrator services after they're initialized.</p> <p>Called by orchestrator after services are created.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp instance</p> required Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"LaunchpadSamplerApp\") -&gt; None:\n    \"\"\"\n    Register LED event handler with all orchestrator services after they're initialized.\n\n    Called by orchestrator after services are created.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp instance\n    \"\"\"\n    # Use orchestrator's MIDI controller (shared resource)\n    if orchestrator.midi_controller:\n        self.controller = orchestrator.midi_controller\n        self.renderer.controller = self.controller\n        logger.info(\"LED UI using orchestrator's LaunchpadController\")\n    else:\n        logger.warning(\"No MIDI controller available - LED UI will not function\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.event_handler)\n\n    # Register for playback state events\n    orchestrator.player.register_state_observer(self.event_handler)\n\n    # Register for MIDI events (connection/disconnection only)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.event_handler)\n\n    logger.info(\"LED event handler registered with all services\")\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.run","title":"<code>run()</code>","text":"<p>Run the LED UI.</p> <p>LED UI is a background UI, so this returns immediately. The Launchpad controller runs in its own polling thread.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the LED UI.\n\n    LED UI is a background UI, so this returns immediately.\n    The Launchpad controller runs in its own polling thread.\n    \"\"\"\n    logger.info(\"LED UI running in background\")\n    # Non-blocking - LED controller runs in background thread\n    pass\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the LED UI and clean up resources.</p> <p>Since we reuse the Player's LaunchpadController, we don't stop it here. We only unregister our observers.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the LED UI and clean up resources.\n\n    Since we reuse the Player's LaunchpadController, we don't stop it here.\n    We only unregister our observers.\n    \"\"\"\n    logger.info(\"Shutting down LED UI\")\n\n    # Unregister observers\n    try:\n        self.orchestrator.unregister_observer(self.event_handler)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.event_handler)\n        if self.orchestrator.player:\n            self.orchestrator.player.unregister_state_observer(self.event_handler)\n        if self.orchestrator.midi_controller:\n            self.orchestrator.midi_controller.unregister_observer(self.event_handler)\n        logger.info(\"LED event handler unregistered from all services\")\n    except Exception as e:\n        logger.error(f\"Error unregistering LED event handler observers: {e}\")\n\n    # Don't stop the controller - we don't own it, the orchestrator does\n    logger.info(\"LED UI shut down\")\n</code></pre>"},{"location":"api/led_ui/app/","title":"App","text":""},{"location":"api/led_ui/app/#launchsampler.led_ui.app","title":"<code>app</code>","text":"<p>LED UI adapter for Launchpad hardware display.</p>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI","title":"<code>LaunchpadLEDUI(orchestrator, poll_interval=5.0)</code>","text":"<p>               Bases: <code>UIAdapter</code></p> <p>LED UI implementation that displays the pad grid on Launchpad hardware.</p> <p>This UI adapter implements the UIAdapter protocol and runs in the background, mirroring the TUI's grid state on the physical Launchpad LEDs.</p> <p>The LED UI: - Runs in background (non-blocking) - Mirrors the 8x8 grid state from the TUI - Shows pad assignments with configured colors - Shows playing pads with pulsing yellow animation - Automatically syncs with all state changes</p> <p>Lifecycle: 1. init: Create controller and service, register as observer 2. initialize(): Start LED controller 3. run(): Non-blocking (returns immediately) 4. shutdown(): Stop controller and clean up</p> <p>Initialize the LED UI.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp orchestrator</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for Launchpad device (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def __init__(self, orchestrator: \"LaunchpadSamplerApp\", poll_interval: float = 5.0):\n    \"\"\"\n    Initialize the LED UI.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp orchestrator\n        poll_interval: How often to check for Launchpad device (seconds)\n    \"\"\"\n    self.orchestrator = orchestrator\n    self.poll_interval = poll_interval\n\n    # We'll use the orchestrator's LaunchpadController (shared resource)\n    # This avoids MIDI port conflicts\n    self.controller = None  # Will be set in register_with_services()\n\n    # Create LED renderer (stateless) - controller will be set later\n    self.renderer = LEDRenderer(None)\n\n    # Create LED event handler (observer) - pass renderer and shared state machine\n    self.event_handler = LEDEventHandler(self.renderer, orchestrator, orchestrator.state_machine)\n\n    # Register service with orchestrator services\n    self._register_with_services()\n\n    logger.info(\"LaunchpadLEDUI initialized\")\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the LED UI before the orchestrator starts.</p> <p>The LED UI uses the orchestrator's LaunchpadController (shared resource), so there's nothing to initialize here. The controller is created by the orchestrator.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the LED UI before the orchestrator starts.\n\n    The LED UI uses the orchestrator's LaunchpadController (shared resource),\n    so there's nothing to initialize here. The controller is created by the orchestrator.\n    \"\"\"\n    logger.info(\"Initializing LED UI (using orchestrator's LaunchpadController)\")\n    # Nothing to do - we use the orchestrator's controller\n    pass\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register LED event handler with all orchestrator services after they're initialized.</p> <p>Called by orchestrator after services are created.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp instance</p> required Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"LaunchpadSamplerApp\") -&gt; None:\n    \"\"\"\n    Register LED event handler with all orchestrator services after they're initialized.\n\n    Called by orchestrator after services are created.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp instance\n    \"\"\"\n    # Use orchestrator's MIDI controller (shared resource)\n    if orchestrator.midi_controller:\n        self.controller = orchestrator.midi_controller\n        self.renderer.controller = self.controller\n        logger.info(\"LED UI using orchestrator's LaunchpadController\")\n    else:\n        logger.warning(\"No MIDI controller available - LED UI will not function\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.event_handler)\n\n    # Register for playback state events\n    orchestrator.player.register_state_observer(self.event_handler)\n\n    # Register for MIDI events (connection/disconnection only)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.event_handler)\n\n    logger.info(\"LED event handler registered with all services\")\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.run","title":"<code>run()</code>","text":"<p>Run the LED UI.</p> <p>LED UI is a background UI, so this returns immediately. The Launchpad controller runs in its own polling thread.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the LED UI.\n\n    LED UI is a background UI, so this returns immediately.\n    The Launchpad controller runs in its own polling thread.\n    \"\"\"\n    logger.info(\"LED UI running in background\")\n    # Non-blocking - LED controller runs in background thread\n    pass\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the LED UI and clean up resources.</p> <p>Since we reuse the Player's LaunchpadController, we don't stop it here. We only unregister our observers.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the LED UI and clean up resources.\n\n    Since we reuse the Player's LaunchpadController, we don't stop it here.\n    We only unregister our observers.\n    \"\"\"\n    logger.info(\"Shutting down LED UI\")\n\n    # Unregister observers\n    try:\n        self.orchestrator.unregister_observer(self.event_handler)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.event_handler)\n        if self.orchestrator.player:\n            self.orchestrator.player.unregister_state_observer(self.event_handler)\n        if self.orchestrator.midi_controller:\n            self.orchestrator.midi_controller.unregister_observer(self.event_handler)\n        logger.info(\"LED event handler unregistered from all services\")\n    except Exception as e:\n        logger.error(f\"Error unregistering LED event handler observers: {e}\")\n\n    # Don't stop the controller - we don't own it, the orchestrator does\n    logger.info(\"LED UI shut down\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/","title":"Led Event Handler","text":""},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler","title":"<code>led_event_handler</code>","text":"<p>Event handler for LED UI synchronization with application state.</p>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler","title":"<code>LEDEventHandler(renderer, orchestrator, state_machine)</code>","text":"<p>               Bases: <code>AppObserver</code>, <code>EditObserver</code>, <code>MidiObserver</code>, <code>StateObserver</code></p> <p>Event handler for synchronizing the Launchpad LED grid with application state.</p> <p>This service observes all system events and delegates LED rendering to LEDRenderer. It decouples the application core from LED-specific update logic.</p> <p>Implements multiple observer protocols: - AppObserver: App lifecycle events (SET_MOUNTED, SET_SAVED, etc.) - EditObserver: Editing events (PAD_ASSIGNED, PAD_CLEARED, etc.) - MidiObserver: MIDI controller events (NOTE_ON, NOTE_OFF, etc.) - StateObserver: Playback events (PAD_PLAYING, PAD_STOPPED, etc.)</p> <p>LED Color Scheme (synchronized with TUI via ui_colors module): - Empty pad: Off (black) - Assigned pad: Mode-specific color (red/green/blue/magenta) - Playing pad: Pulsing yellow (overrides mode color)</p> <p>Initialize the LED event handler.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>LEDRenderer</code> <p>The LED renderer for hardware updates</p> required <code>orchestrator</code> <p>The LaunchpadSamplerApp orchestrator</p> required <code>state_machine</code> <code>SamplerStateMachine</code> <p>Shared state machine for querying playback state</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def __init__(self, renderer: LEDRenderer, orchestrator, state_machine: SamplerStateMachine):\n    \"\"\"\n    Initialize the LED event handler.\n\n    Args:\n        renderer: The LED renderer for hardware updates\n        orchestrator: The LaunchpadSamplerApp orchestrator\n        state_machine: Shared state machine for querying playback state\n    \"\"\"\n    self.renderer = renderer\n    self.orchestrator = orchestrator\n    self.state_machine = state_machine\n    logger.info(\"LEDEventHandler initialized\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data</p> <code>{}</code> Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_app_event(self, event: AppEvent, **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data\n    \"\"\"\n    try:\n        if event == AppEvent.SET_MOUNTED:\n            self._handle_set_mounted(**kwargs)\n        elif event == AppEvent.SET_SAVED:\n            # No LED action needed on save\n            pass\n        elif event == AppEvent.MODE_CHANGED:\n            # No LED action needed on mode change\n            pass\n        else:\n            logger.warning(f\"LEDEventHandler received unknown app event: {event}\")\n\n    except Exception as e:\n        logger.error(f\"Error handling app event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and update LEDs.</p> <p>This is called when editing operations occur. Automatically synchronizes the LEDs with the new pad states.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events and update LEDs.\n\n    This is called when editing operations occur.\n    Automatically synchronizes the LEDs with the new pad states.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received edit event: {event.value} for pads {pad_indices}\")\n\n    try:\n        # Update LEDs for edited pads\n        for pad_index, pad in zip(pad_indices, pads):\n            self._update_pad_led(pad_index, pad)\n\n    except Exception as e:\n        logger.error(f\"Error handling edit event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>Called from MIDI thread via LaunchpadController.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    Called from MIDI thread via LaunchpadController.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received MIDI event: {event}, pad_index: {pad_index}\")\n\n    # Handle device connection/disconnection events\n    if event == MidiEvent.CONTROLLER_CONNECTED:\n        logger.info(\"Launchpad connected - syncing LED grid\")\n        # Sync all LEDs when device connects\n        self._update_all_leds()\n        # Light up panic button\n        self._set_panic_button_led()\n    elif event == MidiEvent.CONTROLLER_DISCONNECTED:\n        logger.info(\"Launchpad disconnected\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>Called from audio thread via callback.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The playback event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63)</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    Called from audio thread via callback.\n\n    Args:\n        event: The playback event that occurred\n        pad_index: Index of the pad (0-63)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received playback event: {event}, pad_index: {pad_index}\")\n\n    try:\n        if event == PlaybackEvent.PAD_PLAYING:\n            # Pad started playing - show pulsing yellow\n            self._set_pad_playing_led(pad_index, True)\n\n        elif event in (PlaybackEvent.PAD_STOPPED, PlaybackEvent.PAD_FINISHED):\n            # Pad stopped or finished - restore normal color\n            self._set_pad_playing_led(pad_index, False)\n\n    except Exception as e:\n        logger.error(f\"Error handling playback event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/","title":"Led Renderer","text":""},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer","title":"<code>led_renderer</code>","text":"<p>LED rendering logic for Launchpad hardware.</p>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer","title":"<code>LEDRenderer(controller)</code>","text":"<p>Stateless renderer that translates application state to LED hardware commands.</p> <p>This class contains only rendering logic - no event handling or state management. It queries state from canonical sources (orchestrator, state_machine) and renders the appropriate LED colors.</p> <p>Responsibilities: - Update individual pad LEDs - Update all pad LEDs in bulk - Set playing animations (pulsing) - Set panic button LED</p> <p>Initialize the LED renderer.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>Optional[DeviceController]</code> <p>The device controller instance (may be None initially)</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def __init__(self, controller: Optional[DeviceController]):\n    \"\"\"\n    Initialize the LED renderer.\n\n    Args:\n        controller: The device controller instance (may be None initially)\n    \"\"\"\n    self.controller = controller\n    logger.debug(\"LEDRenderer initialized\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.update_all_pads","title":"<code>update_all_pads(all_pads, playing_pads)</code>","text":"<p>Update all 64 pad LEDs to reflect current state.</p> <p>Parameters:</p> Name Type Description Default <code>all_pads</code> <code>list[Pad]</code> <p>List of all 64 pad states from orchestrator</p> required <code>playing_pads</code> <code>set[int]</code> <p>Set of pad indices currently playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def update_all_pads(self, all_pads: list[\"Pad\"], playing_pads: set[int]) -&gt; None:\n    \"\"\"\n    Update all 64 pad LEDs to reflect current state.\n\n    Args:\n        all_pads: List of all 64 pad states from orchestrator\n        playing_pads: Set of pad indices currently playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.warning(\"Cannot update LEDs: Controller not available or not connected\")\n        return\n\n    # Build bulk update list for non-playing pads\n    updates = []\n    for i in range(64):\n        # Check if pad is currently playing\n        if i in playing_pads:\n            # Playing pads get pulsing animation (set individually, not in bulk)\n            continue\n\n        pad = all_pads[i]\n        if pad.is_assigned:\n            # Get color from centralized color scheme\n            color = get_pad_led_color(pad, is_playing=False)\n            updates.append((i, color))\n        else:\n            # Pad is empty, turn off\n            updates.append((i, Color.off()))\n\n    # Send bulk update for non-playing pads\n    if updates:\n        self.controller.set_leds_bulk(updates)\n        logger.info(f\"Updated {len(updates)} non-playing LEDs\")\n\n    # Set playing pads with animation\n    for pad_index in playing_pads:\n        pad = all_pads[pad_index]\n        palette_color = get_pad_led_palette_index(pad, is_playing=True)\n        self.controller.set_pad_pulsing(pad_index, palette_color)\n        logger.debug(f\"Set playing animation for pad {pad_index}\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.update_pad","title":"<code>update_pad(pad_index, pad, is_playing)</code>","text":"<p>Update LED for a single pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether this pad is currently playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def update_pad(self, pad_index: int, pad: \"Pad\", is_playing: bool) -&gt; None:\n    \"\"\"\n    Update LED for a single pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        pad: Pad model\n        is_playing: Whether this pad is currently playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot update LED: Controller not available or not connected\")\n        return\n\n    # If pad is playing, don't override the playing animation\n    if is_playing:\n        return\n\n    # Set color from centralized color scheme\n    color = get_pad_led_color(pad, is_playing=False)\n    self.controller.set_pad_color(pad_index, color)\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.set_playing_animation","title":"<code>set_playing_animation(pad_index, pad, is_playing)</code>","text":"<p>Update LED to reflect pad playing state (pulsing animation).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether pad is playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def set_playing_animation(self, pad_index: int, pad: \"Pad\", is_playing: bool) -&gt; None:\n    \"\"\"\n    Update LED to reflect pad playing state (pulsing animation).\n\n    Args:\n        pad_index: Index of pad (0-63)\n        pad: Pad model\n        is_playing: Whether pad is playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot update LED: Controller not available or not connected\")\n        return\n\n    if is_playing:\n        # Pulse with playing color (centralized from ui_colors)\n        palette_color = get_pad_led_palette_index(pad, is_playing=True)\n        self.controller.set_pad_pulsing(pad_index, palette_color)\n    else:\n        # Restore normal color\n        if pad.is_assigned:\n            self.update_pad(pad_index, pad, is_playing=False)\n        else:\n            self.controller.set_pad_color(pad_index, Color.off())\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.set_panic_button","title":"<code>set_panic_button(panic_button_cc)</code>","text":"<p>Set the panic button LED to dark red.</p> <p>Parameters:</p> Name Type Description Default <code>panic_button_cc</code> <code>int</code> <p>The CC control number for the panic button</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def set_panic_button(self, panic_button_cc: int) -&gt; None:\n    \"\"\"\n    Set the panic button LED to dark red.\n\n    Args:\n        panic_button_cc: The CC control number for the panic button\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot set panic button LED: Controller not available or not connected\")\n        return\n\n    if not self.controller._device:\n        logger.debug(\"Cannot set panic button LED: Device not initialized\")\n        return\n\n    # Set the LED to dark red using the RGB color\n    self.controller._device.output.set_control_led(panic_button_cc, PANIC_BUTTON_COLOR.rgb)\n    logger.info(f\"Panic button LED set for CC {panic_button_cc}\")\n</code></pre>"},{"location":"api/midi/","title":"Midi","text":"<p>MIDI input/output management</p>"},{"location":"api/midi/#launchsampler.midi","title":"<code>midi</code>","text":"<p>MIDI management - generic MIDI functionality.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager","title":"<code>BaseMidiManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[PortType]</code></p> <p>Base MIDI manager with hot-plug support.</p> <p>Monitors for MIDI devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Subclasses must implement abstract methods for port-specific operations.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if MIDI device is currently connected.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.current_port","title":"<code>current_port</code>  <code>property</code>","text":"<p>Get currently connected port name.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    if self._running:\n        logger.warning(f\"Midi{self._get_port_type_name().capitalize()}Manager is already running\")\n        return\n\n    self._running = True\n    self._monitor_thread = threading.Thread(target=self._monitor_devices, daemon=True)\n    self._monitor_thread.start()\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager started\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    self._on_connection_changed = callback\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._running = False\n\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.close()\n            except Exception as e:\n                logger.error(f\"Error closing MIDI {self._get_port_type_name()} port: {e}\")\n            self._port = None\n\n    if self._monitor_thread and self._monitor_thread.is_alive():\n        self._monitor_thread.join(timeout=1.0)\n\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager stopped\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiInputManager","title":"<code>MidiInputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseInput]</code></p> <p>Generic MIDI input manager with hot-plug support.</p> <p>Monitors for MIDI input devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Initialize MIDI input manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI input manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    super().__init__(device_filter, poll_interval, port_selector)\n    self._message_callback: Optional[Callable[[mido.Message], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiInputManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._message_callback = callback\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager","title":"<code>MidiManager(device_filter, poll_interval=5.0, input_port_selector=None, output_port_selector=None)</code>","text":"<p>Generic MIDI manager combining input and output functionality.</p> <p>Provides a unified interface for MIDI device management with hot-plug support.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>input_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best input port from candidates.                 If None, selects first matching port.</p> <code>None</code> <code>output_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best output port from candidates.                  If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    input_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None,\n    output_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        input_port_selector: Optional function to select best input port from candidates.\n                            If None, selects first matching port.\n        output_port_selector: Optional function to select best output port from candidates.\n                             If None, selects first matching port.\n    \"\"\"\n    self._input_manager = MidiInputManager(device_filter, poll_interval, input_port_selector)\n    self._output_manager = MidiOutputManager(device_filter, poll_interval, output_port_selector)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if both input and output devices are connected.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.current_input_port","title":"<code>current_input_port</code>  <code>property</code>","text":"<p>Get currently connected input port name.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.current_output_port","title":"<code>current_output_port</code>  <code>property</code>","text":"<p>Get currently connected output port name.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._input_manager.on_message(callback)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Callback is executed when device connects or disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Callback is executed when device connects or disconnects.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    # Register same callback for both input and output (fires twice, but that's ok)\n    self._input_manager.on_connection_changed(callback)\n    self._output_manager.on_connection_changed(callback)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    return self._output_manager.send(message)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    self._input_manager.start()\n    self._output_manager.start()\n    logger.debug(\"MidiManager started\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._input_manager.stop()\n    self._output_manager.stop()\n    logger.debug(\"MidiManager stopped\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.list_ports","title":"<code>list_ports()</code>  <code>staticmethod</code>","text":"<p>List all available MIDI ports.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'input' and 'output' lists of port names</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>@staticmethod\ndef list_ports() -&gt; dict:\n    \"\"\"\n    List all available MIDI ports.\n\n    Returns:\n        Dictionary with 'input' and 'output' lists of port names\n    \"\"\"\n    return {\n        'input': mido.get_input_names(),\n        'output': mido.get_output_names()\n    }\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiOutputManager","title":"<code>MidiOutputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseOutput]</code></p> <p>Generic MIDI output manager with hot-plug support.</p> <p>Monitors for MIDI output devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiOutputManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/output_manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.send(message)\n                return True\n            except Exception as e:\n                logger.error(f\"Error sending MIDI message: {e}\")\n                return False\n        return False\n</code></pre>"},{"location":"api/midi/base_manager/","title":"Base Manager","text":""},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager","title":"<code>base_manager</code>","text":"<p>Base MIDI manager with hot-plug support.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager","title":"<code>BaseMidiManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[PortType]</code></p> <p>Base MIDI manager with hot-plug support.</p> <p>Monitors for MIDI devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Subclasses must implement abstract methods for port-specific operations.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if MIDI device is currently connected.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.current_port","title":"<code>current_port</code>  <code>property</code>","text":"<p>Get currently connected port name.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    if self._running:\n        logger.warning(f\"Midi{self._get_port_type_name().capitalize()}Manager is already running\")\n        return\n\n    self._running = True\n    self._monitor_thread = threading.Thread(target=self._monitor_devices, daemon=True)\n    self._monitor_thread.start()\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager started\")\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    self._on_connection_changed = callback\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._running = False\n\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.close()\n            except Exception as e:\n                logger.error(f\"Error closing MIDI {self._get_port_type_name()} port: {e}\")\n            self._port = None\n\n    if self._monitor_thread and self._monitor_thread.is_alive():\n        self._monitor_thread.join(timeout=1.0)\n\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager stopped\")\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/input_manager/","title":"Input Manager","text":""},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager","title":"<code>input_manager</code>","text":"<p>Generic MIDI input manager with hot-plug support.</p>"},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager.MidiInputManager","title":"<code>MidiInputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseInput]</code></p> <p>Generic MIDI input manager with hot-plug support.</p> <p>Monitors for MIDI input devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Initialize MIDI input manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI input manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    super().__init__(device_filter, poll_interval, port_selector)\n    self._message_callback: Optional[Callable[[mido.Message], None]] = None\n</code></pre>"},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager.MidiInputManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._message_callback = callback\n</code></pre>"},{"location":"api/midi/manager/","title":"Manager","text":""},{"location":"api/midi/manager/#launchsampler.midi.manager","title":"<code>manager</code>","text":"<p>Generic MIDI manager combining input and output.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager","title":"<code>MidiManager(device_filter, poll_interval=5.0, input_port_selector=None, output_port_selector=None)</code>","text":"<p>Generic MIDI manager combining input and output functionality.</p> <p>Provides a unified interface for MIDI device management with hot-plug support.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>input_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best input port from candidates.                 If None, selects first matching port.</p> <code>None</code> <code>output_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best output port from candidates.                  If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    input_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None,\n    output_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        input_port_selector: Optional function to select best input port from candidates.\n                            If None, selects first matching port.\n        output_port_selector: Optional function to select best output port from candidates.\n                             If None, selects first matching port.\n    \"\"\"\n    self._input_manager = MidiInputManager(device_filter, poll_interval, input_port_selector)\n    self._output_manager = MidiOutputManager(device_filter, poll_interval, output_port_selector)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if both input and output devices are connected.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.current_input_port","title":"<code>current_input_port</code>  <code>property</code>","text":"<p>Get currently connected input port name.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.current_output_port","title":"<code>current_output_port</code>  <code>property</code>","text":"<p>Get currently connected output port name.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._input_manager.on_message(callback)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Callback is executed when device connects or disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Callback is executed when device connects or disconnects.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    # Register same callback for both input and output (fires twice, but that's ok)\n    self._input_manager.on_connection_changed(callback)\n    self._output_manager.on_connection_changed(callback)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    return self._output_manager.send(message)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    self._input_manager.start()\n    self._output_manager.start()\n    logger.debug(\"MidiManager started\")\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._input_manager.stop()\n    self._output_manager.stop()\n    logger.debug(\"MidiManager stopped\")\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.list_ports","title":"<code>list_ports()</code>  <code>staticmethod</code>","text":"<p>List all available MIDI ports.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'input' and 'output' lists of port names</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>@staticmethod\ndef list_ports() -&gt; dict:\n    \"\"\"\n    List all available MIDI ports.\n\n    Returns:\n        Dictionary with 'input' and 'output' lists of port names\n    \"\"\"\n    return {\n        'input': mido.get_input_names(),\n        'output': mido.get_output_names()\n    }\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/output_manager/","title":"Output Manager","text":""},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager","title":"<code>output_manager</code>","text":"<p>Generic MIDI output manager with hot-plug support.</p>"},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager.MidiOutputManager","title":"<code>MidiOutputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseOutput]</code></p> <p>Generic MIDI output manager with hot-plug support.</p> <p>Monitors for MIDI output devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager.MidiOutputManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/output_manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.send(message)\n                return True\n            except Exception as e:\n                logger.error(f\"Error sending MIDI message: {e}\")\n                return False\n        return False\n</code></pre>"},{"location":"api/models/","title":"Models","text":"<p>Pydantic data models for configuration and state</p>"},{"location":"api/models/#launchsampler.models","title":"<code>models</code>","text":"<p>Data models for the Launchpad sampler.</p>"},{"location":"api/models/#launchsampler.models.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RGB color for Launchpad LED.</p>"},{"location":"api/models/#launchsampler.models.Color.validate_rgb","title":"<code>validate_rgb(v)</code>  <code>classmethod</code>","text":"<p>Ensure RGB values are in valid range.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@field_validator(\"r\", \"g\", \"b\")\n@classmethod\ndef validate_rgb(cls, v: int) -&gt; int:\n    \"\"\"Ensure RGB values are in valid range.\"\"\"\n    if not 0 &lt;= v &lt;= 127:\n        raise ValueError(\"RGB values must be between 0 and 127\")\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.off","title":"<code>off()</code>  <code>classmethod</code>","text":"<p>Create off (black) color.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@classmethod\ndef off(cls) -&gt; \"Color\":\n    \"\"\"Create off (black) color.\"\"\"\n    return cls(r=0, g=0, b=0)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.to_rgb_tuple","title":"<code>to_rgb_tuple()</code>","text":"<p>Convert to RGB tuple.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_rgb_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert to RGB tuple.\"\"\"\n    return (self.r, self.g, self.b)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert to CSS hex color string (e.g., '#FF00FF').</p> <p>Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range. This method scales the values by 2 for proper CSS display.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex color string in format '#RRGGBB'</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Convert to CSS hex color string (e.g., '#FF00FF').\n\n    Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range.\n    This method scales the values by 2 for proper CSS display.\n\n    Returns:\n        str: Hex color string in format '#RRGGBB'\n    \"\"\"\n    # Scale from 0-127 to 0-255 for CSS compatibility\n    r_scaled = self.r * 2\n    g_scaled = self.g * 2\n    b_scaled = self.b * 2\n    return f\"#{r_scaled:02X}{g_scaled:02X}{b_scaled:02X}\"\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig","title":"<code>AppConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration and settings.</p>"},{"location":"api/models/#launchsampler.models.AppConfig.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@field_serializer(\"sets_dir\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string.\"\"\"\n    return str(path)\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.ensure_directories","title":"<code>ensure_directories()</code>","text":"<p>Create config directories if they don't exist.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def ensure_directories(self) -&gt; None:\n    \"\"\"Create config directories if they don't exist.\"\"\"\n    self.sets_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.load_or_default","title":"<code>load_or_default(path=None)</code>  <code>classmethod</code>","text":"<p>Load config from file or return default.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@classmethod\ndef load_or_default(cls, path: Optional[Path] = None) -&gt; \"AppConfig\":\n    \"\"\"Load config from file or return default.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    if path.exists():\n        return cls.model_validate_json(path.read_text())\n\n    config = cls()\n    config.ensure_directories()\n    return config\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.save","title":"<code>save(path=None)</code>","text":"<p>Save config to file.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save config to file.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(self.model_dump_json(indent=2))\n</code></pre>"},{"location":"api/models/#launchsampler.models.LaunchpadColor","title":"<code>LaunchpadColor</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Complete Launchpad palette (128 colors) with both RGB and palette index.</p> <p>Each color is a tuple of (Color, palette_index). Based on Launchpad MK2/Pro palette.</p>"},{"location":"api/models/#launchsampler.models.LaunchpadColor.rgb","title":"<code>rgb</code>  <code>property</code>","text":"<p>Get the RGB Color value.</p>"},{"location":"api/models/#launchsampler.models.LaunchpadColor.palette","title":"<code>palette</code>  <code>property</code>","text":"<p>Get the palette index (0-127).</p>"},{"location":"api/models/#launchsampler.models.PlaybackMode","title":"<code>PlaybackMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Audio playback modes.</p>"},{"location":"api/models/#launchsampler.models.Launchpad","title":"<code>Launchpad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the complete 8x8 grid of pads.</p>"},{"location":"api/models/#launchsampler.models.Launchpad.assigned_pads","title":"<code>assigned_pads</code>  <code>property</code>","text":"<p>Get all pads that have samples assigned.</p>"},{"location":"api/models/#launchsampler.models.Launchpad.validate_pad_count","title":"<code>validate_pad_count(v)</code>  <code>classmethod</code>","text":"<p>Ensure exactly 64 pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@field_validator(\"pads\")\n@classmethod\ndef validate_pad_count(cls, v: list[Pad]) -&gt; list[Pad]:\n    \"\"\"Ensure exactly 64 pads.\"\"\"\n    if len(v) != TOTAL_PADS:\n        raise ValueError(f\"Launchpad must have exactly {TOTAL_PADS} pads ({GRID_SIZE}x{GRID_SIZE})\")\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; int:\n    \"\"\"Convert (x, y) coordinates to MIDI note.\"\"\"\n    return y * self.GRID_SIZE + x\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; tuple[int, int]:\n    \"\"\"Convert MIDI note to (x, y) coordinates.\"\"\"\n    y = note // self.GRID_SIZE\n    x = note % self.GRID_SIZE\n    return (x, y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.get_pad","title":"<code>get_pad(x, y)</code>","text":"<p>Get pad at specific coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad(self, x: int, y: int) -&gt; Pad:\n    \"\"\"Get pad at specific coordinates.\"\"\"\n    if not (0 &lt;= x &lt; self.GRID_SIZE and 0 &lt;= y &lt; self.GRID_SIZE):\n        raise ValueError(f\"Invalid coordinates: ({x}, {y}). Must be 0-{self.GRID_SIZE - 1}.\")\n    return self.pads[self.xy_to_note(x, y)]\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.get_pad_by_note","title":"<code>get_pad_by_note(note)</code>","text":"<p>Get pad by MIDI note number (0-63).</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad_by_note(self, note: int) -&gt; Optional[Pad]:\n    \"\"\"Get pad by MIDI note number (0-63).\"\"\"\n    if not 0 &lt;= note &lt; self.TOTAL_PADS:\n        return None\n    x, y = self.note_to_xy(note)\n    return self.get_pad(x, y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all pads.\"\"\"\n    for pad in self.pads:\n        pad.clear()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.create_empty","title":"<code>create_empty()</code>  <code>classmethod</code>","text":"<p>Create a new empty Launchpad.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef create_empty(cls) -&gt; \"Launchpad\":\n    \"\"\"Create a new empty Launchpad.\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.from_sample_directory","title":"<code>from_sample_directory(samples_dir, auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create Launchpad configuration by scanning a directory for audio samples.</p> <p>Discovers audio files (WAV, MP3, FLAC) and assigns them to pads. If auto_configure is True, infers playback mode and color from filename.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Launchpad</code> <code>Launchpad</code> <p>Configured Launchpad instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Launchpad\":\n    \"\"\"Create Launchpad configuration by scanning a directory for audio samples.\n\n    Discovers audio files (WAV, MP3, FLAC) and assigns them to pads.\n    If auto_configure is True, infers playback mode and color from filename.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Launchpad: Configured Launchpad instance\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    if not samples_dir.exists():\n        raise ValueError(f\"Samples directory not found: {samples_dir}\")\n\n    # Discover audio files recursively\n    extensions = [\"**/*.wav\", \"**/*.mp3\", \"**/*.flac\", \"**/*.ogg\", \"**/*.aiff\"]\n    sample_files = []\n    for ext in extensions:\n        sample_files.extend(samples_dir.glob(ext))\n\n    if not sample_files:\n        raise ValueError(f\"No audio files found in {samples_dir}\")\n\n    # Sort for consistent ordering\n    sample_files.sort()\n\n    # Create empty launchpad\n    launchpad = cls.create_empty()\n\n    # Assign samples to pads (max 64)\n    for i, sample_file in enumerate(sample_files[:TOTAL_PADS]):\n        sample = Sample.from_file(sample_file)\n        pad = launchpad.pads[i]\n\n        # Assign sample\n        pad.sample = sample\n        pad.volume = default_volume\n\n        # Auto-configure mode and color if requested\n        if auto_configure:\n            pad.mode = cls._infer_playback_mode(sample)\n            pad.color = MODE_COLORS[pad.mode].rgb\n        else:\n            # Use defaults from Pad model\n            pad.mode = PlaybackMode.ONE_SHOT\n            pad.color = MODE_COLORS[pad.mode].rgb\n\n        logger.debug(\n            f\"Pad {i}: {sample.name} ({pad.mode.value}, \"\n            f\"RGB={pad.color.r},{pad.color.g},{pad.color.b})\"\n        )\n\n    logger.info(f\"Loaded {len(sample_files[:TOTAL_PADS])} samples from {samples_dir}\")\n\n    return launchpad\n</code></pre>"},{"location":"api/models/#launchsampler.models.Pad","title":"<code>Pad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single pad in the 8x8 grid.</p>"},{"location":"api/models/#launchsampler.models.Pad.is_assigned","title":"<code>is_assigned</code>  <code>property</code>","text":"<p>Check if pad has a sample assigned.</p>"},{"location":"api/models/#launchsampler.models.Pad.position","title":"<code>position</code>  <code>property</code>","text":"<p>Get (x, y) position as tuple.</p>"},{"location":"api/models/#launchsampler.models.Pad.clear","title":"<code>clear()</code>","text":"<p>Clear the pad (remove sample and turn off LED).</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the pad (remove sample and turn off LED).\"\"\"\n    self.sample = None\n    self.color = Color.off()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Pad.empty","title":"<code>empty(x, y)</code>  <code>classmethod</code>","text":"<p>Create an empty pad at given position.</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>@classmethod\ndef empty(cls, x: int, y: int) -&gt; \"Pad\":\n    \"\"\"Create an empty pad at given position.\"\"\"\n    return cls(x=x, y=y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio sample metadata (not the actual audio data).</p>"},{"location":"api/models/#launchsampler.models.Sample.validate_path","title":"<code>validate_path(v)</code>  <code>classmethod</code>","text":"<p>Validate that path is a Path object.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_validator(\"path\")\n@classmethod\ndef validate_path(cls, v: Path) -&gt; Path:\n    \"\"\"Validate that path is a Path object.\"\"\"\n    if not isinstance(v, Path):\n        return Path(v)\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_serializer(\"path\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string using forward slashes for portability.\"\"\"\n    return path.as_posix()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Create Sample from file path.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; \"Sample\":\n    \"\"\"Create Sample from file path.\"\"\"\n    return cls(\n        name=path.stem,\n        path=path\n    )\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.exists","title":"<code>exists()</code>","text":"<p>Check if the audio file exists.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the audio file exists.\"\"\"\n    return self.path.exists()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set","title":"<code>Set</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A saved configuration of pad assignments.</p> <p>Path Handling: - samples_root: Optional override for where samples are located - If None (default): sample paths are relative to the Set JSON file location - If set: sample paths are relative to samples_root - Absolute paths are preserved as-is</p>"},{"location":"api/models/#launchsampler.models.Set.serialize_datetime","title":"<code>serialize_datetime(dt)</code>","text":"<p>Serialize datetime to ISO format.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"created_at\", \"modified_at\")\ndef serialize_datetime(self, dt: datetime) -&gt; str:\n    \"\"\"Serialize datetime to ISO format.\"\"\"\n    return dt.isoformat()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.serialize_samples_root","title":"<code>serialize_samples_root(samples_root)</code>","text":"<p>Serialize samples_root Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"samples_root\")\ndef serialize_samples_root(self, samples_root: Optional[Path]) -&gt; Optional[str]:\n    \"\"\"Serialize samples_root Path to string using forward slashes for portability.\"\"\"\n    return samples_root.as_posix() if samples_root else None\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.get_samples_root","title":"<code>get_samples_root(set_file_path)</code>","text":"<p>Get the root directory for resolving relative sample paths.</p> <p>Parameters:</p> Name Type Description Default <code>set_file_path</code> <code>Path</code> <p>Path to the Set JSON file</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Root directory (either explicit samples_root or Set file's directory)</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>def get_samples_root(self, set_file_path: Path) -&gt; Path:\n    \"\"\"Get the root directory for resolving relative sample paths.\n\n    Args:\n        set_file_path: Path to the Set JSON file\n\n    Returns:\n        Path: Root directory (either explicit samples_root or Set file's directory)\n    \"\"\"\n    if self.samples_root:\n        return self.samples_root\n    else:\n        # Default: samples are relative to the Set JSON file's directory\n        return set_file_path.parent\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.from_sample_directory","title":"<code>from_sample_directory(samples_dir, name='untitled', auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create a Set by scanning a directory for audio samples.</p> <p>This is a convenience method that wraps Launchpad.from_sample_directory and creates a Set with samples_root set to the scanned directory.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>name</code> <code>str</code> <p>Name for the set</p> <code>'untitled'</code> <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Set</code> <code>Set</code> <p>New set with samples loaded from directory</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    name: str = \"untitled\",\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Set\":\n    \"\"\"Create a Set by scanning a directory for audio samples.\n\n    This is a convenience method that wraps Launchpad.from_sample_directory\n    and creates a Set with samples_root set to the scanned directory.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        name: Name for the set\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Set: New set with samples loaded from directory\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    launchpad = Launchpad.from_sample_directory(\n        samples_dir=samples_dir,\n        auto_configure=auto_configure,\n        default_volume=default_volume\n    )\n\n    return cls(\n        name=name,\n        launchpad=launchpad,\n        samples_root=samples_dir  # Paths will be relative to this directory\n    )\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.create_empty","title":"<code>create_empty(name)</code>  <code>classmethod</code>","text":"<p>Create a new empty set.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef create_empty(cls, name: str) -&gt; \"Set\":\n    \"\"\"Create a new empty set.\"\"\"\n    return cls(\n        name=name,\n        launchpad=Launchpad.create_empty()\n    )\n</code></pre>"},{"location":"api/models/color/","title":"Color","text":""},{"location":"api/models/color/#launchsampler.models.color","title":"<code>color</code>","text":"<p>Color model for LED control.</p>"},{"location":"api/models/color/#launchsampler.models.color.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RGB color for Launchpad LED.</p>"},{"location":"api/models/color/#launchsampler.models.color.Color.validate_rgb","title":"<code>validate_rgb(v)</code>  <code>classmethod</code>","text":"<p>Ensure RGB values are in valid range.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@field_validator(\"r\", \"g\", \"b\")\n@classmethod\ndef validate_rgb(cls, v: int) -&gt; int:\n    \"\"\"Ensure RGB values are in valid range.\"\"\"\n    if not 0 &lt;= v &lt;= 127:\n        raise ValueError(\"RGB values must be between 0 and 127\")\n    return v\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.off","title":"<code>off()</code>  <code>classmethod</code>","text":"<p>Create off (black) color.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@classmethod\ndef off(cls) -&gt; \"Color\":\n    \"\"\"Create off (black) color.\"\"\"\n    return cls(r=0, g=0, b=0)\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.to_rgb_tuple","title":"<code>to_rgb_tuple()</code>","text":"<p>Convert to RGB tuple.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_rgb_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert to RGB tuple.\"\"\"\n    return (self.r, self.g, self.b)\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert to CSS hex color string (e.g., '#FF00FF').</p> <p>Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range. This method scales the values by 2 for proper CSS display.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex color string in format '#RRGGBB'</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Convert to CSS hex color string (e.g., '#FF00FF').\n\n    Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range.\n    This method scales the values by 2 for proper CSS display.\n\n    Returns:\n        str: Hex color string in format '#RRGGBB'\n    \"\"\"\n    # Scale from 0-127 to 0-255 for CSS compatibility\n    r_scaled = self.r * 2\n    g_scaled = self.g * 2\n    b_scaled = self.b * 2\n    return f\"#{r_scaled:02X}{g_scaled:02X}{b_scaled:02X}\"\n</code></pre>"},{"location":"api/models/config/","title":"Config","text":""},{"location":"api/models/config/#launchsampler.models.config","title":"<code>config</code>","text":"<p>Application configuration model.</p>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig","title":"<code>AppConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration and settings.</p>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@field_serializer(\"sets_dir\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string.\"\"\"\n    return str(path)\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.ensure_directories","title":"<code>ensure_directories()</code>","text":"<p>Create config directories if they don't exist.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def ensure_directories(self) -&gt; None:\n    \"\"\"Create config directories if they don't exist.\"\"\"\n    self.sets_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.load_or_default","title":"<code>load_or_default(path=None)</code>  <code>classmethod</code>","text":"<p>Load config from file or return default.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@classmethod\ndef load_or_default(cls, path: Optional[Path] = None) -&gt; \"AppConfig\":\n    \"\"\"Load config from file or return default.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    if path.exists():\n        return cls.model_validate_json(path.read_text())\n\n    config = cls()\n    config.ensure_directories()\n    return config\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.save","title":"<code>save(path=None)</code>","text":"<p>Save config to file.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save config to file.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(self.model_dump_json(indent=2))\n</code></pre>"},{"location":"api/models/enums/","title":"Enums","text":""},{"location":"api/models/enums/#launchsampler.models.enums","title":"<code>enums</code>","text":"<p>Enumerations for the Launchpad sampler.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor","title":"<code>LaunchpadColor</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Complete Launchpad palette (128 colors) with both RGB and palette index.</p> <p>Each color is a tuple of (Color, palette_index). Based on Launchpad MK2/Pro palette.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor.rgb","title":"<code>rgb</code>  <code>property</code>","text":"<p>Get the RGB Color value.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor.palette","title":"<code>palette</code>  <code>property</code>","text":"<p>Get the palette index (0-127).</p>"},{"location":"api/models/enums/#launchsampler.models.enums.PlaybackMode","title":"<code>PlaybackMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Audio playback modes.</p>"},{"location":"api/models/launchpad/","title":"Launchpad","text":""},{"location":"api/models/launchpad/#launchsampler.models.launchpad","title":"<code>launchpad</code>","text":"<p>Launchpad model representing the 8x8 grid.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad","title":"<code>Launchpad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the complete 8x8 grid of pads.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.assigned_pads","title":"<code>assigned_pads</code>  <code>property</code>","text":"<p>Get all pads that have samples assigned.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.validate_pad_count","title":"<code>validate_pad_count(v)</code>  <code>classmethod</code>","text":"<p>Ensure exactly 64 pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@field_validator(\"pads\")\n@classmethod\ndef validate_pad_count(cls, v: list[Pad]) -&gt; list[Pad]:\n    \"\"\"Ensure exactly 64 pads.\"\"\"\n    if len(v) != TOTAL_PADS:\n        raise ValueError(f\"Launchpad must have exactly {TOTAL_PADS} pads ({GRID_SIZE}x{GRID_SIZE})\")\n    return v\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; int:\n    \"\"\"Convert (x, y) coordinates to MIDI note.\"\"\"\n    return y * self.GRID_SIZE + x\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; tuple[int, int]:\n    \"\"\"Convert MIDI note to (x, y) coordinates.\"\"\"\n    y = note // self.GRID_SIZE\n    x = note % self.GRID_SIZE\n    return (x, y)\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.get_pad","title":"<code>get_pad(x, y)</code>","text":"<p>Get pad at specific coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad(self, x: int, y: int) -&gt; Pad:\n    \"\"\"Get pad at specific coordinates.\"\"\"\n    if not (0 &lt;= x &lt; self.GRID_SIZE and 0 &lt;= y &lt; self.GRID_SIZE):\n        raise ValueError(f\"Invalid coordinates: ({x}, {y}). Must be 0-{self.GRID_SIZE - 1}.\")\n    return self.pads[self.xy_to_note(x, y)]\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.get_pad_by_note","title":"<code>get_pad_by_note(note)</code>","text":"<p>Get pad by MIDI note number (0-63).</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad_by_note(self, note: int) -&gt; Optional[Pad]:\n    \"\"\"Get pad by MIDI note number (0-63).\"\"\"\n    if not 0 &lt;= note &lt; self.TOTAL_PADS:\n        return None\n    x, y = self.note_to_xy(note)\n    return self.get_pad(x, y)\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all pads.\"\"\"\n    for pad in self.pads:\n        pad.clear()\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.create_empty","title":"<code>create_empty()</code>  <code>classmethod</code>","text":"<p>Create a new empty Launchpad.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef create_empty(cls) -&gt; \"Launchpad\":\n    \"\"\"Create a new empty Launchpad.\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.from_sample_directory","title":"<code>from_sample_directory(samples_dir, auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create Launchpad configuration by scanning a directory for audio samples.</p> <p>Discovers audio files (WAV, MP3, FLAC) and assigns them to pads. If auto_configure is True, infers playback mode and color from filename.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Launchpad</code> <code>Launchpad</code> <p>Configured Launchpad instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Launchpad\":\n    \"\"\"Create Launchpad configuration by scanning a directory for audio samples.\n\n    Discovers audio files (WAV, MP3, FLAC) and assigns them to pads.\n    If auto_configure is True, infers playback mode and color from filename.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Launchpad: Configured Launchpad instance\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    if not samples_dir.exists():\n        raise ValueError(f\"Samples directory not found: {samples_dir}\")\n\n    # Discover audio files recursively\n    extensions = [\"**/*.wav\", \"**/*.mp3\", \"**/*.flac\", \"**/*.ogg\", \"**/*.aiff\"]\n    sample_files = []\n    for ext in extensions:\n        sample_files.extend(samples_dir.glob(ext))\n\n    if not sample_files:\n        raise ValueError(f\"No audio files found in {samples_dir}\")\n\n    # Sort for consistent ordering\n    sample_files.sort()\n\n    # Create empty launchpad\n    launchpad = cls.create_empty()\n\n    # Assign samples to pads (max 64)\n    for i, sample_file in enumerate(sample_files[:TOTAL_PADS]):\n        sample = Sample.from_file(sample_file)\n        pad = launchpad.pads[i]\n\n        # Assign sample\n        pad.sample = sample\n        pad.volume = default_volume\n\n        # Auto-configure mode and color if requested\n        if auto_configure:\n            pad.mode = cls._infer_playback_mode(sample)\n            pad.color = MODE_COLORS[pad.mode].rgb\n        else:\n            # Use defaults from Pad model\n            pad.mode = PlaybackMode.ONE_SHOT\n            pad.color = MODE_COLORS[pad.mode].rgb\n\n        logger.debug(\n            f\"Pad {i}: {sample.name} ({pad.mode.value}, \"\n            f\"RGB={pad.color.r},{pad.color.g},{pad.color.b})\"\n        )\n\n    logger.info(f\"Loaded {len(sample_files[:TOTAL_PADS])} samples from {samples_dir}\")\n\n    return launchpad\n</code></pre>"},{"location":"api/models/pad/","title":"Pad","text":""},{"location":"api/models/pad/#launchsampler.models.pad","title":"<code>pad</code>","text":"<p>Pad model representing a single grid cell.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad","title":"<code>Pad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single pad in the 8x8 grid.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.is_assigned","title":"<code>is_assigned</code>  <code>property</code>","text":"<p>Check if pad has a sample assigned.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.position","title":"<code>position</code>  <code>property</code>","text":"<p>Get (x, y) position as tuple.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.clear","title":"<code>clear()</code>","text":"<p>Clear the pad (remove sample and turn off LED).</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the pad (remove sample and turn off LED).\"\"\"\n    self.sample = None\n    self.color = Color.off()\n</code></pre>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.empty","title":"<code>empty(x, y)</code>  <code>classmethod</code>","text":"<p>Create an empty pad at given position.</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>@classmethod\ndef empty(cls, x: int, y: int) -&gt; \"Pad\":\n    \"\"\"Create an empty pad at given position.\"\"\"\n    return cls(x=x, y=y)\n</code></pre>"},{"location":"api/models/sample/","title":"Sample","text":""},{"location":"api/models/sample/#launchsampler.models.sample","title":"<code>sample</code>","text":"<p>Sample model for audio file metadata.</p>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio sample metadata (not the actual audio data).</p>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.validate_path","title":"<code>validate_path(v)</code>  <code>classmethod</code>","text":"<p>Validate that path is a Path object.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_validator(\"path\")\n@classmethod\ndef validate_path(cls, v: Path) -&gt; Path:\n    \"\"\"Validate that path is a Path object.\"\"\"\n    if not isinstance(v, Path):\n        return Path(v)\n    return v\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_serializer(\"path\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string using forward slashes for portability.\"\"\"\n    return path.as_posix()\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Create Sample from file path.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; \"Sample\":\n    \"\"\"Create Sample from file path.\"\"\"\n    return cls(\n        name=path.stem,\n        path=path\n    )\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.exists","title":"<code>exists()</code>","text":"<p>Check if the audio file exists.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the audio file exists.\"\"\"\n    return self.path.exists()\n</code></pre>"},{"location":"api/models/set/","title":"Set","text":""},{"location":"api/models/set/#launchsampler.models.set","title":"<code>set</code>","text":"<p>Set model for pad configurations (data structure only - persistence is in SetManagerService).</p>"},{"location":"api/models/set/#launchsampler.models.set.Set","title":"<code>Set</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A saved configuration of pad assignments.</p> <p>Path Handling: - samples_root: Optional override for where samples are located - If None (default): sample paths are relative to the Set JSON file location - If set: sample paths are relative to samples_root - Absolute paths are preserved as-is</p>"},{"location":"api/models/set/#launchsampler.models.set.Set.serialize_datetime","title":"<code>serialize_datetime(dt)</code>","text":"<p>Serialize datetime to ISO format.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"created_at\", \"modified_at\")\ndef serialize_datetime(self, dt: datetime) -&gt; str:\n    \"\"\"Serialize datetime to ISO format.\"\"\"\n    return dt.isoformat()\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.serialize_samples_root","title":"<code>serialize_samples_root(samples_root)</code>","text":"<p>Serialize samples_root Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"samples_root\")\ndef serialize_samples_root(self, samples_root: Optional[Path]) -&gt; Optional[str]:\n    \"\"\"Serialize samples_root Path to string using forward slashes for portability.\"\"\"\n    return samples_root.as_posix() if samples_root else None\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.get_samples_root","title":"<code>get_samples_root(set_file_path)</code>","text":"<p>Get the root directory for resolving relative sample paths.</p> <p>Parameters:</p> Name Type Description Default <code>set_file_path</code> <code>Path</code> <p>Path to the Set JSON file</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Root directory (either explicit samples_root or Set file's directory)</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>def get_samples_root(self, set_file_path: Path) -&gt; Path:\n    \"\"\"Get the root directory for resolving relative sample paths.\n\n    Args:\n        set_file_path: Path to the Set JSON file\n\n    Returns:\n        Path: Root directory (either explicit samples_root or Set file's directory)\n    \"\"\"\n    if self.samples_root:\n        return self.samples_root\n    else:\n        # Default: samples are relative to the Set JSON file's directory\n        return set_file_path.parent\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.from_sample_directory","title":"<code>from_sample_directory(samples_dir, name='untitled', auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create a Set by scanning a directory for audio samples.</p> <p>This is a convenience method that wraps Launchpad.from_sample_directory and creates a Set with samples_root set to the scanned directory.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>name</code> <code>str</code> <p>Name for the set</p> <code>'untitled'</code> <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Set</code> <code>Set</code> <p>New set with samples loaded from directory</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    name: str = \"untitled\",\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Set\":\n    \"\"\"Create a Set by scanning a directory for audio samples.\n\n    This is a convenience method that wraps Launchpad.from_sample_directory\n    and creates a Set with samples_root set to the scanned directory.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        name: Name for the set\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Set: New set with samples loaded from directory\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    launchpad = Launchpad.from_sample_directory(\n        samples_dir=samples_dir,\n        auto_configure=auto_configure,\n        default_volume=default_volume\n    )\n\n    return cls(\n        name=name,\n        launchpad=launchpad,\n        samples_root=samples_dir  # Paths will be relative to this directory\n    )\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.create_empty","title":"<code>create_empty(name)</code>  <code>classmethod</code>","text":"<p>Create a new empty set.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef create_empty(cls, name: str) -&gt; \"Set\":\n    \"\"\"Create a new empty set.\"\"\"\n    return cls(\n        name=name,\n        launchpad=Launchpad.create_empty()\n    )\n</code></pre>"},{"location":"api/services/","title":"Services","text":"<p>Business logic services</p>"},{"location":"api/services/#launchsampler.services","title":"<code>services</code>","text":"<p>Generic services for LaunchSampler (not TUI-specific).</p>"},{"location":"api/services/#launchsampler.services.EditorService","title":"<code>EditorService(config)</code>","text":"<p>Manages editing operations on a Launchpad configuration.</p> <p>This service encapsulates all business logic for editing pads, managing samples, and saving/loading sets. It operates directly on a Launchpad instance, with no dependency on the full app.</p> Event-Driven Architecture <p>All editing operations emit EditEvent notifications to registered observers. This ensures automatic synchronization of audio engine and UI without manual coordination.</p> Threading <p>All methods are called from the UI thread (Textual's main loop). Observer notifications are also dispatched on the UI thread. The _event_lock protects the observer list during registration, but is released before calling observers to avoid holding locks during potentially slow callbacks.</p> Dependency Injection <p>EditorService receives a Launchpad reference, not the entire app. This eliminates circular dependencies and improves testability.</p> <p>Initialize the editor service.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the editor service.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self._launchpad = None\n    self.config = config\n    self._clipboard: Optional[Pad] = None\n\n    # Event system\n    self._observers = ObserverManager[EditObserver](observer_type_name=\"edit\")\n    logger.info(\"EditorService initialized\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>Get the launchpad being edited.</p>"},{"location":"api/services/#launchsampler.services.EditorService.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get the total number of pads in the launchpad grid.</p>"},{"location":"api/services/#launchsampler.services.EditorService.has_clipboard","title":"<code>has_clipboard</code>  <code>property</code>","text":"<p>Check if clipboard has content.</p>"},{"location":"api/services/#launchsampler.services.EditorService.update_launchpad","title":"<code>update_launchpad(launchpad)</code>","text":"<p>Update the launchpad reference.</p> <p>This should be called when a new set is mounted to ensure the editor is working with the correct launchpad instance.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The new Launchpad instance to edit</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def update_launchpad(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Update the launchpad reference.\n\n    This should be called when a new set is mounted to ensure\n    the editor is working with the correct launchpad instance.\n\n    Args:\n        launchpad: The new Launchpad instance to edit\n    \"\"\"\n    self._launchpad = launchpad\n    logger.debug(\"EditorService launchpad reference updated\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive edit events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Object implementing EditObserver protocol</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def register_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive edit events.\n\n    Args:\n        observer: Object implementing EditObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def unregister_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.get_pad","title":"<code>get_pad(pad_index)</code>","text":"<p>Get a pad by index (read-only).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def get_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Get a pad by index (read-only).\n\n    Args:\n        pad_index: Index of pad to get\n\n    Returns:\n        The Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    return self.launchpad.pads[pad_index]\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.assign_sample","title":"<code>assign_sample(pad_index, sample_path)</code>","text":"<p>Assign a sample to a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to assign to</p> required <code>sample_path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If sample file doesn't exist</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def assign_sample(self, pad_index: int, sample_path: Path) -&gt; Pad:\n    \"\"\"\n    Assign a sample to a pad.\n\n    Args:\n        pad_index: Index of pad to assign to\n        sample_path: Path to audio file\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If sample file doesn't exist\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not sample_path.exists():\n        raise ValueError(f\"Sample file not found: {sample_path}\")\n\n    # Create sample from file\n    sample = Sample.from_file(sample_path)\n\n    # Get pad and assign sample\n    pad = self.launchpad.pads[pad_index]\n    was_empty = not pad.is_assigned\n    pad.sample = sample\n    pad.volume = 0.8  # Default volume\n\n    # Set default color if pad was previously empty\n    if was_empty:\n        pad.color = MODE_COLORS[pad.mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [pad_index], [pad])\n\n    logger.info(f\"Assigned sample '{sample.name}' to pad {pad_index}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_pad","title":"<code>clear_pad(pad_index)</code>","text":"<p>Clear a pad (remove sample).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The new empty Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Clear a pad (remove sample).\n\n    Args:\n        pad_index: Index of pad to clear\n\n    Returns:\n        The new empty Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    # Get current pad position\n    old_pad = self.launchpad.pads[pad_index]\n\n    # Replace with empty pad\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cleared pad {pad_index}\")\n    return new_pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_pad_mode","title":"<code>set_pad_mode(pad_index, mode)</code>","text":"<p>Change the playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; Pad:\n    \"\"\"\n    Change the playback mode for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        mode: New playback mode\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot set mode on empty pad {pad_index}\")\n\n    pad.mode = mode\n    pad.color = MODE_COLORS[mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_MODE_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} mode to {mode.value}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_pad_volume","title":"<code>set_pad_volume(pad_index, volume)</code>","text":"<p>Set the volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If volume is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_volume(self, pad_index: int, volume: float) -&gt; Pad:\n    \"\"\"\n    Set the volume for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        volume: New volume (0.0-1.0)\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If volume is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not 0.0 &lt;= volume &lt;= 1.0:\n        raise ValueError(f\"Volume {volume} out of range (0.0-1.0)\")\n\n    pad = self.launchpad.pads[pad_index]\n    pad.volume = volume\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_VOLUME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} volume to {volume:.0%}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_sample_name","title":"<code>set_sample_name(pad_index, name)</code>","text":"<p>Set the name for a pad's sample.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>name</code> <code>str</code> <p>New sample name</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned or name is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_sample_name(self, pad_index: int, name: str) -&gt; Pad:\n    \"\"\"\n    Set the name for a pad's sample.\n\n    Args:\n        pad_index: Index of pad to modify\n        name: New sample name\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned or name is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not name or not name.strip():\n        raise ValueError(\"Sample name cannot be empty\")\n\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned or not pad.sample:\n        raise ValueError(f\"Cannot set name on empty pad {pad_index}\")\n\n    pad.sample.name = name.strip()\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_NAME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} sample name to '{name}'\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.move_pad","title":"<code>move_pad(source_index, target_index, swap=False)</code>","text":"<p>Move a sample from source pad to target pad.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>swap</code> <code>bool</code> <p>If True, swap samples between pads. If False, overwrite target.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Pad, Pad]</code> <p>Tuple of (new source pad, new target pad)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def move_pad(self, source_index: int, target_index: int, swap: bool = False) -&gt; tuple[Pad, Pad]:\n    \"\"\"\n    Move a sample from source pad to target pad.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        swap: If True, swap samples between pads. If False, overwrite target.\n\n    Returns:\n        Tuple of (new source pad, new target pad)\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n    logger.info(f\"Moving sample from pad {source_index} to pad {target_index} (swap={swap})\")\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to move\")\n\n    if swap and target_pad.is_assigned:\n        # Swap samples between pads\n        # Store target pad data\n        target_sample = target_pad.sample\n        target_mode = target_pad.mode\n        target_volume = target_pad.volume\n        target_color = target_pad.color\n\n        # Move source to target\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Move target to source\n        source_pad.sample = target_sample\n        source_pad.mode = target_mode\n        source_pad.volume = target_volume\n        source_pad.color = target_color\n\n        logger.info(f\"Swapped pads {source_index} and {target_index}\")\n    else:\n        # Move/overwrite: copy source to target and clear source\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Clear source pad\n        source_pos = (source_pad.x, source_pad.y)\n        new_source = Pad.empty(source_pos[0], source_pos[1])\n        self.launchpad.pads[source_index] = new_source\n        source_pad = new_source\n\n        logger.info(f\"Moved sample from pad {source_index} to {target_index}\")\n\n    # Notify observers about both affected pads\n    self._notify_observers(\n        EditEvent.PAD_MOVED,\n        [source_index, target_index],\n        [source_pad, target_pad]\n    )\n\n    return (source_pad, target_pad)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.duplicate_pad","title":"<code>duplicate_pad(source_index, target_index, overwrite=False)</code>","text":"<p>Duplicate a sample from source pad to target pad.</p> <p>Creates a complete deep copy of the source pad, preserving only the target's position. This ensures all properties are duplicated without needing to handle them individually.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty, indices are the same,        or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def duplicate_pad(self, source_index: int, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Duplicate a sample from source pad to target pad.\n\n    Creates a complete deep copy of the source pad, preserving only\n    the target's position. This ensures all properties are duplicated\n    without needing to handle them individually.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty, indices are the same,\n                   or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to copy\")\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with duplicate from pad {source_index} ('{source_pad.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Duplicated sample '{source_pad.sample.name}' from pad {source_index} to pad {target_index}\")\n\n    # Deep copy entire source pad but preserve target position\n    new_target = source_pad.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_DUPLICATED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.copy_pad","title":"<code>copy_pad(pad_index)</code>","text":"<p>Copy a pad to the clipboard buffer.</p> <p>Creates a deep copy of the pad and stores it in an internal buffer for later pasting.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to copy</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def copy_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Copy a pad to the clipboard buffer.\n\n    Creates a deep copy of the pad and stores it in an internal buffer\n    for later pasting.\n\n    Args:\n        pad_index: Index of pad to copy\n\n    Returns:\n        The copied Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot copy empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    logger.info(f\"Copied pad {pad_index} ('{pad.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.paste_pad","title":"<code>paste_pad(target_index, overwrite=False)</code>","text":"<p>Paste the clipboard buffer to a target pad.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of pad to paste to</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If target_index is out of range</p> <code>ValueError</code> <p>If clipboard is empty or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def paste_pad(self, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Paste the clipboard buffer to a target pad.\n\n    Args:\n        target_index: Index of pad to paste to\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If target_index is out of range\n        ValueError: If clipboard is empty or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(target_index, \"Target pad index\")\n\n    if self._clipboard is None:\n        raise ValueError(\"Clipboard is empty. Copy a pad first.\")\n\n    target_pad = self.launchpad.pads[target_index]\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with paste from clipboard ('{self._clipboard.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Pasted sample '{self._clipboard.sample.name}' from clipboard to pad {target_index}\")\n\n    # Deep copy clipboard to target, preserving target position\n    new_target = self._clipboard.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers (treat paste as assignment to target)\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.cut_pad","title":"<code>cut_pad(pad_index)</code>","text":"<p>Cut a pad to the clipboard buffer and clear the source.</p> <p>Atomically copies the pad to clipboard and clears the source pad. This is equivalent to copy_pad() followed by clear_pad().</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to cut</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad (now in clipboard)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def cut_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Cut a pad to the clipboard buffer and clear the source.\n\n    Atomically copies the pad to clipboard and clears the source pad.\n    This is equivalent to copy_pad() followed by clear_pad().\n\n    Args:\n        pad_index: Index of pad to cut\n\n    Returns:\n        The copied Pad (now in clipboard)\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot cut empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    # Clear the source pad\n    old_pad = self.launchpad.pads[pad_index]\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers (source pad is now cleared)\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cut pad {pad_index} ('{self._clipboard.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads in the launchpad.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_all(self) -&gt; int:\n    \"\"\"\n    Clear all pads in the launchpad.\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    \"\"\"\n    cleared_count = 0\n    for i in range(self.grid_size):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared all pads ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_range","title":"<code>clear_range(start_index, end_index)</code>","text":"<p>Clear a range of pads.</p> <p>Parameters:</p> Name Type Description Default <code>start_index</code> <code>int</code> <p>First pad index (inclusive)</p> required <code>end_index</code> <code>int</code> <p>Last pad index (inclusive)</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If start_index or end_index is out of range</p> <code>ValueError</code> <p>If start_index &gt; end_index</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_range(self, start_index: int, end_index: int) -&gt; int:\n    \"\"\"\n    Clear a range of pads.\n\n    Args:\n        start_index: First pad index (inclusive)\n        end_index: Last pad index (inclusive)\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    Raises:\n        IndexError: If start_index or end_index is out of range\n        ValueError: If start_index &gt; end_index\n    \"\"\"\n    self._validate_pad_index(start_index, \"Start pad index\")\n    self._validate_pad_index(end_index, \"End pad index\")\n\n    if start_index &gt; end_index:\n        raise ValueError(f\"Start index {start_index} must be &lt;= end index {end_index}\")\n\n    cleared_count = 0\n    for i in range(start_index, end_index + 1):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared pads {start_index}-{end_index} ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService","title":"<code>SetManagerService(config)</code>","text":"<p>Handles set persistence and creation operations.</p> <p>This service is responsible for: - Opening existing sets from files - Creating new sets from sample directories - Saving sets to files - Managing set file paths and naming</p> <p>The service is stateless - it operates on Set objects passed to it and returns new Set objects, without storing any state internally.</p> <p>Initialize the SetManagerService.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the SetManagerService.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self.config = config\n    logger.info(\"SetManagerService initialized\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.open_set","title":"<code>open_set(path)</code>","text":"<p>Open an existing set from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the set file (.json)</p> required <p>Returns:</p> Type Description <code>Set</code> <p>Loaded Set object</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file is invalid or corrupted</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set(self, path: Path) -&gt; Set:\n    \"\"\"\n    Open an existing set from a JSON file.\n\n    Args:\n        path: Path to the set file (.json)\n\n    Returns:\n        Loaded Set object\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is invalid or corrupted\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Set file not found: {path}\")\n\n    try:\n        set_obj = self._load_set_from_file(path)\n        logger.info(f\"Opened set '{set_obj.name}' from {path}\")\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error opening set from {path}: {e}\")\n        raise ValueError(f\"Failed to open set: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.open_set_by_name","title":"<code>open_set_by_name(name)</code>","text":"<p>Open an existing set by name from the configured sets directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the set (without .json extension)</p> required <p>Returns:</p> Type Description <code>Optional[Set]</code> <p>Loaded Set object, or None if not found or error occurred</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set_by_name(self, name: str) -&gt; Optional[Set]:\n    \"\"\"\n    Open an existing set by name from the configured sets directory.\n\n    Args:\n        name: Name of the set (without .json extension)\n\n    Returns:\n        Loaded Set object, or None if not found or error occurred\n    \"\"\"\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    if not set_path.exists():\n        logger.warning(f\"Set file not found: {set_path}\")\n        return None\n\n    try:\n        return self.open_set(set_path)\n    except ValueError as e:\n        logger.error(f\"Error opening set '{name}': {e}\")\n        return None\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.create_from_directory","title":"<code>create_from_directory(samples_dir, name=None)</code>","text":"<p>Create a new set from samples in a directory.</p> <p>Scans the directory for supported audio files and creates a set with samples auto-assigned to pads.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing sample files</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name for the set (defaults to directory name)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>New Set object with samples loaded</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If directory doesn't exist or contains no valid samples</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_from_directory(self, samples_dir: Path, name: Optional[str] = None) -&gt; Set:\n    \"\"\"\n    Create a new set from samples in a directory.\n\n    Scans the directory for supported audio files and creates a set\n    with samples auto-assigned to pads.\n\n    Args:\n        samples_dir: Directory containing sample files\n        name: Optional name for the set (defaults to directory name)\n\n    Returns:\n        New Set object with samples loaded\n\n    Raises:\n        ValueError: If directory doesn't exist or contains no valid samples\n    \"\"\"\n    if not samples_dir.exists() or not samples_dir.is_dir():\n        raise ValueError(f\"Invalid samples directory: {samples_dir}\")\n\n    set_name = name or samples_dir.name\n\n    try:\n        set_obj = Set.from_sample_directory(\n            samples_dir=samples_dir,\n            name=set_name,\n            auto_configure=True\n        )\n        logger.info(\n            f\"Created set '{set_name}' with {len(set_obj.launchpad.assigned_pads)} \"\n            f\"samples from {samples_dir}\"\n        )\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error creating set from {samples_dir}: {e}\")\n        raise ValueError(f\"Failed to create set from directory: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.save_set","title":"<code>save_set(set_obj, path, new_name=None)</code>","text":"<p>Save a set to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>path</code> <code>Path</code> <p>Path where the set should be saved (.json)</p> required <code>new_name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>The saved Set object (with updated name if provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set(\n    self,\n    set_obj: Set,\n    path: Path,\n    new_name: Optional[str] = None\n) -&gt; Set:\n    \"\"\"\n    Save a set to a JSON file.\n\n    Args:\n        set_obj: The Set object to save\n        path: Path where the set should be saved (.json)\n        new_name: Optional new name for the set\n\n    Returns:\n        The saved Set object (with updated name if provided)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    try:\n        # Update name if provided\n        if new_name and set_obj.name != new_name:\n            set_obj = Set(\n                name=new_name,\n                launchpad=set_obj.launchpad,\n                samples_root=set_obj.samples_root,\n                created_at=set_obj.created_at,\n                modified_at=set_obj.modified_at\n            )\n\n        # Ensure parent directory exists\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Save the set (using internal implementation)\n        saved_set = self._save_set_to_file(set_obj, path)\n\n        logger.info(f\"Saved set '{saved_set.name}' to {path}\")\n        return saved_set\n    except Exception as e:\n        logger.error(f\"Error saving set to {path}: {e}\")\n        raise ValueError(f\"Failed to save set: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.save_set_to_library","title":"<code>save_set_to_library(set_obj, filename=None)</code>","text":"<p>Save a set to the configured sets library directory.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional filename (without .json extension).      Defaults to set_obj.name</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Set, Path]</code> <p>Tuple of (saved Set object, path where it was saved)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set_to_library(\n    self,\n    set_obj: Set,\n    filename: Optional[str] = None\n) -&gt; tuple[Set, Path]:\n    \"\"\"\n    Save a set to the configured sets library directory.\n\n    Args:\n        set_obj: The Set object to save\n        filename: Optional filename (without .json extension).\n                 Defaults to set_obj.name\n\n    Returns:\n        Tuple of (saved Set object, path where it was saved)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    name = filename or set_obj.name\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    saved_set = self.save_set(set_obj, set_path)\n    return saved_set, set_path\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.create_empty","title":"<code>create_empty(name='Untitled')</code>","text":"<p>Create a new empty set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new set</p> <code>'Untitled'</code> <p>Returns:</p> Type Description <code>Set</code> <p>New empty Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_empty(self, name: str = \"Untitled\") -&gt; Set:\n    \"\"\"\n    Create a new empty set.\n\n    Args:\n        name: Name for the new set\n\n    Returns:\n        New empty Set object\n    \"\"\"\n    set_obj = Set.create_empty(name)\n    logger.info(f\"Created empty set '{name}'\")\n    return set_obj\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.load_set","title":"<code>load_set(set_name=None, samples_dir=None)</code>","text":"<p>Load a set with smart fallback logic.</p> <p>This handles the I/O operation of loading a Set from various sources (disk, directory, or creating empty). The returned Set object can then be mounted into the application.</p> <p>Priority order: 1. Load from samples directory (if provided) 2. Load from saved set file by name 3. Create empty set as fallback</p> <p>Parameters:</p> Name Type Description Default <code>set_name</code> <code>Optional[str]</code> <p>Name of set to load (defaults to \"Untitled\")</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Directory to load samples from (highest priority)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>Loaded or created Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def load_set(\n    self,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None\n) -&gt; Set:\n    \"\"\"\n    Load a set with smart fallback logic.\n\n    This handles the I/O operation of loading a Set from various sources\n    (disk, directory, or creating empty). The returned Set object can then\n    be mounted into the application.\n\n    Priority order:\n    1. Load from samples directory (if provided)\n    2. Load from saved set file by name\n    3. Create empty set as fallback\n\n    Args:\n        set_name: Name of set to load (defaults to \"Untitled\")\n        samples_dir: Directory to load samples from (highest priority)\n\n    Returns:\n        Loaded or created Set object\n    \"\"\"\n    name = set_name or \"Untitled\"\n\n    # Priority 1: Load from samples directory\n    if samples_dir:\n        try:\n            loaded_set = self.create_from_directory(samples_dir, name)\n            logger.info(f\"Loaded initial set from samples directory: {samples_dir}\")\n            return loaded_set\n        except ValueError as e:\n            logger.error(f\"Failed to load from samples directory: {e}\")\n            # Fall through to next priority\n\n    # Priority 2: Load from saved set file\n    if name and name.lower() != \"untitled\":\n        loaded_set = self.open_set_by_name(name)\n        if loaded_set:\n            logger.info(f\"Loaded initial set from saved file: {name}\")\n            return loaded_set\n        else:\n            logger.warning(f\"Set '{name}' not found, creating empty set\")\n\n    # Fallback: empty set\n    logger.info(f\"Creating empty set '{name}'\")\n    return self.create_empty(name)\n</code></pre>"},{"location":"api/services/editor_service/","title":"Editor Service","text":""},{"location":"api/services/editor_service/#launchsampler.services.editor_service","title":"<code>editor_service</code>","text":"<p>Editor service for managing Launchpad editing operations.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService","title":"<code>EditorService(config)</code>","text":"<p>Manages editing operations on a Launchpad configuration.</p> <p>This service encapsulates all business logic for editing pads, managing samples, and saving/loading sets. It operates directly on a Launchpad instance, with no dependency on the full app.</p> Event-Driven Architecture <p>All editing operations emit EditEvent notifications to registered observers. This ensures automatic synchronization of audio engine and UI without manual coordination.</p> Threading <p>All methods are called from the UI thread (Textual's main loop). Observer notifications are also dispatched on the UI thread. The _event_lock protects the observer list during registration, but is released before calling observers to avoid holding locks during potentially slow callbacks.</p> Dependency Injection <p>EditorService receives a Launchpad reference, not the entire app. This eliminates circular dependencies and improves testability.</p> <p>Initialize the editor service.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the editor service.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self._launchpad = None\n    self.config = config\n    self._clipboard: Optional[Pad] = None\n\n    # Event system\n    self._observers = ObserverManager[EditObserver](observer_type_name=\"edit\")\n    logger.info(\"EditorService initialized\")\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>Get the launchpad being edited.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get the total number of pads in the launchpad grid.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.has_clipboard","title":"<code>has_clipboard</code>  <code>property</code>","text":"<p>Check if clipboard has content.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.update_launchpad","title":"<code>update_launchpad(launchpad)</code>","text":"<p>Update the launchpad reference.</p> <p>This should be called when a new set is mounted to ensure the editor is working with the correct launchpad instance.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The new Launchpad instance to edit</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def update_launchpad(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Update the launchpad reference.\n\n    This should be called when a new set is mounted to ensure\n    the editor is working with the correct launchpad instance.\n\n    Args:\n        launchpad: The new Launchpad instance to edit\n    \"\"\"\n    self._launchpad = launchpad\n    logger.debug(\"EditorService launchpad reference updated\")\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive edit events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Object implementing EditObserver protocol</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def register_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive edit events.\n\n    Args:\n        observer: Object implementing EditObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def unregister_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.get_pad","title":"<code>get_pad(pad_index)</code>","text":"<p>Get a pad by index (read-only).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def get_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Get a pad by index (read-only).\n\n    Args:\n        pad_index: Index of pad to get\n\n    Returns:\n        The Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    return self.launchpad.pads[pad_index]\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.assign_sample","title":"<code>assign_sample(pad_index, sample_path)</code>","text":"<p>Assign a sample to a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to assign to</p> required <code>sample_path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If sample file doesn't exist</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def assign_sample(self, pad_index: int, sample_path: Path) -&gt; Pad:\n    \"\"\"\n    Assign a sample to a pad.\n\n    Args:\n        pad_index: Index of pad to assign to\n        sample_path: Path to audio file\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If sample file doesn't exist\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not sample_path.exists():\n        raise ValueError(f\"Sample file not found: {sample_path}\")\n\n    # Create sample from file\n    sample = Sample.from_file(sample_path)\n\n    # Get pad and assign sample\n    pad = self.launchpad.pads[pad_index]\n    was_empty = not pad.is_assigned\n    pad.sample = sample\n    pad.volume = 0.8  # Default volume\n\n    # Set default color if pad was previously empty\n    if was_empty:\n        pad.color = MODE_COLORS[pad.mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [pad_index], [pad])\n\n    logger.info(f\"Assigned sample '{sample.name}' to pad {pad_index}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_pad","title":"<code>clear_pad(pad_index)</code>","text":"<p>Clear a pad (remove sample).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The new empty Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Clear a pad (remove sample).\n\n    Args:\n        pad_index: Index of pad to clear\n\n    Returns:\n        The new empty Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    # Get current pad position\n    old_pad = self.launchpad.pads[pad_index]\n\n    # Replace with empty pad\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cleared pad {pad_index}\")\n    return new_pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_pad_mode","title":"<code>set_pad_mode(pad_index, mode)</code>","text":"<p>Change the playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; Pad:\n    \"\"\"\n    Change the playback mode for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        mode: New playback mode\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot set mode on empty pad {pad_index}\")\n\n    pad.mode = mode\n    pad.color = MODE_COLORS[mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_MODE_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} mode to {mode.value}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_pad_volume","title":"<code>set_pad_volume(pad_index, volume)</code>","text":"<p>Set the volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If volume is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_volume(self, pad_index: int, volume: float) -&gt; Pad:\n    \"\"\"\n    Set the volume for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        volume: New volume (0.0-1.0)\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If volume is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not 0.0 &lt;= volume &lt;= 1.0:\n        raise ValueError(f\"Volume {volume} out of range (0.0-1.0)\")\n\n    pad = self.launchpad.pads[pad_index]\n    pad.volume = volume\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_VOLUME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} volume to {volume:.0%}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_sample_name","title":"<code>set_sample_name(pad_index, name)</code>","text":"<p>Set the name for a pad's sample.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>name</code> <code>str</code> <p>New sample name</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned or name is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_sample_name(self, pad_index: int, name: str) -&gt; Pad:\n    \"\"\"\n    Set the name for a pad's sample.\n\n    Args:\n        pad_index: Index of pad to modify\n        name: New sample name\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned or name is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not name or not name.strip():\n        raise ValueError(\"Sample name cannot be empty\")\n\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned or not pad.sample:\n        raise ValueError(f\"Cannot set name on empty pad {pad_index}\")\n\n    pad.sample.name = name.strip()\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_NAME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} sample name to '{name}'\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.move_pad","title":"<code>move_pad(source_index, target_index, swap=False)</code>","text":"<p>Move a sample from source pad to target pad.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>swap</code> <code>bool</code> <p>If True, swap samples between pads. If False, overwrite target.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Pad, Pad]</code> <p>Tuple of (new source pad, new target pad)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def move_pad(self, source_index: int, target_index: int, swap: bool = False) -&gt; tuple[Pad, Pad]:\n    \"\"\"\n    Move a sample from source pad to target pad.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        swap: If True, swap samples between pads. If False, overwrite target.\n\n    Returns:\n        Tuple of (new source pad, new target pad)\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n    logger.info(f\"Moving sample from pad {source_index} to pad {target_index} (swap={swap})\")\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to move\")\n\n    if swap and target_pad.is_assigned:\n        # Swap samples between pads\n        # Store target pad data\n        target_sample = target_pad.sample\n        target_mode = target_pad.mode\n        target_volume = target_pad.volume\n        target_color = target_pad.color\n\n        # Move source to target\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Move target to source\n        source_pad.sample = target_sample\n        source_pad.mode = target_mode\n        source_pad.volume = target_volume\n        source_pad.color = target_color\n\n        logger.info(f\"Swapped pads {source_index} and {target_index}\")\n    else:\n        # Move/overwrite: copy source to target and clear source\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Clear source pad\n        source_pos = (source_pad.x, source_pad.y)\n        new_source = Pad.empty(source_pos[0], source_pos[1])\n        self.launchpad.pads[source_index] = new_source\n        source_pad = new_source\n\n        logger.info(f\"Moved sample from pad {source_index} to {target_index}\")\n\n    # Notify observers about both affected pads\n    self._notify_observers(\n        EditEvent.PAD_MOVED,\n        [source_index, target_index],\n        [source_pad, target_pad]\n    )\n\n    return (source_pad, target_pad)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.duplicate_pad","title":"<code>duplicate_pad(source_index, target_index, overwrite=False)</code>","text":"<p>Duplicate a sample from source pad to target pad.</p> <p>Creates a complete deep copy of the source pad, preserving only the target's position. This ensures all properties are duplicated without needing to handle them individually.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty, indices are the same,        or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def duplicate_pad(self, source_index: int, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Duplicate a sample from source pad to target pad.\n\n    Creates a complete deep copy of the source pad, preserving only\n    the target's position. This ensures all properties are duplicated\n    without needing to handle them individually.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty, indices are the same,\n                   or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to copy\")\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with duplicate from pad {source_index} ('{source_pad.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Duplicated sample '{source_pad.sample.name}' from pad {source_index} to pad {target_index}\")\n\n    # Deep copy entire source pad but preserve target position\n    new_target = source_pad.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_DUPLICATED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.copy_pad","title":"<code>copy_pad(pad_index)</code>","text":"<p>Copy a pad to the clipboard buffer.</p> <p>Creates a deep copy of the pad and stores it in an internal buffer for later pasting.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to copy</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def copy_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Copy a pad to the clipboard buffer.\n\n    Creates a deep copy of the pad and stores it in an internal buffer\n    for later pasting.\n\n    Args:\n        pad_index: Index of pad to copy\n\n    Returns:\n        The copied Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot copy empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    logger.info(f\"Copied pad {pad_index} ('{pad.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.paste_pad","title":"<code>paste_pad(target_index, overwrite=False)</code>","text":"<p>Paste the clipboard buffer to a target pad.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of pad to paste to</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If target_index is out of range</p> <code>ValueError</code> <p>If clipboard is empty or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def paste_pad(self, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Paste the clipboard buffer to a target pad.\n\n    Args:\n        target_index: Index of pad to paste to\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If target_index is out of range\n        ValueError: If clipboard is empty or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(target_index, \"Target pad index\")\n\n    if self._clipboard is None:\n        raise ValueError(\"Clipboard is empty. Copy a pad first.\")\n\n    target_pad = self.launchpad.pads[target_index]\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with paste from clipboard ('{self._clipboard.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Pasted sample '{self._clipboard.sample.name}' from clipboard to pad {target_index}\")\n\n    # Deep copy clipboard to target, preserving target position\n    new_target = self._clipboard.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers (treat paste as assignment to target)\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.cut_pad","title":"<code>cut_pad(pad_index)</code>","text":"<p>Cut a pad to the clipboard buffer and clear the source.</p> <p>Atomically copies the pad to clipboard and clears the source pad. This is equivalent to copy_pad() followed by clear_pad().</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to cut</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad (now in clipboard)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def cut_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Cut a pad to the clipboard buffer and clear the source.\n\n    Atomically copies the pad to clipboard and clears the source pad.\n    This is equivalent to copy_pad() followed by clear_pad().\n\n    Args:\n        pad_index: Index of pad to cut\n\n    Returns:\n        The copied Pad (now in clipboard)\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot cut empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    # Clear the source pad\n    old_pad = self.launchpad.pads[pad_index]\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers (source pad is now cleared)\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cut pad {pad_index} ('{self._clipboard.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads in the launchpad.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_all(self) -&gt; int:\n    \"\"\"\n    Clear all pads in the launchpad.\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    \"\"\"\n    cleared_count = 0\n    for i in range(self.grid_size):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared all pads ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_range","title":"<code>clear_range(start_index, end_index)</code>","text":"<p>Clear a range of pads.</p> <p>Parameters:</p> Name Type Description Default <code>start_index</code> <code>int</code> <p>First pad index (inclusive)</p> required <code>end_index</code> <code>int</code> <p>Last pad index (inclusive)</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If start_index or end_index is out of range</p> <code>ValueError</code> <p>If start_index &gt; end_index</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_range(self, start_index: int, end_index: int) -&gt; int:\n    \"\"\"\n    Clear a range of pads.\n\n    Args:\n        start_index: First pad index (inclusive)\n        end_index: Last pad index (inclusive)\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    Raises:\n        IndexError: If start_index or end_index is out of range\n        ValueError: If start_index &gt; end_index\n    \"\"\"\n    self._validate_pad_index(start_index, \"Start pad index\")\n    self._validate_pad_index(end_index, \"End pad index\")\n\n    if start_index &gt; end_index:\n        raise ValueError(f\"Start index {start_index} must be &lt;= end index {end_index}\")\n\n    cleared_count = 0\n    for i in range(start_index, end_index + 1):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared pads {start_index}-{end_index} ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/set_manager_service/","title":"Set Manager Service","text":""},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service","title":"<code>set_manager_service</code>","text":"<p>Service for managing set persistence and loading.</p>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService","title":"<code>SetManagerService(config)</code>","text":"<p>Handles set persistence and creation operations.</p> <p>This service is responsible for: - Opening existing sets from files - Creating new sets from sample directories - Saving sets to files - Managing set file paths and naming</p> <p>The service is stateless - it operates on Set objects passed to it and returns new Set objects, without storing any state internally.</p> <p>Initialize the SetManagerService.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the SetManagerService.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self.config = config\n    logger.info(\"SetManagerService initialized\")\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.open_set","title":"<code>open_set(path)</code>","text":"<p>Open an existing set from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the set file (.json)</p> required <p>Returns:</p> Type Description <code>Set</code> <p>Loaded Set object</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file is invalid or corrupted</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set(self, path: Path) -&gt; Set:\n    \"\"\"\n    Open an existing set from a JSON file.\n\n    Args:\n        path: Path to the set file (.json)\n\n    Returns:\n        Loaded Set object\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is invalid or corrupted\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Set file not found: {path}\")\n\n    try:\n        set_obj = self._load_set_from_file(path)\n        logger.info(f\"Opened set '{set_obj.name}' from {path}\")\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error opening set from {path}: {e}\")\n        raise ValueError(f\"Failed to open set: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.open_set_by_name","title":"<code>open_set_by_name(name)</code>","text":"<p>Open an existing set by name from the configured sets directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the set (without .json extension)</p> required <p>Returns:</p> Type Description <code>Optional[Set]</code> <p>Loaded Set object, or None if not found or error occurred</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set_by_name(self, name: str) -&gt; Optional[Set]:\n    \"\"\"\n    Open an existing set by name from the configured sets directory.\n\n    Args:\n        name: Name of the set (without .json extension)\n\n    Returns:\n        Loaded Set object, or None if not found or error occurred\n    \"\"\"\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    if not set_path.exists():\n        logger.warning(f\"Set file not found: {set_path}\")\n        return None\n\n    try:\n        return self.open_set(set_path)\n    except ValueError as e:\n        logger.error(f\"Error opening set '{name}': {e}\")\n        return None\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.create_from_directory","title":"<code>create_from_directory(samples_dir, name=None)</code>","text":"<p>Create a new set from samples in a directory.</p> <p>Scans the directory for supported audio files and creates a set with samples auto-assigned to pads.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing sample files</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name for the set (defaults to directory name)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>New Set object with samples loaded</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If directory doesn't exist or contains no valid samples</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_from_directory(self, samples_dir: Path, name: Optional[str] = None) -&gt; Set:\n    \"\"\"\n    Create a new set from samples in a directory.\n\n    Scans the directory for supported audio files and creates a set\n    with samples auto-assigned to pads.\n\n    Args:\n        samples_dir: Directory containing sample files\n        name: Optional name for the set (defaults to directory name)\n\n    Returns:\n        New Set object with samples loaded\n\n    Raises:\n        ValueError: If directory doesn't exist or contains no valid samples\n    \"\"\"\n    if not samples_dir.exists() or not samples_dir.is_dir():\n        raise ValueError(f\"Invalid samples directory: {samples_dir}\")\n\n    set_name = name or samples_dir.name\n\n    try:\n        set_obj = Set.from_sample_directory(\n            samples_dir=samples_dir,\n            name=set_name,\n            auto_configure=True\n        )\n        logger.info(\n            f\"Created set '{set_name}' with {len(set_obj.launchpad.assigned_pads)} \"\n            f\"samples from {samples_dir}\"\n        )\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error creating set from {samples_dir}: {e}\")\n        raise ValueError(f\"Failed to create set from directory: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.save_set","title":"<code>save_set(set_obj, path, new_name=None)</code>","text":"<p>Save a set to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>path</code> <code>Path</code> <p>Path where the set should be saved (.json)</p> required <code>new_name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>The saved Set object (with updated name if provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set(\n    self,\n    set_obj: Set,\n    path: Path,\n    new_name: Optional[str] = None\n) -&gt; Set:\n    \"\"\"\n    Save a set to a JSON file.\n\n    Args:\n        set_obj: The Set object to save\n        path: Path where the set should be saved (.json)\n        new_name: Optional new name for the set\n\n    Returns:\n        The saved Set object (with updated name if provided)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    try:\n        # Update name if provided\n        if new_name and set_obj.name != new_name:\n            set_obj = Set(\n                name=new_name,\n                launchpad=set_obj.launchpad,\n                samples_root=set_obj.samples_root,\n                created_at=set_obj.created_at,\n                modified_at=set_obj.modified_at\n            )\n\n        # Ensure parent directory exists\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Save the set (using internal implementation)\n        saved_set = self._save_set_to_file(set_obj, path)\n\n        logger.info(f\"Saved set '{saved_set.name}' to {path}\")\n        return saved_set\n    except Exception as e:\n        logger.error(f\"Error saving set to {path}: {e}\")\n        raise ValueError(f\"Failed to save set: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.save_set_to_library","title":"<code>save_set_to_library(set_obj, filename=None)</code>","text":"<p>Save a set to the configured sets library directory.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional filename (without .json extension).      Defaults to set_obj.name</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Set, Path]</code> <p>Tuple of (saved Set object, path where it was saved)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set_to_library(\n    self,\n    set_obj: Set,\n    filename: Optional[str] = None\n) -&gt; tuple[Set, Path]:\n    \"\"\"\n    Save a set to the configured sets library directory.\n\n    Args:\n        set_obj: The Set object to save\n        filename: Optional filename (without .json extension).\n                 Defaults to set_obj.name\n\n    Returns:\n        Tuple of (saved Set object, path where it was saved)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    name = filename or set_obj.name\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    saved_set = self.save_set(set_obj, set_path)\n    return saved_set, set_path\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.create_empty","title":"<code>create_empty(name='Untitled')</code>","text":"<p>Create a new empty set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new set</p> <code>'Untitled'</code> <p>Returns:</p> Type Description <code>Set</code> <p>New empty Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_empty(self, name: str = \"Untitled\") -&gt; Set:\n    \"\"\"\n    Create a new empty set.\n\n    Args:\n        name: Name for the new set\n\n    Returns:\n        New empty Set object\n    \"\"\"\n    set_obj = Set.create_empty(name)\n    logger.info(f\"Created empty set '{name}'\")\n    return set_obj\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.load_set","title":"<code>load_set(set_name=None, samples_dir=None)</code>","text":"<p>Load a set with smart fallback logic.</p> <p>This handles the I/O operation of loading a Set from various sources (disk, directory, or creating empty). The returned Set object can then be mounted into the application.</p> <p>Priority order: 1. Load from samples directory (if provided) 2. Load from saved set file by name 3. Create empty set as fallback</p> <p>Parameters:</p> Name Type Description Default <code>set_name</code> <code>Optional[str]</code> <p>Name of set to load (defaults to \"Untitled\")</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Directory to load samples from (highest priority)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>Loaded or created Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def load_set(\n    self,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None\n) -&gt; Set:\n    \"\"\"\n    Load a set with smart fallback logic.\n\n    This handles the I/O operation of loading a Set from various sources\n    (disk, directory, or creating empty). The returned Set object can then\n    be mounted into the application.\n\n    Priority order:\n    1. Load from samples directory (if provided)\n    2. Load from saved set file by name\n    3. Create empty set as fallback\n\n    Args:\n        set_name: Name of set to load (defaults to \"Untitled\")\n        samples_dir: Directory to load samples from (highest priority)\n\n    Returns:\n        Loaded or created Set object\n    \"\"\"\n    name = set_name or \"Untitled\"\n\n    # Priority 1: Load from samples directory\n    if samples_dir:\n        try:\n            loaded_set = self.create_from_directory(samples_dir, name)\n            logger.info(f\"Loaded initial set from samples directory: {samples_dir}\")\n            return loaded_set\n        except ValueError as e:\n            logger.error(f\"Failed to load from samples directory: {e}\")\n            # Fall through to next priority\n\n    # Priority 2: Load from saved set file\n    if name and name.lower() != \"untitled\":\n        loaded_set = self.open_set_by_name(name)\n        if loaded_set:\n            logger.info(f\"Loaded initial set from saved file: {name}\")\n            return loaded_set\n        else:\n            logger.warning(f\"Set '{name}' not found, creating empty set\")\n\n    # Fallback: empty set\n    logger.info(f\"Creating empty set '{name}'\")\n    return self.create_empty(name)\n</code></pre>"},{"location":"api/tui/","title":"Tui","text":"<p>Terminal user interface</p>"},{"location":"api/tui/#launchsampler.tui","title":"<code>tui</code>","text":"<p>TUI (Text User Interface) package for Launchpad Sampler.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler","title":"<code>LaunchpadSampler(orchestrator, start_mode='play')</code>","text":"<p>               Bases: <code>App</code></p> <p>Textual TUI for Launchpad Sampler.</p> <p>This is a PURE UI layer that delegates all business logic to the orchestrator. The orchestrator (LaunchpadSamplerApp) owns all state and services.</p> <p>Implements UIAdapter protocol via structural subtyping (no explicit inheritance to avoid metaclass conflicts between App and Protocol).</p> <p>Responsibilities: - Textual framework integration (widgets, layouts, bindings) - UI event handling (keyboard, mouse) - Visual presentation and updates via TUIService</p> <p>The orchestrator provides: - Core state (launchpad, current_set, mode) - Services (Player, EditorService, SetManagerService) - Observer pattern for UI synchronization</p> <p>Modes: - Edit Mode: Build sets, assign samples, configure pads - Play Mode: Full MIDI integration for live performance</p> <p>Switch modes anytime with E (edit) or P (play) keys.</p> <p>Initialize the Textual UI application.</p> <p>This is a thin UI layer that delegates all business logic to the orchestrator. The orchestrator should NOT be initialized yet - call orchestrator.initialize() after registering this UI to ensure event synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp orchestrator instance (not yet initialized)</p> required <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'play'</code> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def __init__(\n    self,\n    orchestrator: \"LaunchpadSamplerApp\",\n    start_mode: str = \"play\"\n):\n    \"\"\"\n    Initialize the Textual UI application.\n\n    This is a thin UI layer that delegates all business logic to the orchestrator.\n    The orchestrator should NOT be initialized yet - call orchestrator.initialize()\n    after registering this UI to ensure event synchronization.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp orchestrator instance (not yet initialized)\n        start_mode: Mode to start in (\"edit\" or \"play\")\n    \"\"\"\n    super().__init__()\n\n    # Orchestrator owns all business logic and state\n    self.orchestrator = orchestrator\n    self.config = orchestrator.config\n    self._start_mode = start_mode\n\n    # UI-specific ephemeral state (not persisted)\n    self._selected_pad_index: Optional[int] = None\n\n    # Services\n    self.tui_service: Optional[TUIService] = None  # Initialized in initialize()\n    self.navigation: NavigationService = NavigationService(orchestrator.launchpad)\n\n    self._selection_observers: list = []  # For SelectionObserver pattern\n    self._initialized = False  # Track initialization state\n    logger.info(\"LaunchpadSampler TUI created\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>READ-ONLY access to launchpad state.</p> <p>Do NOT mutate this directly. Use EditorService methods to make changes (they fire events for observer synchronization).</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.current_set","title":"<code>current_set</code>  <code>property</code>","text":"<p>READ-ONLY access to current set.</p> <p>To change sets, use orchestrator.mount_set() which fires AppEvent.SET_MOUNTED for observers.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.set_manager","title":"<code>set_manager</code>  <code>property</code>","text":"<p>Get the set manager service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.player","title":"<code>player</code>  <code>property</code>","text":"<p>Get the player service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get the editor service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.selected_pad_index","title":"<code>selected_pad_index</code>  <code>property</code>","text":"<p>Get the currently selected pad index (UI state).</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the TUI and register observers.</p> <p>This is called by orchestrator.run() to set up the TUI service and register app-level observers.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the TUI and register observers.\n\n    This is called by orchestrator.run() to set up the TUI service\n    and register app-level observers.\n    \"\"\"\n    if self._initialized:\n        logger.warning(\"TUI already initialized\")\n        return\n\n    logger.info(\"Initializing TUI service and registering observers\")\n\n    # Create TUI service - handles ALL UI updates via observer pattern\n    self.tui_service = TUIService(self)\n\n    # Register TUI service for app-level events (SET_MOUNTED, MODE_CHANGED)\n    self.orchestrator.register_observer(self.tui_service)\n\n    # Register for selection events (UI-specific state)\n    self.register_selection_observer(self.tui_service)\n\n    self._initialized = True\n    logger.info(\"TUI initialization complete - ready to receive events\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register TUI service with orchestrator services.</p> <p>Called by orchestrator.initialize() after services are created but BEFORE events are fired. This ensures we receive all edit events.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The orchestrator with initialized services</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"LaunchpadSamplerApp\") -&gt; None:\n    \"\"\"\n    Register TUI service with orchestrator services.\n\n    Called by orchestrator.initialize() after services are created\n    but BEFORE events are fired. This ensures we receive all edit events.\n\n    Args:\n        orchestrator: The orchestrator with initialized services\n    \"\"\"\n    if not self.tui_service:\n        raise RuntimeError(\"TUI service not initialized - call initialize() first\")\n\n    logger.info(\"Registering TUI service with orchestrator services\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.tui_service)\n\n    # Register for MIDI events (for visual feedback - green borders)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.tui_service)\n        logger.info(\"TUI service registered as MIDI observer\")\n\n    # Register for playback events\n    orchestrator.player.set_playback_callback(self.tui_service.on_playback_event)\n\n    logger.info(\"TUI service registered with all orchestrator services\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.run","title":"<code>run()</code>","text":"<p>Run the Textual TUI (blocks until app exits).</p> <p>This is called by the orchestrator after initialization completes. The orchestrator has already fired startup events which the TUI received.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the Textual TUI (blocks until app exits).\n\n    This is called by the orchestrator after initialization completes.\n    The orchestrator has already fired startup events which the TUI received.\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"TUI must be initialized before running\")\n\n    logger.info(\"Starting Textual TUI\")\n    # Call Textual's run method (blocks until app exits)\n    super().run()\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the TUI and clean up resources.</p> <p>Called by the orchestrator during application exit.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the TUI and clean up resources.\n\n    Called by the orchestrator during application exit.\n    \"\"\"\n    logger.info(\"Shutting down TUI\")\n    # Unregister observers\n    if self.tui_service:\n        self.orchestrator.unregister_observer(self.tui_service)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.tui_service)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Select a pad (UI operation).</p> <p>This updates UI-specific selection state and notifies selection observers. This does NOT modify persistent data or fire EditEvent.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Select a pad (UI operation).\n\n    This updates UI-specific selection state and notifies selection observers.\n    This does NOT modify persistent data or fire EditEvent.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; 64:\n        logger.error(f\"Pad index {pad_index} out of range\")\n        return\n\n    self._selected_pad_index = pad_index\n\n    # Notify selection observers (TUIService will update UI)\n    self._notify_selection_observers(SelectionEvent.CHANGED, pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.clear_pad_selection","title":"<code>clear_pad_selection()</code>","text":"<p>Clear pad selection (UI operation - renamed to avoid Textual API conflict).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def clear_pad_selection(self) -&gt; None:\n    \"\"\"Clear pad selection (UI operation - renamed to avoid Textual API conflict).\"\"\"\n    self._notify_selection_observers(SelectionEvent.CLEARED, None)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.register_selection_observer","title":"<code>register_selection_observer(observer)</code>","text":"<p>Register an observer for selection events.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_selection_observer(self, observer) -&gt; None:\n    \"\"\"Register an observer for selection events.\"\"\"\n    if observer not in self._selection_observers:\n        self._selection_observers.append(observer)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.compose","title":"<code>compose()</code>","text":"<p>Create the main layout.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the main layout.\"\"\"\n    yield Header(show_clock=True)\n\n    with Horizontal():\n        yield PadGrid()  # No launchpad parameter - data-driven\n        yield PadDetailsPanel()\n\n    yield StatusBar()\n    yield Footer()\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_mount","title":"<code>on_mount()</code>","text":"<p>Initialize the app after Textual mounting.</p> <p>At this point, Textual is running with its event loop active, so we can safely process events and update widgets.</p> <p>Flow: 1. UIAdapter.initialize() has created TUI service and registered app observers 2. Now Textual is running (we're in on_mount) 3. Initialize the grid widgets 4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED) 5. TUI service receives events and updates widgets (now they exist!)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Initialize the app after Textual mounting.\n\n    At this point, Textual is running with its event loop active,\n    so we can safely process events and update widgets.\n\n    Flow:\n    1. UIAdapter.initialize() has created TUI service and registered app observers\n    2. Now Textual is running (we're in on_mount)\n    3. Initialize the grid widgets\n    4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED)\n    5. TUI service receives events and updates widgets (now they exist!)\n    \"\"\"\n    if not self._initialized or not self.tui_service:\n        raise RuntimeError(\"TUI must be initialized via UIAdapter.initialize() before mounting\")\n\n    logger.info(\"TUI mounting - Textual is now running\")\n\n    # Initialize grid with launchpad (creates button widgets)\n    grid = self.query_one(PadGrid)\n    grid.initialize_pads(self.launchpad)\n\n    # NOW initialize the orchestrator (Textual is running, widgets exist)\n    # orchestrator.initialize() will:\n    # 1. Create services (SetManager, Player, Editor)\n    # 2. Call ui.register_with_services() to register observers\n    # 3. Fire SET_MOUNTED and MODE_CHANGED events (TUI service receives and processes them)\n    logger.info(\"Initializing orchestrator from TUI on_mount\")\n    self.orchestrator.initialize()\n\n    # Update subtitle (events have already synced the widgets)\n    if self.orchestrator.mode:\n        self.sub_title = f\"{self.orchestrator.mode.title()}: {self.current_set.name}\"\n\n    logger.info(\"TUI mount complete - orchestrator initialized, UI synchronized\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_unmount","title":"<code>on_unmount()</code>","text":"<p>Cleanup when Textual app unmounts.</p> <p>Note: Orchestrator shutdown is handled by orchestrator.shutdown(), which calls our UIAdapter.shutdown() method. We don't call it here to avoid double-shutdown.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_unmount(self) -&gt; None:\n    \"\"\"\n    Cleanup when Textual app unmounts.\n\n    Note: Orchestrator shutdown is handled by orchestrator.shutdown(),\n    which calls our UIAdapter.shutdown() method. We don't call it here\n    to avoid double-shutdown.\n    \"\"\"\n    logger.info(\"TUI unmounted\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_switch_mode","title":"<code>action_switch_mode(mode)</code>","text":"<p>Switch between edit and play modes.</p> <p>Entry point for keybindings (E/P keys). Delegates to _set_mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_switch_mode(self, mode: str) -&gt; None:\n    \"\"\"\n    Switch between edit and play modes.\n\n    Entry point for keybindings (E/P keys). Delegates to _set_mode.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n    \"\"\"\n    self._set_mode(mode)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_grid_pad_selected","title":"<code>on_pad_grid_pad_selected(message)</code>","text":"<p>Handle pad selection from grid.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_pad_grid_pad_selected(self, message: PadGrid.PadSelected) -&gt; None:\n    \"\"\"Handle pad selection from grid.\"\"\"\n    if self._sampler_mode == \"edit\":\n        try:\n            self.select_pad(message.pad_index)  # Fires SelectionEvent\n        except Exception as e:\n            logger.error(f\"Error selecting pad: {e}\")\n            self.notify(f\"Error selecting pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses from details panel.\"\"\"\n    button_id = event.button.id\n\n    if not button_id:\n        return\n\n    if button_id == \"browse-btn\":\n        self.action_browse_sample()\n    elif button_id == \"clear-btn\":\n        self.action_delete_pad()\n    elif button_id == \"test-btn\":\n        self.action_test_pad()\n    elif button_id == \"stop-btn\":\n        self.action_toggle_test()  # Use same toggle behavior\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_radio_set_changed","title":"<code>on_radio_set_changed(event)</code>","text":"<p>Handle mode radio button changes.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_radio_set_changed(self, event: RadioSet.Changed) -&gt; None:\n    \"\"\"Handle mode radio button changes.\"\"\"\n    if event.radio_set.id != \"mode-radio\":\n        return\n\n    # Map radio button IDs to playback modes\n    mode_map = {\n        \"mode-oneshot\": PlaybackMode.ONE_SHOT,\n        \"mode-loop\": PlaybackMode.LOOP,\n        \"mode-hold\": PlaybackMode.HOLD,\n        \"mode-looptoggle\": PlaybackMode.LOOP_TOGGLE\n    }\n\n    pressed_id = event.pressed.id if event.pressed else None\n    if pressed_id in mode_map:\n        self._set_pad_mode(mode_map[pressed_id])\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_volume_changed","title":"<code>on_pad_details_panel_volume_changed(event)</code>","text":"<p>Handle volume change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_volume_changed(self, event: PadDetailsPanel.VolumeChanged) -&gt; None:\n    \"\"\"Handle volume change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle audio/UI sync automatically)\n        _ = self.editor.set_pad_volume(event.pad_index, event.volume)\n\n    except Exception as e:\n        logger.error(f\"Error updating volume: {e}\")\n        self.notify(f\"Error updating volume: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_name_changed","title":"<code>on_pad_details_panel_name_changed(event)</code>","text":"<p>Handle name change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_name_changed(self, event: PadDetailsPanel.NameChanged) -&gt; None:\n    \"\"\"Handle name change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle UI sync automatically)\n        _ = self.editor.set_sample_name(event.pad_index, event.name)\n\n    except Exception as e:\n        logger.error(f\"Error updating name: {e}\")\n        self.notify(f\"Error updating name: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_move_pad_requested","title":"<code>on_pad_details_panel_move_pad_requested(event)</code>","text":"<p>Handle move pad request from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_move_pad_requested(self, event: PadDetailsPanel.MovePadRequested) -&gt; None:\n    \"\"\"Handle move pad request from details panel.\"\"\"\n    try:\n        source_index = event.source_index\n        target_index = event.target_index\n        logger.info(f\"Move request received: {source_index} -&gt; {target_index}\")\n\n        # Check if target pad has a sample\n        target_pad = self.editor.get_pad(target_index)\n\n        if target_pad.is_assigned:\n            # Target has a sample - ask user what to do\n\n            logger.info(f\"Target pad {target_index} has sample, showing modal\")\n\n            # Show modal and handle result via callback\n            def handle_move_choice(result: str) -&gt; None:\n                \"\"\"Handle the user's choice from the modal.\"\"\"\n                logger.info(f\"Modal callback received result: {result}\")\n                if result == \"cancel\":\n                    logger.info(\"User cancelled move\")\n                    return\n                elif result == \"swap\":\n                    swap = True\n                elif result == \"overwrite\":\n                    swap = False\n                else:\n                    logger.warning(f\"Unknown result: {result}\")\n                    return\n\n                # Perform the move with user's choice\n                logger.info(f\"Executing move with swap={swap}\")\n                self._perform_pad_move(source_index, target_index, swap)\n\n            self.push_screen(\n                MoveConfirmationModal(\n                    source_index=source_index,\n                    target_index=target_index,\n                    target_sample_name=target_pad.sample.name if target_pad.sample else \"Unknown\"\n                ),\n                callback=handle_move_choice\n            )\n            logger.info(\"Modal pushed, waiting for user input\")\n        else:\n            # Target is empty - just move\n            logger.info(f\"Target pad {target_index} is empty, moving directly\")\n            self._perform_pad_move(source_index, target_index, swap=False)\n\n    except Exception as e:\n        logger.error(f\"Error moving pad: {e}\")\n        self.notify(f\"Error moving pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_browse_sample","title":"<code>action_browse_sample()</code>","text":"<p>Open file browser to assign a sample.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_browse_sample(self) -&gt; None:\n    \"\"\"Open file browser to assign a sample.\"\"\"\n    if self.selected_pad_index is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    # Capture selected pad index (guaranteed not None here)\n    selected_pad = self.selected_pad_index\n\n    def handle_file(file_path: Optional[Path]) -&gt; None:\n        if file_path:\n            try:\n                # Assign sample (events handle audio/UI sync automatically)\n                pad = self.editor.assign_sample(selected_pad, file_path)\n\n                # Safe to access sample.name after assign_sample\n                if pad.sample:\n                    self.notify(f\"Assigned: {pad.sample.name}\")\n            except Exception as e:\n                logger.error(f\"Error assigning sample: {e}\")\n                self.notify(f\"Error: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    browse_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(\n        FileBrowserScreen(browse_dir),\n        handle_file\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_save","title":"<code>action_save()</code>","text":"<p>Save the current set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_save(self) -&gt; None:\n    \"\"\"Save the current set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_save(result: Optional[tuple[Path, str]]) -&gt; None:\n        if result:\n            directory, filename = result\n            try:\n                # Construct full path\n                save_path = directory / f\"{filename}.json\"\n\n                # Update set name if changed\n                if self.current_set.name != filename:\n                    self.current_set = Set(\n                        name=filename,\n                        launchpad=self.launchpad,\n                        samples_root=self.current_set.samples_root,\n                        created_at=self.current_set.created_at,\n                        modified_at=self.current_set.modified_at\n                    )\n\n                # Save set using SetManagerService\n                self.set_manager.save_set(self.current_set, save_path)\n\n                self.notify(f\"Saved set to: {save_path}\")\n\n                # Update subtitle\n                if self._sampler_mode:\n                    self.sub_title = f\"{self._sampler_mode.title()}: {filename}\"\n\n            except Exception as e:\n                logger.error(f\"Error saving set: {e}\")\n                self.notify(f\"Error saving: {e}\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(\n        SaveSetBrowserScreen(self.config.sets_dir, self.current_set.name),\n        handle_save\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_load","title":"<code>action_load()</code>","text":"<p>Load a saved set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_load(self) -&gt; None:\n    \"\"\"Load a saved set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_load(set_path: Optional[Path]) -&gt; None:\n        if set_path:\n            try:\n                # Load set using SetManagerService\n                loaded_set = self.set_manager.open_set(set_path)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                self.notify(f\"Loaded set: {loaded_set.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading set: {e}\")\n                self.notify(\"Error loading set file\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(SetFileBrowserScreen(self.set_manager, self.config.sets_dir), handle_load)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_open_directory","title":"<code>action_open_directory()</code>","text":"<p>Open a directory to load samples from.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_open_directory(self) -&gt; None:\n    \"\"\"Open a directory to load samples from.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_directory_selected(dir_path: Optional[Path]) -&gt; None:\n        if dir_path:\n            try:\n                # Load samples using SetManagerService\n                loaded_set = self.set_manager.create_from_directory(dir_path, dir_path.name)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                # Switch to edit mode after loading directory\n                self._set_mode(\"edit\")\n\n                self.notify(f\"Loaded {len(self.launchpad.assigned_pads)} samples from {dir_path.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading directory: {e}\")\n                self.notify(f\"Error loading directory: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    start_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(DirectoryBrowserScreen(start_dir), handle_directory_selected)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_copy_pad","title":"<code>action_copy_pad()</code>","text":"<p>Copy selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_copy_pad(self) -&gt; None:\n    \"\"\"Copy selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        pad = self.editor.copy_pad(selected_pad)\n        self.notify(f\"Copied: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_cut_pad","title":"<code>action_cut_pad()</code>","text":"<p>Cut selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_cut_pad(self) -&gt; None:\n    \"\"\"Cut selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        # Stop playback if pad is playing\n        if self.player.is_pad_playing(selected_pad):\n            self.player.stop_pad(selected_pad)\n            self._set_pad_playing_ui(selected_pad, False)\n\n        # Cut pad (events handle audio/UI sync automatically)\n        pad = self.editor.cut_pad(selected_pad)\n\n        self.notify(f\"Cut: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_paste_pad","title":"<code>action_paste_pad()</code>","text":"<p>Paste clipboard to selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_paste_pad(self) -&gt; None:\n    \"\"\"Paste clipboard to selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    if not self.editor.has_clipboard:\n        self.notify(\"Clipboard is empty\", severity=\"warning\")\n        return\n\n    try:\n        # Try paste with overwrite=False first (events handle audio/UI sync automatically)\n        pad = self.editor.paste_pad(selected_pad, overwrite=False)\n\n        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n\n    except ValueError as e:\n        # Check if it's because target is occupied\n        if \"already has sample\" in str(e):\n            # Show confirmation modal\n            target_pad = self.editor.get_pad(selected_pad)\n\n            def handle_paste_confirm(overwrite: bool) -&gt; None:\n                if overwrite:\n                    try:\n                        # Paste (events handle audio/UI sync automatically)\n                        pad = self.editor.paste_pad(selected_pad, overwrite=True)\n                        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n                    except Exception as e:\n                        logger.error(f\"Error pasting: {e}\")\n                        self.notify(f\"Error: {e}\", severity=\"error\")\n\n            self.push_screen(\n                PasteConfirmationModal(selected_pad, target_pad.sample.name),\n                handle_paste_confirm\n            )\n        else:\n            # Some other error\n            self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_delete_pad","title":"<code>action_delete_pad()</code>","text":"<p>Delete the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_delete_pad(self) -&gt; None:\n    \"\"\"Delete the selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Check if pad has a sample\n    pad = self.editor.get_pad(selected_pad)\n    if not pad.is_assigned or not pad.sample:\n        self.notify(\"Pad is already empty\", severity=\"warning\")\n        return\n\n    # Show confirmation modal\n    def handle_confirmation(confirmed: bool) -&gt; None:\n        if not confirmed:\n            return\n\n        try:\n            # Clear pad (events handle audio/UI sync automatically)\n            _ = self.editor.clear_pad(selected_pad)\n\n            self.notify(\"Pad deleted\")\n        except Exception as e:\n            logger.error(f\"Error deleting pad: {e}\")\n            self.notify(f\"Error: {e}\", severity=\"error\")\n\n    self.push_screen(\n        ClearConfirmationModal(selected_pad, pad.sample.name),\n        handle_confirmation\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_up","title":"<code>action_navigate_up()</code>","text":"<p>Navigate to pad above current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_up(self) -&gt; None:\n    \"\"\"Navigate to pad above current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"up\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_down","title":"<code>action_navigate_down()</code>","text":"<p>Navigate to pad below current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_down(self) -&gt; None:\n    \"\"\"Navigate to pad below current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"down\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_left","title":"<code>action_navigate_left()</code>","text":"<p>Navigate to pad left of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_left(self) -&gt; None:\n    \"\"\"Navigate to pad left of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"left\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_right","title":"<code>action_navigate_right()</code>","text":"<p>Navigate to pad right of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_right(self) -&gt; None:\n    \"\"\"Navigate to pad right of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"right\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_up","title":"<code>action_duplicate_up()</code>","text":"<p>Duplicate selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_up(self) -&gt; None:\n    \"\"\"Duplicate selected pad upward.\"\"\"\n    self._duplicate_directional(\"up\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_down","title":"<code>action_duplicate_down()</code>","text":"<p>Duplicate selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_down(self) -&gt; None:\n    \"\"\"Duplicate selected pad downward.\"\"\"\n    self._duplicate_directional(\"down\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_left","title":"<code>action_duplicate_left()</code>","text":"<p>Duplicate selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_left(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the left.\"\"\"\n    self._duplicate_directional(\"left\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_right","title":"<code>action_duplicate_right()</code>","text":"<p>Duplicate selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_right(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the right.\"\"\"\n    self._duplicate_directional(\"right\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_up","title":"<code>action_move_up()</code>","text":"<p>Move selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_up(self) -&gt; None:\n    \"\"\"Move selected pad upward.\"\"\"\n    self._move_directional(\"up\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_down","title":"<code>action_move_down()</code>","text":"<p>Move selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_down(self) -&gt; None:\n    \"\"\"Move selected pad downward.\"\"\"\n    self._move_directional(\"down\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_left","title":"<code>action_move_left()</code>","text":"<p>Move selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_left(self) -&gt; None:\n    \"\"\"Move selected pad to the left.\"\"\"\n    self._move_directional(\"left\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_right","title":"<code>action_move_right()</code>","text":"<p>Move selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_right(self) -&gt; None:\n    \"\"\"Move selected pad to the right.\"\"\"\n    self._move_directional(\"right\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_test_pad","title":"<code>action_test_pad()</code>","text":"<p>Test the selected pad (works in both modes).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_test_pad(self) -&gt; None:\n    \"\"\"Test the selected pad (works in both modes).\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if pad.is_assigned:\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_toggle_test","title":"<code>action_toggle_test()</code>","text":"<p>Toggle between test and stop for the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_toggle_test(self) -&gt; None:\n    \"\"\"Toggle between test and stop for the selected pad.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if not pad.is_assigned:\n        return\n\n    # Check if pad is currently playing\n    if self.player.is_pad_playing(self.selected_pad_index):\n        # Stop the pad - goes through queue and fires proper events\n        self.player.stop_pad(self.selected_pad_index)\n    else:\n        # Start the pad\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_stop_audio","title":"<code>action_stop_audio()</code>","text":"<p>Stop all audio playback.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_stop_audio(self) -&gt; None:\n    \"\"\"Stop all audio playback.\"\"\"\n    self.player.stop_all()\n\n    # Also release selected pad if in HOLD mode\n    if self.selected_pad_index is not None:\n        self.player.release_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_one_shot","title":"<code>action_set_mode_one_shot()</code>","text":"<p>Set selected pad to one-shot mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_one_shot(self) -&gt; None:\n    \"\"\"Set selected pad to one-shot mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.ONE_SHOT)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_loop","title":"<code>action_set_mode_loop()</code>","text":"<p>Set selected pad to loop mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop(self) -&gt; None:\n    \"\"\"Set selected pad to loop mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_hold","title":"<code>action_set_mode_hold()</code>","text":"<p>Set selected pad to hold mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_hold(self) -&gt; None:\n    \"\"\"Set selected pad to hold mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.HOLD)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_loop_toggle","title":"<code>action_set_mode_loop_toggle()</code>","text":"<p>Set selected pad to loop toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to loop toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP_TOGGLE)\n</code></pre>"},{"location":"api/tui/app/","title":"App","text":""},{"location":"api/tui/app/#launchsampler.tui.app","title":"<code>app</code>","text":"<p>Main unified TUI application with edit and play modes.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler","title":"<code>LaunchpadSampler(orchestrator, start_mode='play')</code>","text":"<p>               Bases: <code>App</code></p> <p>Textual TUI for Launchpad Sampler.</p> <p>This is a PURE UI layer that delegates all business logic to the orchestrator. The orchestrator (LaunchpadSamplerApp) owns all state and services.</p> <p>Implements UIAdapter protocol via structural subtyping (no explicit inheritance to avoid metaclass conflicts between App and Protocol).</p> <p>Responsibilities: - Textual framework integration (widgets, layouts, bindings) - UI event handling (keyboard, mouse) - Visual presentation and updates via TUIService</p> <p>The orchestrator provides: - Core state (launchpad, current_set, mode) - Services (Player, EditorService, SetManagerService) - Observer pattern for UI synchronization</p> <p>Modes: - Edit Mode: Build sets, assign samples, configure pads - Play Mode: Full MIDI integration for live performance</p> <p>Switch modes anytime with E (edit) or P (play) keys.</p> <p>Initialize the Textual UI application.</p> <p>This is a thin UI layer that delegates all business logic to the orchestrator. The orchestrator should NOT be initialized yet - call orchestrator.initialize() after registering this UI to ensure event synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The LaunchpadSamplerApp orchestrator instance (not yet initialized)</p> required <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'play'</code> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def __init__(\n    self,\n    orchestrator: \"LaunchpadSamplerApp\",\n    start_mode: str = \"play\"\n):\n    \"\"\"\n    Initialize the Textual UI application.\n\n    This is a thin UI layer that delegates all business logic to the orchestrator.\n    The orchestrator should NOT be initialized yet - call orchestrator.initialize()\n    after registering this UI to ensure event synchronization.\n\n    Args:\n        orchestrator: The LaunchpadSamplerApp orchestrator instance (not yet initialized)\n        start_mode: Mode to start in (\"edit\" or \"play\")\n    \"\"\"\n    super().__init__()\n\n    # Orchestrator owns all business logic and state\n    self.orchestrator = orchestrator\n    self.config = orchestrator.config\n    self._start_mode = start_mode\n\n    # UI-specific ephemeral state (not persisted)\n    self._selected_pad_index: Optional[int] = None\n\n    # Services\n    self.tui_service: Optional[TUIService] = None  # Initialized in initialize()\n    self.navigation: NavigationService = NavigationService(orchestrator.launchpad)\n\n    self._selection_observers: list = []  # For SelectionObserver pattern\n    self._initialized = False  # Track initialization state\n    logger.info(\"LaunchpadSampler TUI created\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>READ-ONLY access to launchpad state.</p> <p>Do NOT mutate this directly. Use EditorService methods to make changes (they fire events for observer synchronization).</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.current_set","title":"<code>current_set</code>  <code>property</code>","text":"<p>READ-ONLY access to current set.</p> <p>To change sets, use orchestrator.mount_set() which fires AppEvent.SET_MOUNTED for observers.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.set_manager","title":"<code>set_manager</code>  <code>property</code>","text":"<p>Get the set manager service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.player","title":"<code>player</code>  <code>property</code>","text":"<p>Get the player service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get the editor service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.selected_pad_index","title":"<code>selected_pad_index</code>  <code>property</code>","text":"<p>Get the currently selected pad index (UI state).</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the TUI and register observers.</p> <p>This is called by orchestrator.run() to set up the TUI service and register app-level observers.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the TUI and register observers.\n\n    This is called by orchestrator.run() to set up the TUI service\n    and register app-level observers.\n    \"\"\"\n    if self._initialized:\n        logger.warning(\"TUI already initialized\")\n        return\n\n    logger.info(\"Initializing TUI service and registering observers\")\n\n    # Create TUI service - handles ALL UI updates via observer pattern\n    self.tui_service = TUIService(self)\n\n    # Register TUI service for app-level events (SET_MOUNTED, MODE_CHANGED)\n    self.orchestrator.register_observer(self.tui_service)\n\n    # Register for selection events (UI-specific state)\n    self.register_selection_observer(self.tui_service)\n\n    self._initialized = True\n    logger.info(\"TUI initialization complete - ready to receive events\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register TUI service with orchestrator services.</p> <p>Called by orchestrator.initialize() after services are created but BEFORE events are fired. This ensures we receive all edit events.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>LaunchpadSamplerApp</code> <p>The orchestrator with initialized services</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"LaunchpadSamplerApp\") -&gt; None:\n    \"\"\"\n    Register TUI service with orchestrator services.\n\n    Called by orchestrator.initialize() after services are created\n    but BEFORE events are fired. This ensures we receive all edit events.\n\n    Args:\n        orchestrator: The orchestrator with initialized services\n    \"\"\"\n    if not self.tui_service:\n        raise RuntimeError(\"TUI service not initialized - call initialize() first\")\n\n    logger.info(\"Registering TUI service with orchestrator services\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.tui_service)\n\n    # Register for MIDI events (for visual feedback - green borders)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.tui_service)\n        logger.info(\"TUI service registered as MIDI observer\")\n\n    # Register for playback events\n    orchestrator.player.set_playback_callback(self.tui_service.on_playback_event)\n\n    logger.info(\"TUI service registered with all orchestrator services\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.run","title":"<code>run()</code>","text":"<p>Run the Textual TUI (blocks until app exits).</p> <p>This is called by the orchestrator after initialization completes. The orchestrator has already fired startup events which the TUI received.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the Textual TUI (blocks until app exits).\n\n    This is called by the orchestrator after initialization completes.\n    The orchestrator has already fired startup events which the TUI received.\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"TUI must be initialized before running\")\n\n    logger.info(\"Starting Textual TUI\")\n    # Call Textual's run method (blocks until app exits)\n    super().run()\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the TUI and clean up resources.</p> <p>Called by the orchestrator during application exit.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the TUI and clean up resources.\n\n    Called by the orchestrator during application exit.\n    \"\"\"\n    logger.info(\"Shutting down TUI\")\n    # Unregister observers\n    if self.tui_service:\n        self.orchestrator.unregister_observer(self.tui_service)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.tui_service)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Select a pad (UI operation).</p> <p>This updates UI-specific selection state and notifies selection observers. This does NOT modify persistent data or fire EditEvent.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Select a pad (UI operation).\n\n    This updates UI-specific selection state and notifies selection observers.\n    This does NOT modify persistent data or fire EditEvent.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; 64:\n        logger.error(f\"Pad index {pad_index} out of range\")\n        return\n\n    self._selected_pad_index = pad_index\n\n    # Notify selection observers (TUIService will update UI)\n    self._notify_selection_observers(SelectionEvent.CHANGED, pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.clear_pad_selection","title":"<code>clear_pad_selection()</code>","text":"<p>Clear pad selection (UI operation - renamed to avoid Textual API conflict).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def clear_pad_selection(self) -&gt; None:\n    \"\"\"Clear pad selection (UI operation - renamed to avoid Textual API conflict).\"\"\"\n    self._notify_selection_observers(SelectionEvent.CLEARED, None)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.register_selection_observer","title":"<code>register_selection_observer(observer)</code>","text":"<p>Register an observer for selection events.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_selection_observer(self, observer) -&gt; None:\n    \"\"\"Register an observer for selection events.\"\"\"\n    if observer not in self._selection_observers:\n        self._selection_observers.append(observer)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.compose","title":"<code>compose()</code>","text":"<p>Create the main layout.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the main layout.\"\"\"\n    yield Header(show_clock=True)\n\n    with Horizontal():\n        yield PadGrid()  # No launchpad parameter - data-driven\n        yield PadDetailsPanel()\n\n    yield StatusBar()\n    yield Footer()\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_mount","title":"<code>on_mount()</code>","text":"<p>Initialize the app after Textual mounting.</p> <p>At this point, Textual is running with its event loop active, so we can safely process events and update widgets.</p> <p>Flow: 1. UIAdapter.initialize() has created TUI service and registered app observers 2. Now Textual is running (we're in on_mount) 3. Initialize the grid widgets 4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED) 5. TUI service receives events and updates widgets (now they exist!)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Initialize the app after Textual mounting.\n\n    At this point, Textual is running with its event loop active,\n    so we can safely process events and update widgets.\n\n    Flow:\n    1. UIAdapter.initialize() has created TUI service and registered app observers\n    2. Now Textual is running (we're in on_mount)\n    3. Initialize the grid widgets\n    4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED)\n    5. TUI service receives events and updates widgets (now they exist!)\n    \"\"\"\n    if not self._initialized or not self.tui_service:\n        raise RuntimeError(\"TUI must be initialized via UIAdapter.initialize() before mounting\")\n\n    logger.info(\"TUI mounting - Textual is now running\")\n\n    # Initialize grid with launchpad (creates button widgets)\n    grid = self.query_one(PadGrid)\n    grid.initialize_pads(self.launchpad)\n\n    # NOW initialize the orchestrator (Textual is running, widgets exist)\n    # orchestrator.initialize() will:\n    # 1. Create services (SetManager, Player, Editor)\n    # 2. Call ui.register_with_services() to register observers\n    # 3. Fire SET_MOUNTED and MODE_CHANGED events (TUI service receives and processes them)\n    logger.info(\"Initializing orchestrator from TUI on_mount\")\n    self.orchestrator.initialize()\n\n    # Update subtitle (events have already synced the widgets)\n    if self.orchestrator.mode:\n        self.sub_title = f\"{self.orchestrator.mode.title()}: {self.current_set.name}\"\n\n    logger.info(\"TUI mount complete - orchestrator initialized, UI synchronized\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_unmount","title":"<code>on_unmount()</code>","text":"<p>Cleanup when Textual app unmounts.</p> <p>Note: Orchestrator shutdown is handled by orchestrator.shutdown(), which calls our UIAdapter.shutdown() method. We don't call it here to avoid double-shutdown.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_unmount(self) -&gt; None:\n    \"\"\"\n    Cleanup when Textual app unmounts.\n\n    Note: Orchestrator shutdown is handled by orchestrator.shutdown(),\n    which calls our UIAdapter.shutdown() method. We don't call it here\n    to avoid double-shutdown.\n    \"\"\"\n    logger.info(\"TUI unmounted\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_switch_mode","title":"<code>action_switch_mode(mode)</code>","text":"<p>Switch between edit and play modes.</p> <p>Entry point for keybindings (E/P keys). Delegates to _set_mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_switch_mode(self, mode: str) -&gt; None:\n    \"\"\"\n    Switch between edit and play modes.\n\n    Entry point for keybindings (E/P keys). Delegates to _set_mode.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n    \"\"\"\n    self._set_mode(mode)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_grid_pad_selected","title":"<code>on_pad_grid_pad_selected(message)</code>","text":"<p>Handle pad selection from grid.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_pad_grid_pad_selected(self, message: PadGrid.PadSelected) -&gt; None:\n    \"\"\"Handle pad selection from grid.\"\"\"\n    if self._sampler_mode == \"edit\":\n        try:\n            self.select_pad(message.pad_index)  # Fires SelectionEvent\n        except Exception as e:\n            logger.error(f\"Error selecting pad: {e}\")\n            self.notify(f\"Error selecting pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses from details panel.\"\"\"\n    button_id = event.button.id\n\n    if not button_id:\n        return\n\n    if button_id == \"browse-btn\":\n        self.action_browse_sample()\n    elif button_id == \"clear-btn\":\n        self.action_delete_pad()\n    elif button_id == \"test-btn\":\n        self.action_test_pad()\n    elif button_id == \"stop-btn\":\n        self.action_toggle_test()  # Use same toggle behavior\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_radio_set_changed","title":"<code>on_radio_set_changed(event)</code>","text":"<p>Handle mode radio button changes.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_radio_set_changed(self, event: RadioSet.Changed) -&gt; None:\n    \"\"\"Handle mode radio button changes.\"\"\"\n    if event.radio_set.id != \"mode-radio\":\n        return\n\n    # Map radio button IDs to playback modes\n    mode_map = {\n        \"mode-oneshot\": PlaybackMode.ONE_SHOT,\n        \"mode-loop\": PlaybackMode.LOOP,\n        \"mode-hold\": PlaybackMode.HOLD,\n        \"mode-looptoggle\": PlaybackMode.LOOP_TOGGLE\n    }\n\n    pressed_id = event.pressed.id if event.pressed else None\n    if pressed_id in mode_map:\n        self._set_pad_mode(mode_map[pressed_id])\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_volume_changed","title":"<code>on_pad_details_panel_volume_changed(event)</code>","text":"<p>Handle volume change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_volume_changed(self, event: PadDetailsPanel.VolumeChanged) -&gt; None:\n    \"\"\"Handle volume change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle audio/UI sync automatically)\n        _ = self.editor.set_pad_volume(event.pad_index, event.volume)\n\n    except Exception as e:\n        logger.error(f\"Error updating volume: {e}\")\n        self.notify(f\"Error updating volume: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_name_changed","title":"<code>on_pad_details_panel_name_changed(event)</code>","text":"<p>Handle name change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_name_changed(self, event: PadDetailsPanel.NameChanged) -&gt; None:\n    \"\"\"Handle name change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle UI sync automatically)\n        _ = self.editor.set_sample_name(event.pad_index, event.name)\n\n    except Exception as e:\n        logger.error(f\"Error updating name: {e}\")\n        self.notify(f\"Error updating name: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_move_pad_requested","title":"<code>on_pad_details_panel_move_pad_requested(event)</code>","text":"<p>Handle move pad request from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_move_pad_requested(self, event: PadDetailsPanel.MovePadRequested) -&gt; None:\n    \"\"\"Handle move pad request from details panel.\"\"\"\n    try:\n        source_index = event.source_index\n        target_index = event.target_index\n        logger.info(f\"Move request received: {source_index} -&gt; {target_index}\")\n\n        # Check if target pad has a sample\n        target_pad = self.editor.get_pad(target_index)\n\n        if target_pad.is_assigned:\n            # Target has a sample - ask user what to do\n\n            logger.info(f\"Target pad {target_index} has sample, showing modal\")\n\n            # Show modal and handle result via callback\n            def handle_move_choice(result: str) -&gt; None:\n                \"\"\"Handle the user's choice from the modal.\"\"\"\n                logger.info(f\"Modal callback received result: {result}\")\n                if result == \"cancel\":\n                    logger.info(\"User cancelled move\")\n                    return\n                elif result == \"swap\":\n                    swap = True\n                elif result == \"overwrite\":\n                    swap = False\n                else:\n                    logger.warning(f\"Unknown result: {result}\")\n                    return\n\n                # Perform the move with user's choice\n                logger.info(f\"Executing move with swap={swap}\")\n                self._perform_pad_move(source_index, target_index, swap)\n\n            self.push_screen(\n                MoveConfirmationModal(\n                    source_index=source_index,\n                    target_index=target_index,\n                    target_sample_name=target_pad.sample.name if target_pad.sample else \"Unknown\"\n                ),\n                callback=handle_move_choice\n            )\n            logger.info(\"Modal pushed, waiting for user input\")\n        else:\n            # Target is empty - just move\n            logger.info(f\"Target pad {target_index} is empty, moving directly\")\n            self._perform_pad_move(source_index, target_index, swap=False)\n\n    except Exception as e:\n        logger.error(f\"Error moving pad: {e}\")\n        self.notify(f\"Error moving pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_browse_sample","title":"<code>action_browse_sample()</code>","text":"<p>Open file browser to assign a sample.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_browse_sample(self) -&gt; None:\n    \"\"\"Open file browser to assign a sample.\"\"\"\n    if self.selected_pad_index is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    # Capture selected pad index (guaranteed not None here)\n    selected_pad = self.selected_pad_index\n\n    def handle_file(file_path: Optional[Path]) -&gt; None:\n        if file_path:\n            try:\n                # Assign sample (events handle audio/UI sync automatically)\n                pad = self.editor.assign_sample(selected_pad, file_path)\n\n                # Safe to access sample.name after assign_sample\n                if pad.sample:\n                    self.notify(f\"Assigned: {pad.sample.name}\")\n            except Exception as e:\n                logger.error(f\"Error assigning sample: {e}\")\n                self.notify(f\"Error: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    browse_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(\n        FileBrowserScreen(browse_dir),\n        handle_file\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_save","title":"<code>action_save()</code>","text":"<p>Save the current set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_save(self) -&gt; None:\n    \"\"\"Save the current set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_save(result: Optional[tuple[Path, str]]) -&gt; None:\n        if result:\n            directory, filename = result\n            try:\n                # Construct full path\n                save_path = directory / f\"{filename}.json\"\n\n                # Update set name if changed\n                if self.current_set.name != filename:\n                    self.current_set = Set(\n                        name=filename,\n                        launchpad=self.launchpad,\n                        samples_root=self.current_set.samples_root,\n                        created_at=self.current_set.created_at,\n                        modified_at=self.current_set.modified_at\n                    )\n\n                # Save set using SetManagerService\n                self.set_manager.save_set(self.current_set, save_path)\n\n                self.notify(f\"Saved set to: {save_path}\")\n\n                # Update subtitle\n                if self._sampler_mode:\n                    self.sub_title = f\"{self._sampler_mode.title()}: {filename}\"\n\n            except Exception as e:\n                logger.error(f\"Error saving set: {e}\")\n                self.notify(f\"Error saving: {e}\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(\n        SaveSetBrowserScreen(self.config.sets_dir, self.current_set.name),\n        handle_save\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_load","title":"<code>action_load()</code>","text":"<p>Load a saved set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_load(self) -&gt; None:\n    \"\"\"Load a saved set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_load(set_path: Optional[Path]) -&gt; None:\n        if set_path:\n            try:\n                # Load set using SetManagerService\n                loaded_set = self.set_manager.open_set(set_path)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                self.notify(f\"Loaded set: {loaded_set.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading set: {e}\")\n                self.notify(\"Error loading set file\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(SetFileBrowserScreen(self.set_manager, self.config.sets_dir), handle_load)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_open_directory","title":"<code>action_open_directory()</code>","text":"<p>Open a directory to load samples from.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_open_directory(self) -&gt; None:\n    \"\"\"Open a directory to load samples from.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_directory_selected(dir_path: Optional[Path]) -&gt; None:\n        if dir_path:\n            try:\n                # Load samples using SetManagerService\n                loaded_set = self.set_manager.create_from_directory(dir_path, dir_path.name)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                # Switch to edit mode after loading directory\n                self._set_mode(\"edit\")\n\n                self.notify(f\"Loaded {len(self.launchpad.assigned_pads)} samples from {dir_path.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading directory: {e}\")\n                self.notify(f\"Error loading directory: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    start_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(DirectoryBrowserScreen(start_dir), handle_directory_selected)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_copy_pad","title":"<code>action_copy_pad()</code>","text":"<p>Copy selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_copy_pad(self) -&gt; None:\n    \"\"\"Copy selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        pad = self.editor.copy_pad(selected_pad)\n        self.notify(f\"Copied: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_cut_pad","title":"<code>action_cut_pad()</code>","text":"<p>Cut selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_cut_pad(self) -&gt; None:\n    \"\"\"Cut selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        # Stop playback if pad is playing\n        if self.player.is_pad_playing(selected_pad):\n            self.player.stop_pad(selected_pad)\n            self._set_pad_playing_ui(selected_pad, False)\n\n        # Cut pad (events handle audio/UI sync automatically)\n        pad = self.editor.cut_pad(selected_pad)\n\n        self.notify(f\"Cut: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_paste_pad","title":"<code>action_paste_pad()</code>","text":"<p>Paste clipboard to selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_paste_pad(self) -&gt; None:\n    \"\"\"Paste clipboard to selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    if not self.editor.has_clipboard:\n        self.notify(\"Clipboard is empty\", severity=\"warning\")\n        return\n\n    try:\n        # Try paste with overwrite=False first (events handle audio/UI sync automatically)\n        pad = self.editor.paste_pad(selected_pad, overwrite=False)\n\n        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n\n    except ValueError as e:\n        # Check if it's because target is occupied\n        if \"already has sample\" in str(e):\n            # Show confirmation modal\n            target_pad = self.editor.get_pad(selected_pad)\n\n            def handle_paste_confirm(overwrite: bool) -&gt; None:\n                if overwrite:\n                    try:\n                        # Paste (events handle audio/UI sync automatically)\n                        pad = self.editor.paste_pad(selected_pad, overwrite=True)\n                        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n                    except Exception as e:\n                        logger.error(f\"Error pasting: {e}\")\n                        self.notify(f\"Error: {e}\", severity=\"error\")\n\n            self.push_screen(\n                PasteConfirmationModal(selected_pad, target_pad.sample.name),\n                handle_paste_confirm\n            )\n        else:\n            # Some other error\n            self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_delete_pad","title":"<code>action_delete_pad()</code>","text":"<p>Delete the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_delete_pad(self) -&gt; None:\n    \"\"\"Delete the selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Check if pad has a sample\n    pad = self.editor.get_pad(selected_pad)\n    if not pad.is_assigned or not pad.sample:\n        self.notify(\"Pad is already empty\", severity=\"warning\")\n        return\n\n    # Show confirmation modal\n    def handle_confirmation(confirmed: bool) -&gt; None:\n        if not confirmed:\n            return\n\n        try:\n            # Clear pad (events handle audio/UI sync automatically)\n            _ = self.editor.clear_pad(selected_pad)\n\n            self.notify(\"Pad deleted\")\n        except Exception as e:\n            logger.error(f\"Error deleting pad: {e}\")\n            self.notify(f\"Error: {e}\", severity=\"error\")\n\n    self.push_screen(\n        ClearConfirmationModal(selected_pad, pad.sample.name),\n        handle_confirmation\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_up","title":"<code>action_navigate_up()</code>","text":"<p>Navigate to pad above current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_up(self) -&gt; None:\n    \"\"\"Navigate to pad above current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"up\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_down","title":"<code>action_navigate_down()</code>","text":"<p>Navigate to pad below current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_down(self) -&gt; None:\n    \"\"\"Navigate to pad below current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"down\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_left","title":"<code>action_navigate_left()</code>","text":"<p>Navigate to pad left of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_left(self) -&gt; None:\n    \"\"\"Navigate to pad left of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"left\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_right","title":"<code>action_navigate_right()</code>","text":"<p>Navigate to pad right of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_right(self) -&gt; None:\n    \"\"\"Navigate to pad right of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"right\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_up","title":"<code>action_duplicate_up()</code>","text":"<p>Duplicate selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_up(self) -&gt; None:\n    \"\"\"Duplicate selected pad upward.\"\"\"\n    self._duplicate_directional(\"up\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_down","title":"<code>action_duplicate_down()</code>","text":"<p>Duplicate selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_down(self) -&gt; None:\n    \"\"\"Duplicate selected pad downward.\"\"\"\n    self._duplicate_directional(\"down\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_left","title":"<code>action_duplicate_left()</code>","text":"<p>Duplicate selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_left(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the left.\"\"\"\n    self._duplicate_directional(\"left\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_right","title":"<code>action_duplicate_right()</code>","text":"<p>Duplicate selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_right(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the right.\"\"\"\n    self._duplicate_directional(\"right\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_up","title":"<code>action_move_up()</code>","text":"<p>Move selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_up(self) -&gt; None:\n    \"\"\"Move selected pad upward.\"\"\"\n    self._move_directional(\"up\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_down","title":"<code>action_move_down()</code>","text":"<p>Move selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_down(self) -&gt; None:\n    \"\"\"Move selected pad downward.\"\"\"\n    self._move_directional(\"down\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_left","title":"<code>action_move_left()</code>","text":"<p>Move selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_left(self) -&gt; None:\n    \"\"\"Move selected pad to the left.\"\"\"\n    self._move_directional(\"left\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_right","title":"<code>action_move_right()</code>","text":"<p>Move selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_right(self) -&gt; None:\n    \"\"\"Move selected pad to the right.\"\"\"\n    self._move_directional(\"right\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_test_pad","title":"<code>action_test_pad()</code>","text":"<p>Test the selected pad (works in both modes).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_test_pad(self) -&gt; None:\n    \"\"\"Test the selected pad (works in both modes).\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if pad.is_assigned:\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_toggle_test","title":"<code>action_toggle_test()</code>","text":"<p>Toggle between test and stop for the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_toggle_test(self) -&gt; None:\n    \"\"\"Toggle between test and stop for the selected pad.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if not pad.is_assigned:\n        return\n\n    # Check if pad is currently playing\n    if self.player.is_pad_playing(self.selected_pad_index):\n        # Stop the pad - goes through queue and fires proper events\n        self.player.stop_pad(self.selected_pad_index)\n    else:\n        # Start the pad\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_stop_audio","title":"<code>action_stop_audio()</code>","text":"<p>Stop all audio playback.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_stop_audio(self) -&gt; None:\n    \"\"\"Stop all audio playback.\"\"\"\n    self.player.stop_all()\n\n    # Also release selected pad if in HOLD mode\n    if self.selected_pad_index is not None:\n        self.player.release_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_one_shot","title":"<code>action_set_mode_one_shot()</code>","text":"<p>Set selected pad to one-shot mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_one_shot(self) -&gt; None:\n    \"\"\"Set selected pad to one-shot mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.ONE_SHOT)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_loop","title":"<code>action_set_mode_loop()</code>","text":"<p>Set selected pad to loop mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop(self) -&gt; None:\n    \"\"\"Set selected pad to loop mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_hold","title":"<code>action_set_mode_hold()</code>","text":"<p>Set selected pad to hold mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_hold(self) -&gt; None:\n    \"\"\"Set selected pad to hold mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.HOLD)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_loop_toggle","title":"<code>action_set_mode_loop_toggle()</code>","text":"<p>Set selected pad to loop toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to loop toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP_TOGGLE)\n</code></pre>"},{"location":"api/tui/decorators/","title":"Decorators","text":""},{"location":"api/tui/decorators/#launchsampler.tui.decorators","title":"<code>decorators</code>","text":"<p>Decorators for TUI components.</p>"},{"location":"api/tui/decorators/#launchsampler.tui.decorators.require_mode","title":"<code>require_mode(*modes)</code>","text":"<p>Decorator to restrict action to specific sampler mode(s).</p> <p>Parameters:</p> Name Type Description Default <code>*modes</code> <p>One or more mode names (e.g., \"edit\", \"play\")</p> <code>()</code> <p>If the app is not in one of the specified modes, the decorated method will return immediately without executing.</p> Example <p>@require_mode(\"edit\") def action_copy_pad(self):     ...</p> <p>@require_mode(\"edit\", \"play\") def action_save(self):     ...</p> Source code in <code>src/launchsampler/tui/decorators.py</code> <pre><code>def require_mode(*modes):\n    \"\"\"Decorator to restrict action to specific sampler mode(s).\n\n    Args:\n        *modes: One or more mode names (e.g., \"edit\", \"play\")\n\n    If the app is not in one of the specified modes, the decorated\n    method will return immediately without executing.\n\n    Example:\n        @require_mode(\"edit\")\n        def action_copy_pad(self):\n            ...\n\n        @require_mode(\"edit\", \"play\")\n        def action_save(self):\n            ...\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._sampler_mode not in modes:\n                return\n            return func(self, *args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/tui/screens/base_browser/","title":"Base Browser","text":""},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser","title":"<code>base_browser</code>","text":"<p>Abstract base class for file/directory browser screens.</p>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.FilteredDirectoryTree","title":"<code>FilteredDirectoryTree</code>","text":"<p>               Bases: <code>DirectoryTree</code></p> <p>DirectoryTree that filters out hidden files and directories.</p>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.FilteredDirectoryTree.filter_paths","title":"<code>filter_paths(paths)</code>","text":"<p>Filter out hidden files and directories (those starting with a dot).</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Iterable[Path]</code> <p>Iterable of Path objects to filter</p> required <p>Returns:</p> Type Description <code>Iterable[Path]</code> <p>Filtered iterable of Path objects</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def filter_paths(self, paths: Iterable[Path]) -&gt; Iterable[Path]:\n    \"\"\"\n    Filter out hidden files and directories (those starting with a dot).\n\n    Args:\n        paths: Iterable of Path objects to filter\n\n    Returns:\n        Filtered iterable of Path objects\n    \"\"\"\n    return [path for path in paths if not path.name.startswith(\".\")]\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen","title":"<code>BaseBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>Screen</code></p> <p>Abstract base class for all file/directory browser screens.</p> <p>Provides common functionality for navigating directories, path input, keyboard shortcuts, and consistent styling. Subclasses implement specific selection logic and validation.</p> <p>Subclasses must implement: - _is_valid_selection(path): Validate if a path can be selected - _get_selection_value(): Get the value to return on dismiss - _get_title(): Return the screen title - _get_instructions(): Return usage instructions</p> <p>Initialize browser.</p> <p>Parameters:</p> Name Type Description Default <code>start_dir</code> <code>Path</code> <p>Directory to start browsing from</p> required Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_ignore","title":"<code>action_ignore()</code>","text":"<p>No-op action to disable parent bindings.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_ignore(self) -&gt; None:\n    \"\"\"No-op action to disable parent bindings.\"\"\"\n    pass\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.compose","title":"<code>compose()</code>","text":"<p>Create the browser layout.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the browser layout.\"\"\"\n    with Vertical():\n        yield Label(self._get_title(), id=\"title\")\n        yield FilteredDirectoryTree(str(self.start_dir), id=\"tree\")\n        yield Input(\n            value=str(self.start_dir),\n            placeholder=\"Enter or paste directory path...\",\n            id=\"path-input\"\n        )\n\n        # Allow subclasses to add extra widgets\n        extra_widgets = self._get_extra_widgets()\n        if extra_widgets:\n            with Container(id=\"extra-widgets\"):\n                for widget in extra_widgets:\n                    yield widget\n\n        yield Label(self._get_instructions(), id=\"instructions\")\n\n        with Horizontal(id=\"button-row\"):\n            for button in self._get_buttons():\n                yield button\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_directory_tree_directory_selected","title":"<code>on_directory_tree_directory_selected(event)</code>","text":"<p>Handle directory selection in tree.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_directory_tree_directory_selected(\n    self, event: DirectoryTree.DirectorySelected\n) -&gt; None:\n    \"\"\"Handle directory selection in tree.\"\"\"\n    self._on_tree_directory_selected(event)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_directory_tree_file_selected","title":"<code>on_directory_tree_file_selected(event)</code>","text":"<p>Handle file selection in tree.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_directory_tree_file_selected(\n    self, event: DirectoryTree.FileSelected\n) -&gt; None:\n    \"\"\"Handle file selection in tree.\"\"\"\n    self._on_tree_file_selected(event)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle path input submission (Enter key in input field).</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle path input submission (Enter key in input field).\"\"\"\n    if event.input.id == \"path-input\":\n        self._navigate_to_path(event.value)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_input_blurred","title":"<code>on_input_blurred(event)</code>","text":"<p>Handle input losing focus - navigate to the entered path.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_input_blurred(self, event: Input.Blurred) -&gt; None:\n    \"\"\"Handle input losing focus - navigate to the entered path.\"\"\"\n    if event.input.id == \"path-input\":\n        self._navigate_to_path(event.input.value)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"select-btn\":\n        self._confirm_selection()\n    elif event.button.id == \"cancel-btn\":\n        self.dismiss(None)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_select_current","title":"<code>action_select_current()</code>","text":"<p>Select the currently highlighted item.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_select_current(self) -&gt; None:\n    \"\"\"Select the currently highlighted item.\"\"\"\n    tree = self.query_one(\"#tree\", DirectoryTree)\n    if tree.cursor_node:\n        cursor_path = Path(str(tree.cursor_node.data.path))\n        self.selected_path = cursor_path\n        self._confirm_selection()\n    else:\n        # Fallback to selected_path if no cursor\n        self._confirm_selection()\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_cancel","title":"<code>action_cancel()</code>","text":"<p>Cancel and close the screen.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_cancel(self) -&gt; None:\n    \"\"\"Cancel and close the screen.\"\"\"\n    self.dismiss(None)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_key","title":"<code>on_key(event)</code>","text":"<p>Handle key presses - intercept enter for selection, left/right for navigation.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_key(self, event: events.Key) -&gt; None:\n    \"\"\"Handle key presses - intercept enter for selection, left/right for navigation.\"\"\"\n    if event.key == \"enter\":\n        event.prevent_default()\n        event.stop()\n        self.action_select_current()\n    elif event.key == \"right\":\n        # Expand the current node (step into folder)\n        tree = self.query_one(\"#tree\", DirectoryTree)\n        if tree.cursor_node and not tree.cursor_node.is_expanded:\n            tree.cursor_node.expand()\n            event.prevent_default()\n            event.stop()\n    elif event.key == \"left\":\n        # Collapse current node, go to parent, or navigate up past root\n        tree = self.query_one(\"#tree\", DirectoryTree)\n        if tree.cursor_node:\n            if tree.cursor_node.is_expanded:\n                # If expanded, collapse it\n                tree.cursor_node.collapse()\n                event.prevent_default()\n                event.stop()\n            elif tree.cursor_node.parent:\n                # If collapsed, move to parent\n                tree.select_node(tree.cursor_node.parent)\n                event.prevent_default()\n                event.stop()\n            else:\n                # We're at the root node, navigate up one directory level\n                current_path = Path(str(tree.cursor_node.data.path))\n                parent_path = current_path.parent\n                if parent_path != current_path:  # Make sure we're not at filesystem root\n                    self.run_worker(self._navigate_to_directory(parent_path))\n                    event.prevent_default()\n                    event.stop()\n</code></pre>"},{"location":"api/tui/screens/directory_browser/","title":"Directory Browser","text":""},{"location":"api/tui/screens/directory_browser/#launchsampler.tui.screens.directory_browser","title":"<code>directory_browser</code>","text":"<p>Directory browser screen for loading samples from a folder.</p>"},{"location":"api/tui/screens/directory_browser/#launchsampler.tui.screens.directory_browser.DirectoryBrowserScreen","title":"<code>DirectoryBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting directories containing samples.</p> <p>Displays a directory tree and allows selection of directories. User can select a directory by pressing Enter on it or using the \"Select\" button.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/file_browser/","title":"File Browser","text":""},{"location":"api/tui/screens/file_browser/#launchsampler.tui.screens.file_browser","title":"<code>file_browser</code>","text":"<p>File browser screen for selecting audio samples.</p>"},{"location":"api/tui/screens/file_browser/#launchsampler.tui.screens.file_browser.FileBrowserScreen","title":"<code>FileBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting audio sample files.</p> <p>Displays a directory tree and allows selection of audio files (.wav, .mp3, .flac, .ogg, .aiff). Automatically selects and dismisses when an audio file is chosen.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/","title":"Save Set Browser","text":""},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser","title":"<code>save_set_browser</code>","text":"<p>Save set browser screen for choosing save location and filename.</p>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen","title":"<code>SaveSetBrowserScreen(start_dir, default_name='untitled')</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for selecting save location and entering filename for sets.</p> <p>Displays a directory tree to choose location, with an input field for entering the set name. Returns a tuple of (directory, filename).</p> <p>Initialize save set browser.</p> <p>Parameters:</p> Name Type Description Default <code>start_dir</code> <code>Path</code> <p>Directory to start browsing from</p> required <code>default_name</code> <code>str</code> <p>Default name for the set</p> <code>'untitled'</code> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def __init__(self, start_dir: Path, default_name: str = \"untitled\") -&gt; None:\n    \"\"\"\n    Initialize save set browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n        default_name: Default name for the set\n    \"\"\"\n    super().__init__(start_dir)\n    self.default_name = default_name\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen.on_mount","title":"<code>on_mount()</code>","text":"<p>Focus the filename input when mounted.</p> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Focus the filename input when mounted.\"\"\"\n    # Give focus to the name input after a brief delay\n    # (need to wait for tree to be mounted first)\n    self.set_timer(0.1, self._focus_name_input)\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle input submission.</p> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle input submission.\"\"\"\n    if event.input.id == \"name-input\":\n        # Name input submitted - try to save\n        self._confirm_selection()\n    elif event.input.id == \"path-input\":\n        # Path input submitted - navigate\n        self._navigate_to_path(event.value)\n</code></pre>"},{"location":"api/tui/screens/set_file_browser/","title":"Set File Browser","text":""},{"location":"api/tui/screens/set_file_browser/#launchsampler.tui.screens.set_file_browser","title":"<code>set_file_browser</code>","text":"<p>Set file browser screen for loading saved sets.</p>"},{"location":"api/tui/screens/set_file_browser/#launchsampler.tui.screens.set_file_browser.SetFileBrowserScreen","title":"<code>SetFileBrowserScreen(set_manager, *args, **kwargs)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting saved set files (.json).</p> <p>Displays a directory tree and allows selection of set files. Shows metadata about sets when available. User can navigate anywhere on the filesystem to find set files.</p> <p>Initialize the set file browser.</p> <p>Parameters:</p> Name Type Description Default <code>set_manager</code> <code>SetManagerService</code> <p>Service for loading sets</p> required Source code in <code>src/launchsampler/tui/screens/set_file_browser.py</code> <pre><code>def __init__(self, set_manager: \"SetManagerService\", *args, **kwargs):\n    \"\"\"\n    Initialize the set file browser.\n\n    Args:\n        set_manager: Service for loading sets\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.set_manager = set_manager\n</code></pre>"},{"location":"api/tui/services/navigation_service/","title":"Navigation Service","text":""},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service","title":"<code>navigation_service</code>","text":"<p>Grid navigation service for directional pad operations.</p> <p>This service handles pure grid geometry logic for navigating the 8x8 Launchpad grid. It is UI-agnostic and can be reused by different UI implementations (TUI, LED UI, etc.).</p> <p>Responsibilities: - Calculate neighboring pad indices in cardinal directions (up, down, left, right) - Validate grid boundaries before navigation - Pure functions with no side effects</p> <p>Design Principles: - Single Responsibility: Only grid geometry, no UI or business logic - Testable: No dependencies on Textual or UI framework - Reusable: Can be used by TUI, LED UI, or any other UI implementation</p>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService","title":"<code>NavigationService(launchpad)</code>","text":"<p>Service for navigating the Launchpad 8x8 grid.</p> <p>This service provides pure functions for calculating neighboring pad indices in cardinal directions. It respects grid boundaries and returns None when attempting to navigate beyond the grid edge.</p> Example <p>nav = NavigationService(launchpad) nav.get_neighbor(0, \"right\")  # Pad 0 -&gt; Pad 1 1 nav.get_neighbor(0, \"down\")   # Pad 0 -&gt; None (at bottom edge) None nav.get_neighbor(63, \"up\")    # Pad 63 -&gt; None (at top edge) None</p> <p>Initialize the navigation service.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The Launchpad grid to navigate</p> required Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def __init__(self, launchpad: Launchpad):\n    \"\"\"\n    Initialize the navigation service.\n\n    Args:\n        launchpad: The Launchpad grid to navigate\n    \"\"\"\n    self.launchpad = launchpad\n    self._grid_size = launchpad.GRID_SIZE\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.get_neighbor","title":"<code>get_neighbor(pad_index, direction)</code>","text":"<p>Get the neighboring pad index in the given direction.</p> <p>Validates grid boundaries and returns None if the move would go beyond the grid edge. Uses the same coordinate system as the Launchpad: - X axis: left (0) to right (7) - Y axis: bottom (0) to top (7) - Index 0 is bottom-left, index 63 is top-right</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Current pad index (0-63)</p> required <code>direction</code> <code>Direction</code> <p>Direction to move (\"up\", \"down\", \"left\", \"right\")</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Target pad index, or None if at edge (cannot move in that direction)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pad_index is out of range (not 0-63)</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def get_neighbor(self, pad_index: int, direction: Direction) -&gt; Optional[int]:\n    \"\"\"\n    Get the neighboring pad index in the given direction.\n\n    Validates grid boundaries and returns None if the move would go beyond\n    the grid edge. Uses the same coordinate system as the Launchpad:\n    - X axis: left (0) to right (7)\n    - Y axis: bottom (0) to top (7)\n    - Index 0 is bottom-left, index 63 is top-right\n\n    Args:\n        pad_index: Current pad index (0-63)\n        direction: Direction to move (\"up\", \"down\", \"left\", \"right\")\n\n    Returns:\n        Target pad index, or None if at edge (cannot move in that direction)\n\n    Raises:\n        ValueError: If pad_index is out of range (not 0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; self.launchpad.TOTAL_PADS:\n        raise ValueError(f\"Pad index {pad_index} out of range (must be 0-63)\")\n\n    # Convert to grid coordinates\n    x, y = self.launchpad.note_to_xy(pad_index)\n\n    # Calculate new coordinates based on direction\n    # Check bounds BEFORE calculating target (fail fast)\n    if direction == \"up\":\n        if y &gt;= self._grid_size - 1:  # Already at top edge\n            return None\n        y = y + 1\n    elif direction == \"down\":\n        if y &lt;= 0:  # Already at bottom edge\n            return None\n        y = y - 1\n    elif direction == \"left\":\n        if x &lt;= 0:  # Already at left edge\n            return None\n        x = x - 1\n    elif direction == \"right\":\n        if x &gt;= self._grid_size - 1:  # Already at right edge\n            return None\n        x = x + 1\n    else:\n        logger.warning(f\"Invalid direction: {direction}\")\n        return None\n\n    # Convert back to pad index\n    return self.launchpad.xy_to_note(x, y)\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.can_move","title":"<code>can_move(pad_index, direction)</code>","text":"<p>Check if a move in the given direction is valid (not at edge).</p> <p>This is a convenience method that combines get_neighbor with a boolean check.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Current pad index (0-63)</p> required <code>direction</code> <code>Direction</code> <p>Direction to check (\"up\", \"down\", \"left\", \"right\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if move is valid, False if at edge or invalid input</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def can_move(self, pad_index: int, direction: Direction) -&gt; bool:\n    \"\"\"\n    Check if a move in the given direction is valid (not at edge).\n\n    This is a convenience method that combines get_neighbor with a boolean check.\n\n    Args:\n        pad_index: Current pad index (0-63)\n        direction: Direction to check (\"up\", \"down\", \"left\", \"right\")\n\n    Returns:\n        True if move is valid, False if at edge or invalid input\n    \"\"\"\n    try:\n        return self.get_neighbor(pad_index, direction) is not None\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.get_edge_position","title":"<code>get_edge_position(pad_index)</code>","text":"<p>Get which edges this pad is on.</p> <p>Useful for UI feedback (e.g., showing disabled directional arrows).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index to check (0-63)</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of edge names (e.g., {\"left\", \"bottom\"} for pad 0)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def get_edge_position(self, pad_index: int) -&gt; set[str]:\n    \"\"\"\n    Get which edges this pad is on.\n\n    Useful for UI feedback (e.g., showing disabled directional arrows).\n\n    Args:\n        pad_index: Pad index to check (0-63)\n\n    Returns:\n        Set of edge names (e.g., {\"left\", \"bottom\"} for pad 0)\n\n    Raises:\n        ValueError: If pad_index is out of range\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; self.launchpad.TOTAL_PADS:\n        raise ValueError(f\"Pad index {pad_index} out of range (must be 0-63)\")\n\n    x, y = self.launchpad.note_to_xy(pad_index)\n    edges = set()\n\n    if x == 0:\n        edges.add(\"left\")\n    if x == self._grid_size - 1:\n        edges.add(\"right\")\n    if y == 0:\n        edges.add(\"bottom\")\n    if y == self._grid_size - 1:\n        edges.add(\"top\")\n\n    return edges\n</code></pre>"},{"location":"api/tui/services/tui_service/","title":"Tui Service","text":""},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service","title":"<code>tui_service</code>","text":"<p>Service for managing TUI synchronization with application state.</p>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService","title":"<code>TUIService(app)</code>","text":"<p>               Bases: <code>AppObserver</code>, <code>EditObserver</code>, <code>SelectionObserver</code>, <code>MidiObserver</code>, <code>StateObserver</code></p> <p>Service for synchronizing the Terminal UI with application state.</p> <p>This service observes all system events and updates the TUI components (pad grid, details panel, status bar) accordingly. It decouples the application core from UI-specific update logic.</p> <p>Implements multiple observer protocols: - AppObserver: App lifecycle events (SET_MOUNTED, SET_SAVED, etc.) - EditObserver: Editing events (PAD_ASSIGNED, PAD_CLEARED, etc.) - SelectionObserver: Selection events (CHANGED, CLEARED) - UI state only - MidiObserver: MIDI controller events (NOTE_ON, NOTE_OFF, etc.) - StateObserver: Playback events (PAD_PLAYING, PAD_STOPPED, etc.)</p> <p>Initialize the TUI service.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>LaunchpadSampler</code> <p>The LaunchpadSampler application instance</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def __init__(self, app: \"LaunchpadSampler\"):\n    \"\"\"\n    Initialize the TUI service.\n\n    Args:\n        app: The LaunchpadSampler application instance\n    \"\"\"\n    self.app = app\n    logger.info(\"TUIService initialized\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data</p> <code>{}</code> Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_app_event(self, event: AppEvent, **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data\n    \"\"\"\n    try:\n        if event == AppEvent.SET_MOUNTED:\n            self._handle_set_mounted()\n        elif event == AppEvent.SET_SAVED:\n            self._handle_set_saved(**kwargs)\n        elif event == AppEvent.MODE_CHANGED:\n            logger.info(f\"TUIService handling MODE_CHANGED event: {kwargs}\")\n            self._handle_mode_changed(**kwargs)\n        else:\n            logger.warning(f\"TUIService received unknown app event: {event}\")\n\n    except Exception as e:\n        logger.error(f\"Error handling app event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and update UI.</p> <p>This is called from the UI thread when editing operations occur. Automatically synchronizes the UI with the new pad states.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events and update UI.\n\n    This is called from the UI thread when editing operations occur.\n    Automatically synchronizes the UI with the new pad states.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    logger.debug(f\"TUIService received edit event: {event.value} for pads {pad_indices}\")\n\n    try:\n        # Update content - refresh grid and details if currently selected\n        for pad_index, pad in zip(pad_indices, pads):\n            self._update_pad_ui(pad_index, pad)\n\n    except Exception as e:\n        logger.error(f\"Error handling edit event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_selection_event","title":"<code>on_selection_event(event, pad_index)</code>","text":"<p>Handle selection change events.</p> <p>This is the NEW way to handle selection (replaces EditEvent.PAD_SELECTED). Selection is UI state that doesn't affect persistence or audio.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>SelectionEvent</code> <p>The type of selection event</p> required <code>pad_index</code> <code>Optional[int]</code> <p>Index of selected pad (0-63), or None if cleared</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_selection_event(\n    self,\n    event: \"SelectionEvent\",\n    pad_index: Optional[int]\n) -&gt; None:\n    \"\"\"\n    Handle selection change events.\n\n    This is the NEW way to handle selection (replaces EditEvent.PAD_SELECTED).\n    Selection is UI state that doesn't affect persistence or audio.\n\n    Args:\n        event: The type of selection event\n        pad_index: Index of selected pad (0-63), or None if cleared\n    \"\"\"\n    logger.info(f\"TUIService received selection event: {event.value}, pad: {pad_index}\")\n\n    try:\n        if event == SelectionEvent.CHANGED and pad_index is not None:\n            # Pad selected - update UI\n            pad = self.app.editor.get_pad(pad_index)\n            self._update_selected_pad_ui(pad_index, pad)\n        elif event == SelectionEvent.CLEARED:\n            # Selection cleared - update UI\n            grid = self.app.query_one(PadGrid)\n            grid.clear_selection()\n\n    except Exception as e:\n        logger.error(f\"Error handling selection event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>Called from MIDI thread via LaunchpadController, so use call_from_thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    Called from MIDI thread via LaunchpadController, so use call_from_thread.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    logger.info(f\"TUI received MIDI event: {event}, pad_index: {pad_index}\")\n\n    if event == MidiEvent.NOTE_ON:\n        # MIDI note on - show green border\n        self.app.call_from_thread(self._set_pad_midi_on_ui, pad_index, True)\n\n    elif event == MidiEvent.NOTE_OFF:\n        # MIDI note off - remove green border\n        self.app.call_from_thread(self._set_pad_midi_on_ui, pad_index, False)\n\n    elif event in (MidiEvent.CONTROLLER_CONNECTED, MidiEvent.CONTROLLER_DISCONNECTED):\n        # MIDI controller connection changed - update status bar\n        self.app.call_from_thread(self._update_status_bar)\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>Called from audio thread via callback, so use call_from_thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The playback event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63)</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    Called from audio thread via callback, so use call_from_thread.\n\n    Args:\n        event: The playback event that occurred\n        pad_index: Index of the pad (0-63)\n    \"\"\"\n    # Handle audio playback events (yellow background)\n    if event == PlaybackEvent.PAD_PLAYING:\n        # Pad started playing - show as active\n        self.app.call_from_thread(self._set_pad_playing_ui, pad_index, True)\n        # Update status bar for voice count\n        self.app.call_from_thread(self._update_status_bar)\n\n    elif event in (PlaybackEvent.PAD_STOPPED, PlaybackEvent.PAD_FINISHED):\n        # Pad stopped or finished - show as inactive\n        self.app.call_from_thread(self._set_pad_playing_ui, pad_index, False)\n        # Update status bar for voice count\n        self.app.call_from_thread(self._update_status_bar)\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/","title":"Clear Confirmation Modal","text":""},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal","title":"<code>clear_confirmation_modal</code>","text":"<p>Modal dialog for confirming pad clear operations.</p>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal","title":"<code>ClearConfirmationModal(pad_index, sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[bool]</code></p> <p>Modal dialog asking user to confirm clearing a pad.</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <code>sample_name</code> <code>str</code> <p>Name of sample to clear</p> required Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def __init__(self, pad_index: int, sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        pad_index: Index of pad to clear\n        sample_name: Name of sample to clear\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.sample_name = sample_name\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Delete pad {self.pad_index}?\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.sample_name}\"',\n            id=\"details\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Delete\", variant=\"error\", id=\"clear-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"clear-btn\":\n        event.stop()\n        self.dismiss(True)\n    elif event.button.id == \"cancel-btn\":\n        event.stop()\n        self.dismiss(False)\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/","title":"Move Confirmation Modal","text":""},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal","title":"<code>move_confirmation_modal</code>","text":"<p>Modal dialog for confirming pad move operations.</p>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal","title":"<code>MoveConfirmationModal(source_index, target_index, target_sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[str]</code></p> <p>Modal dialog asking user to choose between overwrite or swap.</p> <p>User is presented with two options when moving a sample to an occupied pad: - Overwrite: Replace target sample (source pad becomes empty) - Swap: Exchange samples between source and target pads</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>target_sample_name</code> <code>str</code> <p>Name of sample in target pad</p> required Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def __init__(self, source_index: int, target_index: int, target_sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        target_sample_name: Name of sample in target pad\n    \"\"\"\n    super().__init__()\n    self.source_index = source_index\n    self.target_index = target_index\n    self.target_sample_name = target_sample_name\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Pad {self.target_index} already has a sample\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.target_sample_name}\"',\n            id=\"details\"\n        )\n        yield Label(\n            \"Choose an action:\",\n            id=\"action-prompt\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Swap\", variant=\"success\", id=\"swap-btn\")\n            yield Button(\"Overwrite\", variant=\"error\", id=\"overwrite-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"overwrite-btn\":\n        event.stop()\n        self.dismiss(\"overwrite\")\n    elif event.button.id == \"swap-btn\":\n        event.stop()\n        self.dismiss(\"swap\")\n    elif event.button.id == \"cancel-btn\":\n        event.stop()\n        self.dismiss(\"cancel\")\n</code></pre>"},{"location":"api/tui/widgets/pad_details/","title":"Pad Details","text":""},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details","title":"<code>pad_details</code>","text":"<p>Details panel showing information and controls for selected pad.</p>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.NoTabInput","title":"<code>NoTabInput(*args, **kwargs)</code>","text":"<p>               Bases: <code>Input</code></p> <p>Input that doesn't move focus to next field on Enter.</p> <p>Initialize with submit tracking.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize with submit tracking.\"\"\"\n    super().__init__(*args, **kwargs)\n    self._just_submitted = False\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.NoTabInput.action_submit","title":"<code>action_submit()</code>","text":"<p>Override submit action to prevent focus moving to next field.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def action_submit(self) -&gt; None:\n    \"\"\"Override submit action to prevent focus moving to next field.\"\"\"\n    # Run validators and post submitted message\n    self.validate(self.value)\n    self.post_message(self.Submitted(self, self.value))\n    # Set flag to prevent duplicate submission on blur\n    self._just_submitted = True\n    # Focus the grandparent (PadDetailsPanel) to remove focus from input\n    # Structure: PadDetailsPanel &gt; Horizontal &gt; NoTabInput\n    if self.parent and self.parent.parent:\n        self.parent.parent.focus()\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel","title":"<code>PadDetailsPanel()</code>","text":"<p>               Bases: <code>Vertical</code></p> <p>Panel showing details and controls for the selected pad.</p> <p>Displays pad information (index, sample, mode, volume) and provides buttons for editing. Can be set to edit or play mode to disable/enable controls appropriately.</p> <p>Initialize details panel.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize details panel.\"\"\"\n    super().__init__()\n    self.selected_pad_index: Optional[int] = None\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.VolumeChanged","title":"<code>VolumeChanged(pad_index, volume)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when volume is changed.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0 - 1.0)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        volume: New volume (0.0 - 1.0)\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.volume = volume\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.NameChanged","title":"<code>NameChanged(pad_index, name)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when sample name is changed.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>name</code> <code>str</code> <p>New sample name</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, pad_index: int, name: str) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        name: New sample name\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.name = name\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.MovePadRequested","title":"<code>MovePadRequested(source_index, target_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when user requests to move pad to another location.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad (0-63)</p> required <code>target_index</code> <code>int</code> <p>Index of target pad (0-63)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, source_index: int, target_index: int) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        source_index: Index of source pad (0-63)\n        target_index: Index of target pad (0-63)\n    \"\"\"\n    super().__init__()\n    self.source_index = source_index\n    self.target_index = target_index\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.compose","title":"<code>compose()</code>","text":"<p>Create the details panel widgets.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the details panel widgets.\"\"\"\n    with Horizontal(classes=\"pad-header\"):\n        yield Label(\"No pad selected\", id=\"pad-info\")\n        yield Label(\"\", id=\"pad-location\")\n\n    with Horizontal(classes=\"move-container\"):\n        yield Label(\"Move to:\", shrink=True)\n        yield NoTabInput(placeholder=\"0-63\", id=\"move-input\", disabled=True)\n\n    yield Rule()\n\n    with Horizontal(classes=\"name-container\"):\n        yield Label(\"Name:\", shrink=True)\n        yield NoTabInput(placeholder=\"Sample name\", id=\"name-input\", disabled=True)\n\n    with Horizontal(classes=\"volume-container\"):\n        yield Label(\"Volume [%]:\", shrink=True)\n        yield NoTabInput(placeholder=\"0-100\", id=\"volume-input\", type=\"integer\", disabled=True)\n\n    with RadioSet(id=\"mode-radio\"):\n        yield RadioButton(\"\\\\[1] One Shot\", id=\"mode-oneshot\", disabled=True)\n        yield RadioButton(\"\\\\[2] Hold\", id=\"mode-hold\", disabled=True)\n        yield RadioButton(\"\\\\[3] Loop\", id=\"mode-loop\", disabled=True)\n        yield RadioButton(\"\\\\[4] Loop Toggle\", id=\"mode-looptoggle\", disabled=True)\n\n    yield Rule()\n    with Grid(classes=\"button-grid\"):\n        yield Button(\"[\u25aa] Browse\", id=\"browse-btn\", variant=\"primary\", disabled=True)\n        yield Button(\"\\\\[X] Delete\", id=\"clear-btn\", variant=\"default\", disabled=True)\n\n    yield Rule()\n    yield Label(\"\", id=\"sample-info\") # gets updated by update_for_pad\n\n    with Grid(classes=\"control-buttons\"):\n        yield Button(\"\u25b6\", id=\"test-btn\", variant=\"success\", disabled=True)\n        yield Button(\"\u25a0\", id=\"stop-btn\", variant=\"error\", disabled=True)\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.update_for_pad","title":"<code>update_for_pad(pad_index, pad, audio_data=None)</code>","text":"<p>Update the panel to show info for selected pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of selected pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model instance</p> required <code>audio_data</code> <code>Optional[AudioData]</code> <p>Optional AudioData object for the loaded sample</p> <code>None</code> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def update_for_pad(self, pad_index: int, pad: Pad, audio_data: Optional[AudioData] = None) -&gt; None:\n    \"\"\"\n    Update the panel to show info for selected pad.\n\n    Args:\n        pad_index: Index of selected pad (0-63)\n        pad: Pad model instance\n        audio_data: Optional AudioData object for the loaded sample\n    \"\"\"\n    self.selected_pad_index = pad_index\n\n    # Update pad info labels\n    pad_info = self.query_one(\"#pad-info\", Label)\n    pad_info.update(f\"[b]Pad {pad_index}[/b]\")\n\n    pad_location = self.query_one(\"#pad-location\", Label)\n    pad_location.update(f\"[{pad_index % 8}, {pad_index // 8}]\")\n\n    # Update sample info\n    sample_info = self.query_one(\"#sample-info\", Label)\n    if pad.is_assigned and pad.sample:\n        # Build audio info string if audio data available\n        audio_info_str = \"\"\n        if audio_data is not None:\n            audio_info_str = f\"\\nDuration: {audio_data.duration:.2f}s\"\n            audio_info_str += f\"\\nSample Rate: {audio_data.sample_rate} Hz\"\n            audio_info_str += f\"\\nChannels: {audio_data.num_channels}\"\n\n            # Add format info if available\n            if audio_data.format:\n                audio_info_str += f\"\\nFormat: {audio_data.format}\"\n                if audio_data.subtype:\n                    audio_info_str += f\" ({audio_data.subtype})\"\n\n            # Add file size\n            info = audio_data.get_info()\n            audio_info_str += f\"\\nSize: {info['size_str']}\"\n        else:\n            audio_info_str = \"\\n[b]\u26a0\ufe0f File not found[/b]\"\n\n        sample_info.update(\n            f\"Path: {pad.sample.path}\"\n            f\"{audio_info_str}\"\n        )\n    else:\n        sample_info.update(\"[dim]No sample assigned[/dim]\")\n\n    # Update name input\n    name_input = self.query_one(\"#name-input\", Input)\n    if pad.is_assigned and pad.sample:\n        name_input.value = pad.sample.name\n    else:\n        name_input.value = \"\"\n\n    # Update volume input\n    volume_input = self.query_one(\"#volume-input\", Input)\n    if pad.is_assigned:\n        volume_input.value = str(int(pad.volume * 100))\n    else:\n        volume_input.value = \"\"\n\n    # Clear move input\n    move_input = self.query_one(\"#move-input\", Input)\n    move_input.value = \"\"\n\n    # Update button states based on pad and mode\n    self._update_button_states(pad)\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle input submissions.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle input submissions.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    if event.input.id == \"name-input\":\n        # Update sample name\n        name = event.value.strip()\n        if name:  # Only update if not empty\n            self.post_message(self.NameChanged(self.selected_pad_index, name))\n\n    elif event.input.id == \"volume-input\":\n        try:\n            # Parse volume as percentage (0-100)\n            volume_percent = int(event.value)\n            if 0 &lt;= volume_percent &lt;= 100:\n                volume = volume_percent / 100.0\n                # Post message for parent to handle\n                self.post_message(self.VolumeChanged(self.selected_pad_index, volume))\n        except ValueError:\n            # Invalid input, keep current value\n            pass\n\n    elif event.input.id == \"move-input\":\n        try:\n            # Parse target pad index (0-63)\n            target_index = int(event.value)\n            if 0 &lt;= target_index &lt;= 63:\n                # Post message for parent to handle\n                self.post_message(self.MovePadRequested(self.selected_pad_index, target_index))\n                # Clear the input after submission\n                event.input.value = \"\"\n            else:\n                # Out of range, clear it\n                event.input.value = \"\"\n        except ValueError:\n            # Invalid input, clear it\n            event.input.value = \"\"\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/","title":"Pad Grid","text":""},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid","title":"<code>pad_grid</code>","text":"<p>Grid widget containing 8x8 pad widgets.</p>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid","title":"<code>PadGrid()</code>","text":"<p>               Bases: <code>Container</code></p> <p>8x8 grid of pad widgets (layout container).</p> <p>Arranges 64 pad widgets in an 8x8 grid layout, matching the physical Launchpad layout. Handles pad selection visualization and forwards selection events to parent.</p> <p>This widget is stateless - it doesn't store the launchpad model. Pad data is passed explicitly when needed (data-driven approach).</p> <p>Initialize empty pad grid.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty pad grid.\"\"\"\n    super().__init__()\n    # Map pad_index to widget\n    self.pad_widgets: dict[int, PadWidget] = {}\n    self._initialized = False\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.PadSelected","title":"<code>PadSelected(pad_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message posted when any pad is selected.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def __init__(self, pad_index: int):\n    super().__init__()\n    self.pad_index = pad_index\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.compose","title":"<code>compose()</code>","text":"<p>Create empty grid structure.</p> <p>Actual pad widgets are created later via initialize_pads() after the launchpad data is available.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Create empty grid structure.\n\n    Actual pad widgets are created later via initialize_pads()\n    after the launchpad data is available.\n    \"\"\"\n    # Return empty - will be populated via initialize_pads()\n    return []\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.initialize_pads","title":"<code>initialize_pads(launchpad)</code>","text":"<p>Initialize the grid with pad widgets from launchpad data.</p> <p>This is called after the widget is mounted and launchpad data is available.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>Launchpad model containing all pad data</p> required <p>Launchpad layout: (0,0) is bottom-left, (7,7) is top-right Grid layout: top-left to bottom-right So we flip vertically: iterate from row 7 down to row 0</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def initialize_pads(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Initialize the grid with pad widgets from launchpad data.\n\n    This is called after the widget is mounted and launchpad data\n    is available.\n\n    Args:\n        launchpad: Launchpad model containing all pad data\n\n    Launchpad layout: (0,0) is bottom-left, (7,7) is top-right\n    Grid layout: top-left to bottom-right\n    So we flip vertically: iterate from row 7 down to row 0\n    \"\"\"\n    if self._initialized:\n        # Clear existing widgets\n        for widget in self.pad_widgets.values():\n            widget.remove()\n        self.pad_widgets.clear()\n\n    # Iterate rows from 7 (top) to 0 (bottom)\n    for y in range(7, -1, -1):\n        # Iterate columns from 0 (left) to 7 (right)\n        for x in range(8):\n            # Calculate pad index: row * 8 + col\n            i = y * 8 + x\n            pad = launchpad.pads[i]\n            widget = PadWidget(i, pad)\n\n            # Store widget by pad_index\n            self.pad_widgets[i] = widget\n            self.mount(widget)\n\n    self._initialized = True\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.update_pad","title":"<code>update_pad(pad_index, pad)</code>","text":"<p>Update a specific pad's display.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to update (0-63)</p> required <code>pad</code> <code>Pad</code> <p>New pad state (explicitly passed)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def update_pad(self, pad_index: int, pad: Pad) -&gt; None:\n    \"\"\"\n    Update a specific pad's display.\n\n    Args:\n        pad_index: Index of pad to update (0-63)\n        pad: New pad state (explicitly passed)\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].update(pad)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Visually mark a pad as selected.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Visually mark a pad as selected.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    # Deselect all pads\n    for widget in self.pad_widgets.values():\n        widget.remove_class(\"selected\")\n\n    # Select target pad\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].add_class(\"selected\")\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.clear_selection","title":"<code>clear_selection()</code>","text":"<p>Clear selection from all pads.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def clear_selection(self) -&gt; None:\n    \"\"\"Clear selection from all pads.\"\"\"\n    for widget in self.pad_widgets.values():\n        widget.remove_class(\"selected\")\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.set_pad_playing","title":"<code>set_pad_playing(pad_index, is_playing)</code>","text":"<p>Set the playing state of a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def set_pad_playing(self, pad_index: int, is_playing: bool) -&gt; None:\n    \"\"\"\n    Set the playing state of a pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        is_playing: Whether the pad is currently playing\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].set_playing(is_playing)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.set_pad_midi_on","title":"<code>set_pad_midi_on(pad_index, midi_on)</code>","text":"<p>Set the MIDI note on/off state of a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>midi_on</code> <code>bool</code> <p>Whether a MIDI note on is held for this pad</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def set_pad_midi_on(self, pad_index: int, midi_on: bool) -&gt; None:\n    \"\"\"\n    Set the MIDI note on/off state of a pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        midi_on: Whether a MIDI note on is held for this pad\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].set_midi_on(midi_on)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.on_pad_widget_selected","title":"<code>on_pad_widget_selected(message)</code>","text":"<p>Handle pad selection from child widgets.</p> <p>Forwards the selection event up to parent container.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def on_pad_widget_selected(self, message: PadWidget.Selected) -&gt; None:\n    \"\"\"\n    Handle pad selection from child widgets.\n\n    Forwards the selection event up to parent container.\n    \"\"\"\n    # Don't consume the message, let it bubble up\n    message.stop()\n\n    # Post our own message for parent\n    self.post_message(self.PadSelected(message.pad_index))\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/","title":"Pad Widget","text":""},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget","title":"<code>pad_widget</code>","text":"<p>Widget representing a single pad in the grid.</p>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget","title":"<code>PadWidget(pad_index, pad)</code>","text":"<p>               Bases: <code>Static</code></p> <p>Widget representing a single pad (presentation only).</p> <p>Displays pad index, sample name, and applies CSS classes based on playback mode. Posts messages when clicked, allowing parent containers to handle selection logic.</p> <p>Initialize pad widget.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of this pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model instance</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def __init__(self, pad_index: int, pad: Pad) -&gt; None:\n    \"\"\"\n    Initialize pad widget.\n\n    Args:\n        pad_index: Index of this pad (0-63)\n        pad: Pad model instance\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self._pad = pad\n    self._is_playing = False\n    self._midi_on = False\n    self.update_display()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.Selected","title":"<code>Selected(pad_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message posted when pad is clicked.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def __init__(self, pad_index: int):\n    super().__init__()\n    self.pad_index = pad_index\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.update","title":"<code>update(pad)</code>","text":"<p>Update display with new pad state.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>Pad</code> <p>New pad state</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def update(self, pad: Pad) -&gt; None:\n    \"\"\"\n    Update display with new pad state.\n\n    Args:\n        pad: New pad state\n    \"\"\"\n    self._pad = pad\n    self.update_display()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.update_display","title":"<code>update_display()</code>","text":"<p>Render current pad state.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def update_display(self) -&gt; None:\n    \"\"\"Render current pad state.\"\"\"\n    # Clear mode classes\n    self.remove_class(\"one_shot\", \"loop\", \"hold\", \"loop_toggle\", \"empty\")\n\n    if self._pad.is_assigned:\n        # Show pad index and truncated sample name\n        name = self._pad.sample.name if self._pad.sample else \"???\"\n        super().update(f\"[b]{self.pad_index}[/b]\\n{name}\")\n\n        # Add mode class for styling (from centralized colors)\n        self.add_class(self._pad.mode.value)\n    else:\n        # Empty pad\n        super().update(f\"[dim]{self.pad_index}[/dim]\\n\u2014\")\n        self.add_class(\"empty\")\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.set_playing","title":"<code>set_playing(is_playing)</code>","text":"<p>Set the playing state of this pad.</p> <p>Parameters:</p> Name Type Description Default <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def set_playing(self, is_playing: bool) -&gt; None:\n    \"\"\"\n    Set the playing state of this pad.\n\n    Args:\n        is_playing: Whether the pad is currently playing audio\n    \"\"\"\n    if is_playing != self._is_playing:\n        self._is_playing = is_playing\n        if is_playing:\n            self.add_class(\"active\")\n        else:\n            self.remove_class(\"active\")\n        self.refresh()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.set_midi_on","title":"<code>set_midi_on(midi_on)</code>","text":"<p>Set the MIDI note on/off state of this pad.</p> <p>Parameters:</p> Name Type Description Default <code>midi_on</code> <code>bool</code> <p>Whether a MIDI note on is currently held for this pad</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def set_midi_on(self, midi_on: bool) -&gt; None:\n    \"\"\"\n    Set the MIDI note on/off state of this pad.\n\n    Args:\n        midi_on: Whether a MIDI note on is currently held for this pad\n    \"\"\"\n    if midi_on != self._midi_on:\n        self._midi_on = midi_on\n        if midi_on:\n            self.add_class(\"midi_on\")\n        else:\n            self.remove_class(\"midi_on\")\n        self.refresh()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.on_click","title":"<code>on_click()</code>","text":"<p>Handle click event - post message for parent to handle.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def on_click(self) -&gt; None:\n    \"\"\"Handle click event - post message for parent to handle.\"\"\"\n    self.post_message(self.Selected(self.pad_index))\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/","title":"Paste Confirmation Modal","text":""},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal","title":"<code>paste_confirmation_modal</code>","text":"<p>Modal dialog for confirming paste operations.</p>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal","title":"<code>PasteConfirmationModal(target_index, current_sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[bool]</code></p> <p>Modal dialog asking user to confirm overwriting a pad on paste.</p> <p>User is presented with two options when pasting to an occupied pad: - Overwrite: Replace target sample with clipboard contents - Cancel: Abort the paste operation</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>current_sample_name</code> <code>str</code> <p>Name of sample currently in target pad</p> required Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def __init__(self, target_index: int, current_sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        target_index: Index of target pad\n        current_sample_name: Name of sample currently in target pad\n    \"\"\"\n    super().__init__()\n    self.target_index = target_index\n    self.current_sample_name = current_sample_name\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Pad {self.target_index} already has a sample\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.current_sample_name}\"',\n            id=\"details\"\n        )\n        yield Label(\n            \"Overwrite with clipboard contents?\",\n            id=\"action-prompt\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Overwrite\", variant=\"error\", id=\"overwrite-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"overwrite-btn\":\n        self.dismiss(True)\n    elif event.button.id == \"cancel-btn\":\n        self.dismiss(False)\n</code></pre>"},{"location":"api/tui/widgets/status_bar/","title":"Status Bar","text":""},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar","title":"<code>status_bar</code>","text":"<p>Status bar widget showing mode, MIDI status, and active voices.</p>"},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar.StatusBar","title":"<code>StatusBar()</code>","text":"<p>               Bases: <code>Static</code></p> <p>Status bar displaying current application state.</p> <p>Shows: - Current mode (Edit or Play) - MIDI connection status - Active voice count</p> <p>Initialize status bar.</p> Source code in <code>src/launchsampler/tui/widgets/status_bar.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize status bar.\"\"\"\n    super().__init__()\n    self._mode = \"edit\"\n    self._connected = False\n    self._voices = 0\n    self._audio_device = \"No Audio\"\n    self._midi_device = \"No MIDI\"\n    self._update_display()\n</code></pre>"},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar.StatusBar.update_state","title":"<code>update_state(mode, connected, voices, audio_device='Unknown', midi_device='No Device')</code>","text":"<p>Update all status information.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Current mode (\"edit\" or \"play\")</p> required <code>connected</code> <code>bool</code> <p>Whether MIDI is connected</p> required <code>voices</code> <code>int</code> <p>Number of active voices</p> required <code>audio_device</code> <code>str</code> <p>Name of the audio device</p> <code>'Unknown'</code> <code>midi_device</code> <code>str</code> <p>Name of the MIDI device</p> <code>'No Device'</code> Source code in <code>src/launchsampler/tui/widgets/status_bar.py</code> <pre><code>def update_state(\n    self,\n    mode: str,\n    connected: bool,\n    voices: int,\n    audio_device: str = \"Unknown\",\n    midi_device: str = \"No Device\"\n) -&gt; None:\n    \"\"\"\n    Update all status information.\n\n    Args:\n        mode: Current mode (\"edit\" or \"play\")\n        connected: Whether MIDI is connected\n        voices: Number of active voices\n        audio_device: Name of the audio device\n        midi_device: Name of the MIDI device\n    \"\"\"\n    self._mode = mode\n    self._connected = connected\n    self._voices = voices\n    self._audio_device = audio_device\n    self._midi_device = midi_device\n    self._update_display()\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":"<p>Utility functions and helper classes</p>"},{"location":"api/utils/#launchsampler.utils","title":"<code>utils</code>","text":"<p>Utility modules for launchsampler.</p>"},{"location":"api/utils/#launchsampler.utils.ObserverManager","title":"<code>ObserverManager(lock=None, observer_type_name='observer')</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic observer list manager with thread-safe registration and notification.</p> <p>This class provides a reusable implementation of the observer pattern, eliminating code duplication across EditorService, Player, LaunchpadController, SamplerStateMachine, and other classes.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>The observer protocol type (e.g., EditObserver, StateObserver)</p> required Thread Safety <p>All operations are thread-safe. The lock is released before calling observer callbacks to prevent potential deadlocks.</p> Example <pre><code>class MyService:\n    def __init__(self):\n        self._observers = ObserverManager[MyObserver]()\n\n    def register_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.register(observer)\n\n    def unregister_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.unregister(observer)\n\n    def _notify_something_happened(self, data):\n        self._observers.notify('on_something_happened', data)\n</code></pre> <p>Initialize the observer manager.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Optional[Lock]</code> <p>Optional threading lock to use. If None, creates a new lock.</p> <code>None</code> <code>observer_type_name</code> <code>str</code> <p>Name of the observer type for logging (e.g., \"edit\", \"state\")</p> <code>'observer'</code> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __init__(self, lock: Optional[Lock] = None, observer_type_name: str = \"observer\"):\n    \"\"\"\n    Initialize the observer manager.\n\n    Args:\n        lock: Optional threading lock to use. If None, creates a new lock.\n        observer_type_name: Name of the observer type for logging (e.g., \"edit\", \"state\")\n    \"\"\"\n    self._observers: list[T] = []\n    self._lock = lock or Lock()\n    self._observer_type_name = observer_type_name\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.register","title":"<code>register(observer)</code>","text":"<p>Register an observer (idempotent - won't add duplicates).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to register</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def register(self, observer: T) -&gt; None:\n    \"\"\"\n    Register an observer (idempotent - won't add duplicates).\n\n    Args:\n        observer: The observer to register\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer not in self._observers:\n            self._observers.append(observer)\n            logger.info(f\"Registered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.debug(f\"{self._observer_type_name} observer already registered: {observer}\")\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.unregister","title":"<code>unregister(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to unregister</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def unregister(self, observer: T) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer in self._observers:\n            self._observers.remove(observer)\n            logger.debug(f\"Unregistered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.warning(f\"Attempted to unregister unknown {self._observer_type_name} observer: {observer}\")\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.notify","title":"<code>notify(callback_name, *args, **kwargs)</code>","text":"<p>Notify all observers by calling their callback method.</p> <p>The lock is acquired to copy the observer list, then released before calling callbacks. This prevents deadlocks if observers try to register/ unregister during notification.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call (e.g., 'on_edit_event')</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Error Handling <p>Exceptions in observer callbacks are logged but don't affect other observers.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def notify(self, callback_name: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notify all observers by calling their callback method.\n\n    The lock is acquired to copy the observer list, then released before\n    calling callbacks. This prevents deadlocks if observers try to register/\n    unregister during notification.\n\n    Args:\n        callback_name: Name of the callback method to call (e.g., 'on_edit_event')\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Error Handling:\n        Exceptions in observer callbacks are logged but don't affect other observers.\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = list(self._observers)\n\n    # Call observers without holding lock (prevents deadlocks)\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.notify_with_filter","title":"<code>notify_with_filter(callback_name, filter_fn, *args, **kwargs)</code>","text":"<p>Notify only observers that match the filter predicate.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call</p> required <code>filter_fn</code> <code>Callable[[T], bool]</code> <p>Predicate function that returns True for observers to notify</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Example <pre><code># Only notify observers that implement a specific interface\nself._observers.notify_with_filter(\n    'on_custom_event',\n    lambda obs: hasattr(obs, 'supports_custom_events'),\n    event_data\n)\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def notify_with_filter(\n    self,\n    callback_name: str,\n    filter_fn: Callable[[T], bool],\n    *args: Any,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Notify only observers that match the filter predicate.\n\n    Args:\n        callback_name: Name of the callback method to call\n        filter_fn: Predicate function that returns True for observers to notify\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Example:\n        ```python\n        # Only notify observers that implement a specific interface\n        self._observers.notify_with_filter(\n            'on_custom_event',\n            lambda obs: hasattr(obs, 'supports_custom_events'),\n            event_data\n        )\n        ```\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = [obs for obs in self._observers if filter_fn(obs)]\n\n    # Call filtered observers without holding lock\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.count","title":"<code>count()</code>","text":"<p>Get the number of registered observers.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers.\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.has_observers","title":"<code>has_observers()</code>","text":"<p>Check if any observers are registered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def has_observers(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered.\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.clear","title":"<code>clear()</code>","text":"<p>Remove all registered observers.</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Remove all registered observers.\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        count = len(self._observers)\n        self._observers.clear()\n        if count &gt; 0:\n            logger.info(f\"Cleared {count} {self._observer_type_name} observer(s)\")\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.__contains__","title":"<code>__contains__(observer)</code>","text":"<p>Check if an observer is registered (supports 'in' operator).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to check for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if my_observer in observer_manager:\n    print(\"Observer is registered\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __contains__(self, observer: T) -&gt; bool:\n    \"\"\"\n    Check if an observer is registered (supports 'in' operator).\n\n    Args:\n        observer: The observer to check for\n\n    Returns:\n        True if observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if my_observer in observer_manager:\n            print(\"Observer is registered\")\n        ```\n    \"\"\"\n    with self._lock:\n        return observer in self._observers\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of registered observers (supports len() function).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>print(f\"There are {len(observer_manager)} observers\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers (supports len() function).\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        print(f\"There are {len(observer_manager)} observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.ObserverManager.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if any observers are registered (supports bool() and if checks).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if observer_manager:\n    print(\"Has observers\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered (supports bool() and if checks).\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if observer_manager:\n            print(\"Has observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.find_common_path","title":"<code>find_common_path(paths)</code>","text":"<p>Find the most specific common parent path shared by all paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[Path]</code> <p>List of Path objects (can be absolute or relative)</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>The deepest common parent directory, or None if paths is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\nPath('/a/b')\n&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\nPath('/')\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def find_common_path(paths: list[Path]) -&gt; Optional[Path]:\n    \"\"\"Find the most specific common parent path shared by all paths.\n\n    Args:\n        paths: List of Path objects (can be absolute or relative)\n\n    Returns:\n        The deepest common parent directory, or None if paths is empty\n\n    Examples:\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\n        Path('/a/b')\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\n        Path('/')\n    \"\"\"\n    if not paths:\n        return None\n\n    # Convert all paths to absolute for comparison\n    abs_paths = [p.resolve() for p in paths]\n\n    # Get all parent parts for each path\n    all_parts = [list(p.parents)[::-1] + [p.parent] for p in abs_paths]\n\n    # Find common prefix by comparing parts\n    if not all_parts:\n        return None\n\n    common = abs_paths[0].parent\n    for path in abs_paths[1:]:\n        # Find the common ancestor between current common and this path\n        try:\n            # Try to make path relative to common - if it works, common is still valid\n            path.relative_to(common)\n        except ValueError:\n            # Path is not under common, need to go up\n            # Find the actual common ancestor\n            while common != common.parent:  # Don't go above root\n                try:\n                    path.relative_to(common)\n                    break\n                except ValueError:\n                    common = common.parent\n\n    return common\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.format_bytes","title":"<code>format_bytes(size_bytes)</code>","text":"<p>Format byte size as human-readable string.</p> <p>Parameters:</p> Name Type Description Default <code>size_bytes</code> <code>int</code> <p>Size in bytes</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_bytes(500)\n'500 B'\n&gt;&gt;&gt; format_bytes(1536)\n'1.5 KB'\n&gt;&gt;&gt; format_bytes(2621440)\n'2.5 MB'\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def format_bytes(size_bytes: int) -&gt; str:\n    \"\"\"Format byte size as human-readable string.\n\n    Args:\n        size_bytes: Size in bytes\n\n    Returns:\n        Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")\n\n    Examples:\n        &gt;&gt;&gt; format_bytes(500)\n        '500 B'\n        &gt;&gt;&gt; format_bytes(1536)\n        '1.5 KB'\n        &gt;&gt;&gt; format_bytes(2621440)\n        '2.5 MB'\n    \"\"\"\n    if size_bytes &lt; 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes &lt; 1024 * 1024:\n        return f\"{size_bytes / 1024:.1f} KB\"\n    else:\n        return f\"{size_bytes / (1024 * 1024):.1f} MB\"\n</code></pre>"},{"location":"api/utils/observer_manager/","title":"Observer Manager","text":""},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager","title":"<code>observer_manager</code>","text":"<p>Generic observer pattern manager.</p> <p>This module provides a reusable ObserverManager class that handles thread-safe registration, unregistration, and notification of observers. It eliminates the need to duplicate observer management code across multiple classes.</p>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager","title":"<code>ObserverManager(lock=None, observer_type_name='observer')</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic observer list manager with thread-safe registration and notification.</p> <p>This class provides a reusable implementation of the observer pattern, eliminating code duplication across EditorService, Player, LaunchpadController, SamplerStateMachine, and other classes.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>The observer protocol type (e.g., EditObserver, StateObserver)</p> required Thread Safety <p>All operations are thread-safe. The lock is released before calling observer callbacks to prevent potential deadlocks.</p> Example <pre><code>class MyService:\n    def __init__(self):\n        self._observers = ObserverManager[MyObserver]()\n\n    def register_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.register(observer)\n\n    def unregister_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.unregister(observer)\n\n    def _notify_something_happened(self, data):\n        self._observers.notify('on_something_happened', data)\n</code></pre> <p>Initialize the observer manager.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Optional[Lock]</code> <p>Optional threading lock to use. If None, creates a new lock.</p> <code>None</code> <code>observer_type_name</code> <code>str</code> <p>Name of the observer type for logging (e.g., \"edit\", \"state\")</p> <code>'observer'</code> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __init__(self, lock: Optional[Lock] = None, observer_type_name: str = \"observer\"):\n    \"\"\"\n    Initialize the observer manager.\n\n    Args:\n        lock: Optional threading lock to use. If None, creates a new lock.\n        observer_type_name: Name of the observer type for logging (e.g., \"edit\", \"state\")\n    \"\"\"\n    self._observers: list[T] = []\n    self._lock = lock or Lock()\n    self._observer_type_name = observer_type_name\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.register","title":"<code>register(observer)</code>","text":"<p>Register an observer (idempotent - won't add duplicates).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to register</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def register(self, observer: T) -&gt; None:\n    \"\"\"\n    Register an observer (idempotent - won't add duplicates).\n\n    Args:\n        observer: The observer to register\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer not in self._observers:\n            self._observers.append(observer)\n            logger.info(f\"Registered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.debug(f\"{self._observer_type_name} observer already registered: {observer}\")\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.unregister","title":"<code>unregister(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to unregister</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def unregister(self, observer: T) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer in self._observers:\n            self._observers.remove(observer)\n            logger.debug(f\"Unregistered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.warning(f\"Attempted to unregister unknown {self._observer_type_name} observer: {observer}\")\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.notify","title":"<code>notify(callback_name, *args, **kwargs)</code>","text":"<p>Notify all observers by calling their callback method.</p> <p>The lock is acquired to copy the observer list, then released before calling callbacks. This prevents deadlocks if observers try to register/ unregister during notification.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call (e.g., 'on_edit_event')</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Error Handling <p>Exceptions in observer callbacks are logged but don't affect other observers.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def notify(self, callback_name: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notify all observers by calling their callback method.\n\n    The lock is acquired to copy the observer list, then released before\n    calling callbacks. This prevents deadlocks if observers try to register/\n    unregister during notification.\n\n    Args:\n        callback_name: Name of the callback method to call (e.g., 'on_edit_event')\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Error Handling:\n        Exceptions in observer callbacks are logged but don't affect other observers.\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = list(self._observers)\n\n    # Call observers without holding lock (prevents deadlocks)\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.notify_with_filter","title":"<code>notify_with_filter(callback_name, filter_fn, *args, **kwargs)</code>","text":"<p>Notify only observers that match the filter predicate.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call</p> required <code>filter_fn</code> <code>Callable[[T], bool]</code> <p>Predicate function that returns True for observers to notify</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Example <pre><code># Only notify observers that implement a specific interface\nself._observers.notify_with_filter(\n    'on_custom_event',\n    lambda obs: hasattr(obs, 'supports_custom_events'),\n    event_data\n)\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def notify_with_filter(\n    self,\n    callback_name: str,\n    filter_fn: Callable[[T], bool],\n    *args: Any,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Notify only observers that match the filter predicate.\n\n    Args:\n        callback_name: Name of the callback method to call\n        filter_fn: Predicate function that returns True for observers to notify\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Example:\n        ```python\n        # Only notify observers that implement a specific interface\n        self._observers.notify_with_filter(\n            'on_custom_event',\n            lambda obs: hasattr(obs, 'supports_custom_events'),\n            event_data\n        )\n        ```\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = [obs for obs in self._observers if filter_fn(obs)]\n\n    # Call filtered observers without holding lock\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.count","title":"<code>count()</code>","text":"<p>Get the number of registered observers.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers.\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.has_observers","title":"<code>has_observers()</code>","text":"<p>Check if any observers are registered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def has_observers(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered.\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.clear","title":"<code>clear()</code>","text":"<p>Remove all registered observers.</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Remove all registered observers.\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        count = len(self._observers)\n        self._observers.clear()\n        if count &gt; 0:\n            logger.info(f\"Cleared {count} {self._observer_type_name} observer(s)\")\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.__contains__","title":"<code>__contains__(observer)</code>","text":"<p>Check if an observer is registered (supports 'in' operator).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to check for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if my_observer in observer_manager:\n    print(\"Observer is registered\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __contains__(self, observer: T) -&gt; bool:\n    \"\"\"\n    Check if an observer is registered (supports 'in' operator).\n\n    Args:\n        observer: The observer to check for\n\n    Returns:\n        True if observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if my_observer in observer_manager:\n            print(\"Observer is registered\")\n        ```\n    \"\"\"\n    with self._lock:\n        return observer in self._observers\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of registered observers (supports len() function).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>print(f\"There are {len(observer_manager)} observers\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers (supports len() function).\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        print(f\"There are {len(observer_manager)} observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/utils/observer_manager/#launchsampler.utils.observer_manager.ObserverManager.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if any observers are registered (supports bool() and if checks).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if observer_manager:\n    print(\"Has observers\")\n</code></pre> Source code in <code>src/launchsampler/utils/observer_manager.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered (supports bool() and if checks).\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if observer_manager:\n            print(\"Has observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/utils/paths/","title":"Paths","text":""},{"location":"api/utils/paths/#launchsampler.utils.paths","title":"<code>paths</code>","text":"<p>Path utility functions.</p>"},{"location":"api/utils/paths/#launchsampler.utils.paths.format_bytes","title":"<code>format_bytes(size_bytes)</code>","text":"<p>Format byte size as human-readable string.</p> <p>Parameters:</p> Name Type Description Default <code>size_bytes</code> <code>int</code> <p>Size in bytes</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_bytes(500)\n'500 B'\n&gt;&gt;&gt; format_bytes(1536)\n'1.5 KB'\n&gt;&gt;&gt; format_bytes(2621440)\n'2.5 MB'\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def format_bytes(size_bytes: int) -&gt; str:\n    \"\"\"Format byte size as human-readable string.\n\n    Args:\n        size_bytes: Size in bytes\n\n    Returns:\n        Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")\n\n    Examples:\n        &gt;&gt;&gt; format_bytes(500)\n        '500 B'\n        &gt;&gt;&gt; format_bytes(1536)\n        '1.5 KB'\n        &gt;&gt;&gt; format_bytes(2621440)\n        '2.5 MB'\n    \"\"\"\n    if size_bytes &lt; 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes &lt; 1024 * 1024:\n        return f\"{size_bytes / 1024:.1f} KB\"\n    else:\n        return f\"{size_bytes / (1024 * 1024):.1f} MB\"\n</code></pre>"},{"location":"api/utils/paths/#launchsampler.utils.paths.find_common_path","title":"<code>find_common_path(paths)</code>","text":"<p>Find the most specific common parent path shared by all paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[Path]</code> <p>List of Path objects (can be absolute or relative)</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>The deepest common parent directory, or None if paths is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\nPath('/a/b')\n&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\nPath('/')\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def find_common_path(paths: list[Path]) -&gt; Optional[Path]:\n    \"\"\"Find the most specific common parent path shared by all paths.\n\n    Args:\n        paths: List of Path objects (can be absolute or relative)\n\n    Returns:\n        The deepest common parent directory, or None if paths is empty\n\n    Examples:\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\n        Path('/a/b')\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\n        Path('/')\n    \"\"\"\n    if not paths:\n        return None\n\n    # Convert all paths to absolute for comparison\n    abs_paths = [p.resolve() for p in paths]\n\n    # Get all parent parts for each path\n    all_parts = [list(p.parents)[::-1] + [p.parent] for p in abs_paths]\n\n    # Find common prefix by comparing parts\n    if not all_parts:\n        return None\n\n    common = abs_paths[0].parent\n    for path in abs_paths[1:]:\n        # Find the common ancestor between current common and this path\n        try:\n            # Try to make path relative to common - if it works, common is still valid\n            path.relative_to(common)\n        except ValueError:\n            # Path is not under common, need to go up\n            # Find the actual common ancestor\n            while common != common.parent:  # Don't go above root\n                try:\n                    path.relative_to(common)\n                    break\n                except ValueError:\n                    common = common.parent\n\n    return common\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>LaunchSampler follows a clean architecture with clear separation of concerns, event-driven synchronization, and SOLID design principles.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"UI Layer\"\n        TUI[Terminal UI]\n        LED[LED Service]\n    end\n\n    subgraph \"Orchestrator\"\n        APP[LaunchpadSamplerApp]\n    end\n\n    subgraph \"Services\"\n        EDITOR[Editor Service]\n        SETMGR[Set Manager]\n        PLAYER[Player]\n    end\n\n    subgraph \"Core\"\n        ENGINE[Sampler Engine]\n        STATE[State Machine]\n    end\n\n    subgraph \"Devices\"\n        MIDI[MIDI Controller]\n        AUDIO[Audio Device]\n    end\n\n    subgraph \"Models\"\n        LP[Launchpad]\n        PAD[Pad]\n        SAMPLE[Sample]\n    end\n\n    TUI --&gt; APP\n    LED --&gt; APP\n    APP --&gt; EDITOR\n    APP --&gt; SETMGR\n    APP --&gt; PLAYER\n    PLAYER --&gt; ENGINE\n    PLAYER --&gt; MIDI\n    ENGINE --&gt; STATE\n    ENGINE --&gt; AUDIO\n    MIDI --&gt; AUDIO\n    EDITOR --&gt; LP\n    LP --&gt; PAD\n    PAD --&gt; SAMPLE\n\n    style APP fill:#673ab7,color:#fff\n    style PLAYER fill:#9c27b0,color:#fff\n    style ENGINE fill:#e91e63,color:#fff</code></pre>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":"<p>LaunchSampler is built on SOLID principles:</p>"},{"location":"architecture/overview/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Each component has one well-defined purpose:</p> <ul> <li>EditorService: Pad editing operations only</li> <li>Player: Audio/MIDI coordination only</li> <li>SamplerEngine: Low-level audio rendering only</li> <li>TUIService: UI rendering and updates only</li> </ul>"},{"location":"architecture/overview/#openclosed-principle","title":"Open/Closed Principle","text":"<p>Extension without modification through protocols:</p> <pre><code>@runtime_checkable\nclass StateObserver(Protocol):\n    \"\"\"Any object can observe playback events.\"\"\"\n    def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n        ...\n</code></pre>"},{"location":"architecture/overview/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>All implementations are interchangeable:</p> <ul> <li>Any <code>DeviceInput</code> works for MIDI</li> <li>Any <code>DeviceOutput</code> works for audio</li> <li>Any <code>StateObserver</code> can receive events</li> </ul>"},{"location":"architecture/overview/#interface-segregation-principle","title":"Interface Segregation Principle","text":"<p>Focused, granular protocols:</p> <ul> <li><code>EditObserver</code> - Editing events only</li> <li><code>StateObserver</code> - Playback events only</li> <li><code>MidiObserver</code> - MIDI events only</li> <li><code>AppObserver</code> - App lifecycle events only</li> </ul>"},{"location":"architecture/overview/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>High-level modules depend on abstractions:</p> <pre><code>class Player:\n    def __init__(\n        self,\n        config: AppConfig,\n        state_machine: Optional[SamplerStateMachine] = None\n    ):\n        # Dependency injection, not hard-coded creation\n        self._state_machine = state_machine or SamplerStateMachine()\n</code></pre>"},{"location":"architecture/overview/#key-patterns","title":"Key Patterns","text":""},{"location":"architecture/overview/#observer-pattern","title":"Observer Pattern","text":"<p>Event-driven synchronization keeps all components in sync:</p> <pre><code># Editor fires events when pads change\neditor.assign_sample(pad_index, sample_path)\n  \u2192 EditEvent.PAD_ASSIGNED\n    \u2192 TUIService updates UI\n    \u2192 Player loads sample into engine\n    \u2192 LEDService updates LED color\n</code></pre> <p>Benefits: - \u2705 Loose coupling - components don't know about each other - \u2705 Automatic synchronization - no manual update calls - \u2705 Extensible - add new observers without changing existing code</p>"},{"location":"architecture/overview/#service-layer-pattern","title":"Service Layer Pattern","text":"<p>Services encapsulate business logic:</p> <pre><code># EditorService - Manages pad edits\neditor.assign_sample(index, path)\neditor.set_pad_mode(index, mode)\neditor.move_pad(source, target)\n\n# SetManagerService - Manages sample sets\nset_manager.open_set(path)\nset_manager.save_set(set_obj, path)\nset_manager.create_from_directory(path)\n\n# Player - Manages playback\nplayer.trigger_pad(index)\nplayer.stop_pad(index)\nplayer.set_master_volume(volume)\n</code></pre> <p>Benefits: - \u2705 Testable - Services have clear inputs/outputs - \u2705 Reusable - Same services for TUI and LED UI - \u2705 Maintainable - Business logic in one place</p>"},{"location":"architecture/overview/#device-abstraction","title":"Device Abstraction","text":"<p>Hardware is abstracted behind protocols:</p> <pre><code>class DeviceInput(Protocol):\n    \"\"\"Generic MIDI input device.\"\"\"\n    def parse_input(msg: mido.Message) -&gt; Optional[tuple[str, int]]:\n        ...\n\nclass LaunchpadInput(DeviceInput):\n    \"\"\"Launchpad-specific implementation.\"\"\"\n    # Handles Launchpad MIDI quirks\n</code></pre> <p>Benefits: - \u2705 Hardware-agnostic - Easy to support new devices - \u2705 Testable - Mock devices for testing - \u2705 Flexible - Switch devices at runtime</p>"},{"location":"architecture/overview/#threading-model","title":"Threading Model","text":"<p>LaunchSampler uses three threads for real-time performance:</p> <pre><code>graph LR\n    subgraph \"UI Thread\"\n        A[Textual Event Loop]\n        B[TUI Rendering]\n        C[User Input]\n    end\n\n    subgraph \"MIDI Thread\"\n        D[MIDI Polling]\n        E[Pad Press/Release]\n    end\n\n    subgraph \"Audio Thread\"\n        F[Audio Callback]\n        G[Sample Mixing]\n        H[Lock-Free Queue]\n    end\n\n    C --&gt; D\n    E --&gt; H\n    H --&gt; F\n    F --&gt; G\n\n    style F fill:#e91e63,color:#fff\n    style H fill:#ff5722,color:#fff</code></pre>"},{"location":"architecture/overview/#thread-details","title":"Thread Details","text":"Thread Purpose Locks Priority UI Thread User interface, editing Standard locks Normal MIDI Thread Hardware input polling Lock-free queue High Audio Thread Real-time audio rendering No locks! Real-time"},{"location":"architecture/overview/#lock-free-audio-path","title":"Lock-Free Audio Path","text":"<p>The audio callback is completely lock-free for minimal latency:</p> <pre><code># Audio callback (real-time thread)\ndef _audio_callback(self, outdata, frames, time, status):\n    # NO LOCKS - just pop from lock-free queue\n    while not self._trigger_queue.empty():\n        action, pad_index = self._trigger_queue.get()\n        self._process_action(action, pad_index)\n\n    # Mix audio from active pads\n    self._render_audio(outdata, frames)\n</code></pre> <p>Key Insight: Triggers go through a lock-free queue, so the audio thread never blocks.</p>"},{"location":"architecture/overview/#state-management","title":"State Management","text":""},{"location":"architecture/overview/#single-source-of-truth","title":"Single Source of Truth","text":"<p>Each piece of state has one authoritative source:</p> State Source Observers Pad data <code>Launchpad.pads</code> TUI, LED, Player Playing pads <code>SamplerStateMachine</code> TUI, LED, Editor Current set <code>Orchestrator.current_set</code> TUI, SetManager Audio state <code>SamplerEngine</code> Player, State Machine"},{"location":"architecture/overview/#no-state-duplication","title":"No State Duplication","text":"<p>Components query canonical sources instead of caching:</p> <pre><code># \u274c BAD: Duplicate state cache\nclass LEDService:\n    def __init__(self):\n        self._playing_pads = set()  # Duplicate!\n\n# \u2705 GOOD: Query canonical source\nclass LEDService:\n    def _is_pad_playing(self, pad_index: int) -&gt; bool:\n        return self.state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"architecture/overview/#event-flow-example","title":"Event Flow Example","text":"<p>Here's how an edit operation flows through the system:</p> <pre><code>sequenceDiagram\n    participant User\n    participant TUI\n    participant Editor\n    participant Player\n    participant Engine\n    participant LED\n\n    User-&gt;&gt;TUI: Press 'B' to browse\n    TUI-&gt;&gt;Editor: assign_sample(index, path)\n    Editor-&gt;&gt;Editor: Update pad.sample\n    Editor-&gt;&gt;TUI: EditEvent.PAD_ASSIGNED\n    Editor-&gt;&gt;Player: EditEvent.PAD_ASSIGNED\n    Editor-&gt;&gt;LED: EditEvent.PAD_ASSIGNED\n    Player-&gt;&gt;Engine: load_sample(index, sample)\n    TUI-&gt;&gt;TUI: Update pad widget\n    LED-&gt;&gt;LED: Update LED color</code></pre>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Design Principles - Deep dive into SOLID</li> <li>Components - Detailed component documentation</li> <li>Event System - Event types and observers</li> <li>Threading Model - Thread safety details</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>LaunchSampler uses a JSON configuration file to store settings. The config is automatically created on first run.</p>"},{"location":"getting-started/configuration/#configuration-file-location","title":"Configuration File Location","text":"Linux / macOSWindows <pre><code>~/.config/launchsampler/config.json\n</code></pre> <pre><code>%APPDATA%\\launchsampler\\config.json\n</code></pre>"},{"location":"getting-started/configuration/#default-configuration","title":"Default Configuration","text":"<pre><code>{\n  \"audio_device_api\": null,\n  \"audio_device_id\": null,\n  \"sample_rate\": 44100,\n  \"buffer_size\": 512,\n  \"default_mode\": \"play\",\n  \"sets_dir\": \"~/.config/launchsampler/sets\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#audio-settings","title":"Audio Settings","text":""},{"location":"getting-started/configuration/#audio_device_api","title":"<code>audio_device_api</code>","text":"<ul> <li>Type: <code>string | null</code></li> <li>Default: <code>null</code> (auto-detect)</li> <li>Description: Audio API to use (e.g., \"MME\", \"DirectSound\", \"WASAPI\", \"ASIO\" on Windows)</li> </ul>"},{"location":"getting-started/configuration/#audio_device_id","title":"<code>audio_device_id</code>","text":"<ul> <li>Type: <code>integer | null</code></li> <li>Default: <code>null</code> (use default device)</li> <li>Description: Specific audio device ID to use</li> </ul>"},{"location":"getting-started/configuration/#sample_rate","title":"<code>sample_rate</code>","text":"<ul> <li>Type: <code>integer</code></li> <li>Default: <code>44100</code></li> <li>Options: <code>44100</code>, <code>48000</code>, <code>96000</code></li> <li>Description: Audio sample rate in Hz</li> </ul>"},{"location":"getting-started/configuration/#buffer_size","title":"<code>buffer_size</code>","text":"<ul> <li>Type: <code>integer</code></li> <li>Default: <code>512</code></li> <li>Options: <code>128</code>, <code>256</code>, <code>512</code>, <code>1024</code>, <code>2048</code></li> <li>Description: Audio buffer size in frames</li> <li>Note: Lower = less latency, higher CPU usage</li> </ul>"},{"location":"getting-started/configuration/#application-settings","title":"Application Settings","text":""},{"location":"getting-started/configuration/#default_mode","title":"<code>default_mode</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>\"play\"</code></li> <li>Options: <code>\"edit\"</code>, <code>\"play\"</code></li> <li>Description: Mode to start in</li> </ul>"},{"location":"getting-started/configuration/#sets_dir","title":"<code>sets_dir</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>\"~/.config/launchsampler/sets\"</code></li> <li>Description: Default directory for saving/loading sets</li> </ul>"},{"location":"getting-started/configuration/#listing-available-devices","title":"Listing Available Devices","text":""},{"location":"getting-started/configuration/#list-audio-devices","title":"List Audio Devices","text":"<pre><code>launchsampler --list-audio\n</code></pre> <p>Output example: <pre><code>Available Audio APIs:\n  - MME (default)\n  - DirectSound\n  - WASAPI\n\nMME Devices:\n  [0] Speakers (Realtek High Definition Audio)  [Default]\n  [1] Headphones (USB Audio Device)\n\nWASAPI Devices:\n  [2] Speakers (Realtek) [Default]\n  [3] Headphones (USB Audio)\n</code></pre></p>"},{"location":"getting-started/configuration/#list-midi-devices","title":"List MIDI Devices","text":"<pre><code>launchsampler --list-midi\n</code></pre> <p>Output example: <pre><code>Available MIDI Input Devices:\n  [0] Launchpad Mini MK3 MIDI In\n  [1] MIDI Keyboard In\n\nAvailable MIDI Output Devices:\n  [0] Launchpad Mini MK3 MIDI Out\n  [1] MIDI Keyboard Out\n</code></pre></p>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#low-latency-asio","title":"Low Latency (ASIO)","text":"<p>For professional audio interfaces with ASIO support:</p> <pre><code>{\n  \"audio_device_api\": \"ASIO\",\n  \"audio_device_id\": 0,\n  \"sample_rate\": 48000,\n  \"buffer_size\": 128,\n  \"default_mode\": \"play\",\n  \"sets_dir\": \"~/Music/LaunchSampler/Sets\"\n}\n</code></pre> <p>Low Latency</p> <p>Buffer size of 128 provides ~3ms latency but requires fast CPU and quality audio interface</p>"},{"location":"getting-started/configuration/#high-compatibility-default-device","title":"High Compatibility (Default Device)","text":"<p>For maximum compatibility:</p> <pre><code>{\n  \"audio_device_api\": null,\n  \"audio_device_id\": null,\n  \"sample_rate\": 44100,\n  \"buffer_size\": 512,\n  \"default_mode\": \"play\",\n  \"sets_dir\": \"~/.config/launchsampler/sets\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#production-setup-usb-audio-interface","title":"Production Setup (USB Audio Interface)","text":"<p>For USB audio interfaces:</p> <pre><code>{\n  \"audio_device_api\": \"WASAPI\",\n  \"audio_device_id\": 3,\n  \"sample_rate\": 48000,\n  \"buffer_size\": 256,\n  \"default_mode\": \"play\",\n  \"sets_dir\": \"~/Documents/LaunchSampler\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#editing-configuration","title":"Editing Configuration","text":""},{"location":"getting-started/configuration/#method-1-manual-edit","title":"Method 1: Manual Edit","text":"<p>Edit the JSON file directly:</p> <pre><code># Linux / macOS\nnano ~/.config/launchsampler/config.json\n\n# Windows\nnotepad %APPDATA%\\launchsampler\\config.json\n</code></pre>"},{"location":"getting-started/configuration/#method-2-python-api","title":"Method 2: Python API","text":"<pre><code>from launchsampler.models import AppConfig\nfrom pathlib import Path\n\n# Load config\nconfig = AppConfig.load_or_default()\n\n# Modify settings\nconfig.audio_device_api = \"WASAPI\"\nconfig.buffer_size = 256\nconfig.sample_rate = 48000\n\n# Save config\nconfig.save()\n</code></pre>"},{"location":"getting-started/configuration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/configuration/#audio-dropouts-glitches","title":"Audio Dropouts / Glitches","text":"<p>Increase buffer size: <pre><code>{\n  \"buffer_size\": 1024\n}\n</code></pre></p>"},{"location":"getting-started/configuration/#high-latency","title":"High Latency","text":"<p>Decrease buffer size (if your system can handle it): <pre><code>{\n  \"buffer_size\": 256\n}\n</code></pre></p> <p>Or use a better audio API (ASIO on Windows, CoreAudio on macOS).</p>"},{"location":"getting-started/configuration/#wrong-audio-device","title":"Wrong Audio Device","text":"<p>List devices and set explicitly: <pre><code>launchsampler --list-audio\n</code></pre></p> <p>Then set the device ID in config: <pre><code>{\n  \"audio_device_id\": 3\n}\n</code></pre></p>"},{"location":"getting-started/configuration/#midi-not-working","title":"MIDI Not Working","text":"<p>Check MIDI devices: <pre><code>launchsampler --list-midi\n</code></pre></p> <p>If your Launchpad is not listed: 1. Check USB connection 2. Install manufacturer drivers 3. Try a different USB port</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Start using LaunchSampler</li> <li>User Guide - Learn all features</li> <li>MIDI Integration - MIDI setup details</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>LaunchSampler can be installed using pip or uv. We recommend using <code>uv</code> for faster dependency resolution and installation.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>Novation Launchpad (Mini MK3, Pro MK3, X, or compatible device)</li> <li>Audio output device (soundcard)</li> </ul>"},{"location":"getting-started/installation/#supported-platforms","title":"Supported Platforms","text":"<ul> <li>\u2705 Windows</li> <li>\u2705 macOS</li> <li>\u2705 Linux</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":"Using uv (Recommended)Using pip <p>uv is a fast Python package installer and resolver.</p> <pre><code># Install uv (if not already installed)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install LaunchSampler\nuv pip install launchsampler\n\n# Or install from source\ngit clone https://github.com/jacobanana/launchsampler.git\ncd launchsampler\nuv sync\n</code></pre> <pre><code># Install from PyPI (when published)\npip install launchsampler\n\n# Or install from source\ngit clone https://github.com/jacobanana/launchsampler.git\ncd launchsampler\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that LaunchSampler is installed correctly:</p> <pre><code># Check version\nlaunchsampler --version\n\n# Show help\nlaunchsampler --help\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development, clone the repository and install with development dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/jacobanana/launchsampler.git\ncd launchsampler\n\n# Install with development dependencies using uv\nuv sync --all-extras\n\n# Or using pip\npip install -e \".[dev]\"\n\n# Run tests to verify\nuv run pytest\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#midi-device-not-found","title":"MIDI Device Not Found","text":"<p>If LaunchSampler cannot detect your Launchpad:</p> <ol> <li>Check USB connection - Ensure the Launchpad is connected</li> <li>Install drivers - Some systems may need MIDI drivers</li> <li>List devices - Run <code>launchsampler --list-midi</code> to see available devices</li> </ol>"},{"location":"getting-started/installation/#audio-issues","title":"Audio Issues","text":"<p>If you experience audio problems:</p> <ol> <li>Check audio device - Run <code>launchsampler --list-audio</code> to see available devices</li> <li>Configure audio - Edit <code>~/.config/launchsampler/config.json</code> to select device</li> <li>Test playback - Try playing a sample in edit mode (Space key)</li> </ol>"},{"location":"getting-started/installation/#permission-errors-linux","title":"Permission Errors (Linux)","text":"<p>On Linux, you may need to add your user to the <code>audio</code> group:</p> <pre><code>sudo usermod -a -G audio $USER\n</code></pre> <p>Then log out and log back in for changes to take effect.</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics</li> <li>Configuration - Customize your setup</li> <li>User Guide - Master all features</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with LaunchSampler in just a few minutes!</p>"},{"location":"getting-started/quick-start/#1-launch-the-application","title":"1. Launch the Application","text":"<pre><code>launchsampler\n</code></pre> <p>The application will start in Play Mode with an empty set.</p> <p>First Run</p> <p>On first run, LaunchSampler creates a config file at <code>~/.config/launchsampler/config.json</code></p>"},{"location":"getting-started/quick-start/#2-switch-to-edit-mode","title":"2. Switch to Edit Mode","text":"<p>Press E to switch to Edit Mode, where you can build your sample set.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Edit Mode: Untitled Set                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [8x8 Grid]  \u2502  Pad Details Panel             \u2502\n\u2502             \u2502  - Sample name                  \u2502\n\u2502             \u2502  - Playback mode                \u2502\n\u2502             \u2502  - Volume                       \u2502\n\u2502             \u2502  - Move controls                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/quick-start/#3-load-samples","title":"3. Load Samples","text":""},{"location":"getting-started/quick-start/#option-a-load-from-directory","title":"Option A: Load from Directory","text":"<p>Press Ctrl+L to load all samples from a directory:</p> <ol> <li>Navigate to your samples folder</li> <li>Select the directory</li> <li>LaunchSampler automatically assigns first 64 samples to pads</li> </ol>"},{"location":"getting-started/quick-start/#option-b-assign-individual-samples","title":"Option B: Assign Individual Samples","text":"<ol> <li>Click a pad or use arrow keys to select it</li> <li>Press B to browse for a sample</li> <li>Select your audio file (WAV, MP3, FLAC, etc.)</li> </ol>"},{"location":"getting-started/quick-start/#4-configure-pads","title":"4. Configure Pads","text":"<p>For each pad, you can configure:</p>"},{"location":"getting-started/quick-start/#playback-mode","title":"Playback Mode","text":"<p>Press number keys to set playback mode:</p> <ul> <li>1 - One-Shot: Play sample once from start to end</li> <li>2 - Hold: Play while pad is held, stop when released</li> <li>3 - Loop: Loop continuously until stopped</li> <li>4 - Loop Toggle: Toggle loop on/off with each press</li> </ul>"},{"location":"getting-started/quick-start/#adjust-volume","title":"Adjust Volume","text":"<ul> <li>Use the volume slider in the Pad Details Panel</li> <li>Or edit directly in the volume field</li> </ul>"},{"location":"getting-started/quick-start/#test-playback","title":"Test Playback","text":"<ul> <li>Press Space to test the selected pad</li> <li>Or click the Test button in the details panel</li> </ul>"},{"location":"getting-started/quick-start/#5-save-your-set","title":"5. Save Your Set","text":"<p>Press Ctrl+S to save your set:</p> <ol> <li>Choose a location (defaults to <code>~/.config/launchsampler/sets/</code>)</li> <li>Enter a name for your set</li> <li>Your set is saved as a <code>.json</code> file</li> </ol>"},{"location":"getting-started/quick-start/#6-switch-to-play-mode","title":"6. Switch to Play Mode","text":"<p>Press P to switch to Play Mode for live performance:</p> <ul> <li>MIDI Input: Your Launchpad is now active - press pads to trigger samples</li> <li>Keyboard Input: You can still test pads with Space</li> <li>No Editing: Edit operations are disabled to prevent accidents during performance</li> </ul>"},{"location":"getting-started/quick-start/#common-workflows","title":"Common Workflows","text":""},{"location":"getting-started/quick-start/#organize-samples","title":"Organize Samples","text":"<p>Use directional operations to arrange your pads:</p> <pre><code>Alt + Arrow    : Duplicate pad in direction\nCtrl + Arrow   : Move pad in direction\nC              : Copy pad\nX              : Cut pad\nV              : Paste pad\nD              : Delete pad\n</code></pre>"},{"location":"getting-started/quick-start/#set-management","title":"Set Management","text":"<pre><code>Ctrl + O       : Open saved set\nCtrl + L       : Load from directory\nCtrl + S       : Save current set\n</code></pre>"},{"location":"getting-started/quick-start/#navigation","title":"Navigation","text":"<pre><code>Arrow Keys     : Navigate between pads (Edit Mode)\nE              : Switch to Edit Mode\nP              : Switch to Play Mode\nEsc            : Stop all audio (Panic)\nCtrl + Q       : Quit application\n</code></pre>"},{"location":"getting-started/quick-start/#example-session","title":"Example Session","text":"<p>Here's a typical workflow:</p> <ol> <li>Start in Edit Mode - E</li> <li>Load samples - Ctrl+L \u2192 Select \"Drums\" folder</li> <li>Configure pads:</li> <li>Pad 0 (Kick): One-shot (1)</li> <li>Pad 1 (Snare): One-shot (1)</li> <li>Pad 8 (Hi-hat): Loop (3)</li> <li>Pad 16 (Bass): Hold (2)</li> <li>Test your set - Select pads and press Space</li> <li>Save - Ctrl+S \u2192 Name it \"Drums Kit\"</li> <li>Perform - P to switch to Play Mode</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize audio/MIDI settings</li> <li>User Guide - Learn all features in depth</li> <li>Keyboard Shortcuts - Complete shortcut reference</li> </ul>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>This section covers all features of LaunchSampler in detail.</p>"},{"location":"user-guide/overview/#contents","title":"Contents","text":"<ul> <li>Edit Mode - Build and configure sample sets</li> <li>Play Mode - Live performance mode</li> <li>Keyboard Shortcuts - Complete shortcut reference</li> <li>MIDI Integration - MIDI setup and usage</li> <li>Sample Management - Organize your samples</li> </ul> <p>Documentation in Progress</p> <p>This documentation is being actively developed. Check back soon for complete guides.</p>"}]}