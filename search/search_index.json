{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LaunchSampler","text":"<p>Welcome to LaunchSampler - a powerful, terminal based sample player that transforms your Novation Launchpad into a professional sample playback instrument.</p> <ul> <li> <p> Installation</p> <p>Get started quickly with pip or uv</p> <p> Install now</p> </li> <li> <p> Quick Start</p> <p>Learn the basics in 5 minutes</p> <p> Quick start guide</p> </li> <li> <p> User Guide</p> <p>Master edit mode, play mode, and shortcuts</p> <p> Read the guide</p> </li> <li> <p> Troubleshooting</p> <p>Solve common audio, MIDI, and configuration issues</p> <p> Get help</p> </li> <li> <p> API Reference</p> <p>Detailed API documentation for developers</p> <p> API docs</p> </li> </ul>"},{"location":"#get-involved","title":"Get Involved","text":"<p>LaunchSampler is open source! We welcome contributions:</p> <ul> <li> GitHub Repository</li> <li> Report Issues</li> <li> Discussions</li> <li> Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>LaunchSampler is licensed under the MIT License. See License for details.</p>"},{"location":"DOCUMENTATION/","title":"Documentation Guide","text":"<p>This document explains how the LaunchSampler documentation is structured and how to work with it.</p>"},{"location":"DOCUMENTATION/#structure","title":"Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 api/              # Auto-generated API documentation\n\u251c\u2500\u2500 getting-started/  # Installation and quick start guides\n\u251c\u2500\u2500 user-guide/       # User documentation\n\u251c\u2500\u2500 architecture/     # Architecture documentation\n\u251c\u2500\u2500 contributing/     # Contributing guidelines\n\u2514\u2500\u2500 index.md         # Documentation homepage\n\nmkdocs.yml           # MkDocs configuration\nscripts/\n\u2514\u2500\u2500 generate_api_docs.py  # API docs generator\n</code></pre>"},{"location":"DOCUMENTATION/#building-documentation-locally","title":"Building Documentation Locally","text":""},{"location":"DOCUMENTATION/#prerequisites","title":"Prerequisites","text":"<p>Install development dependencies:</p> <pre><code>uv sync --group dev\n</code></pre>"},{"location":"DOCUMENTATION/#generate-api-documentation","title":"Generate API Documentation","text":"<p>The API documentation is automatically generated from Python docstrings:</p> <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre> <p>This will: - Scan all Python modules in <code>src/launchsampler/</code> - Generate markdown files with <code>:::</code> directives in <code>docs/api/</code> - Create package overview pages - Automatically update the API Reference section in <code>mkdocs.yml</code> using PyYAML for proper formatting - Save navigation structure to <code>docs/api_nav.yml</code> (for reference)</p> <p>When to regenerate: - After adding new modules or packages - After restructuring the codebase - When you want the latest docstrings in docs</p> <p>No manual copying needed! The script automatically updates <code>mkdocs.yml</code> for you.</p>"},{"location":"DOCUMENTATION/#serve-documentation","title":"Serve Documentation","text":"<p>Start a local development server with live reload:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>Visit http://127.0.0.1:8000 to view the documentation.</p> <p>Changes to markdown files are reflected immediately. If you modify Python docstrings, re-run the API docs generator.</p>"},{"location":"DOCUMENTATION/#build-static-site","title":"Build Static Site","text":"<p>Build the complete documentation site:</p> <pre><code>uv run mkdocs build\n</code></pre> <p>Output is generated in <code>site/</code> directory (ignored by git).</p>"},{"location":"DOCUMENTATION/#deployment","title":"Deployment","text":"<p>Documentation is automatically built and deployed to GitHub Pages via GitHub Actions:</p> <ul> <li>On push to <code>main</code>: Docs are built and deployed</li> <li>On pull requests: Docs are built (but not deployed) to check for errors</li> </ul> <p>The workflow (<code>.github/workflows/docs.yml</code>) does: 1. Install dependencies with <code>uv</code> 2. Generate API documentation 3. Build docs with <code>mkdocs build --strict</code> 4. Deploy to GitHub Pages (on main branch only)</p>"},{"location":"DOCUMENTATION/#manual-deployment","title":"Manual Deployment","text":"<p>To manually deploy to GitHub Pages:</p> <pre><code>uv run mkdocs gh-deploy\n</code></pre> <p>This builds and pushes to the <code>gh-pages</code> branch.</p>"},{"location":"DOCUMENTATION/#writing-documentation","title":"Writing Documentation","text":""},{"location":"DOCUMENTATION/#markdown-files","title":"Markdown Files","text":"<p>Standard markdown files in <code>docs/</code> are written manually: - User guides - Tutorials - Architecture docs - Contributing guidelines</p>"},{"location":"DOCUMENTATION/#api-documentation","title":"API Documentation","text":"<p>API docs are auto-generated from Python docstrings. To document code:</p> <ol> <li>Write Google-style docstrings in your Python modules:</li> </ol> <pre><code>def my_function(param: str) -&gt; int:\n    \"\"\"\n    Short description.\n\n    Longer description with details.\n\n    Args:\n        param: Description of parameter\n\n    Returns:\n        Description of return value\n\n    Raises:\n        ValueError: When something goes wrong\n    \"\"\"\n</code></pre> <ol> <li>Add architecture diagrams in module docstrings:</li> </ol> <pre><code>\"\"\"\nModule description.\n\nArchitecture Diagram\n--------------------\n\n::\n\n    Component A\n        \u2193\n    Component B\n        \u2193\n    Component C\n\"\"\"\n</code></pre> <ol> <li>Regenerate API docs to see changes:</li> </ol> <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre>"},{"location":"DOCUMENTATION/#adding-new-documentation-pages","title":"Adding New Documentation Pages","text":"<ol> <li>Create markdown file in appropriate <code>docs/</code> subdirectory</li> <li>Add entry to <code>nav:</code> section in <code>mkdocs.yml</code></li> <li>Preview with <code>uv run mkdocs serve</code></li> </ol>"},{"location":"DOCUMENTATION/#configuration","title":"Configuration","text":""},{"location":"DOCUMENTATION/#mkdocsyml","title":"mkdocs.yml","text":"<p>Main configuration file. Key sections:</p> <ul> <li><code>site_name</code>, <code>site_description</code>: Site metadata</li> <li><code>theme</code>: Material theme configuration</li> <li><code>plugins</code>: Enabled plugins (search, mkdocstrings, etc.)</li> <li><code>markdown_extensions</code>: Markdown features</li> <li><code>nav</code>: Documentation navigation structure</li> </ul>"},{"location":"DOCUMENTATION/#mkdocstrings-configuration","title":"mkdocstrings Configuration","text":"<p>API documentation is configured in <code>mkdocs.yml</code>:</p> <pre><code>plugins:\n  - mkdocstrings:\n      handlers:\n        python:\n          options:\n            docstring_style: google\n            show_source: true\n            # ... other options\n</code></pre>"},{"location":"DOCUMENTATION/#troubleshooting","title":"Troubleshooting","text":""},{"location":"DOCUMENTATION/#api-docs-not-updating","title":"API docs not updating","text":"<p>Re-run the generator: <pre><code>uv run python scripts/generate_api_docs.py\n</code></pre></p>"},{"location":"DOCUMENTATION/#build-warnings","title":"Build warnings","text":"<p>Run strict build to catch all issues: <pre><code>uv run mkdocs build --strict\n</code></pre></p>"},{"location":"DOCUMENTATION/#type-annotation-warnings","title":"Type annotation warnings","text":"<p>Ensure all public APIs have proper type hints. See: - <code>src/launchsampler/audio/device.py</code> - <code>src/launchsampler/devices/registry.py</code> - <code>src/launchsampler/utils/observer_manager.py</code></p> <p>For examples of proper type annotations.</p>"},{"location":"DOCUMENTATION/#best-practices","title":"Best Practices","text":"<ol> <li>Commit <code>docs/</code>, not <code>site/</code></li> <li>Source files belong in git</li> <li> <p>Build output is regenerated by CI</p> </li> <li> <p>Regenerate API docs after code changes</p> </li> <li>Keep documentation in sync with code</li> <li> <p>Run generator before committing</p> </li> <li> <p>Write descriptive docstrings</p> </li> <li>They become your API documentation</li> <li> <p>Include examples when helpful</p> </li> <li> <p>Use diagrams in docstrings</p> </li> <li>ASCII diagrams render well in docs</li> <li> <p>Great for explaining architecture</p> </li> <li> <p>Test docs build before committing <pre><code>uv run mkdocs build --strict\n</code></pre></p> </li> </ol>"},{"location":"DOCUMENTATION/#resources","title":"Resources","text":"<ul> <li>MkDocs Documentation</li> <li>Material for MkDocs</li> <li>mkdocstrings</li> <li>Google Style Python Docstrings</li> </ul>"},{"location":"MODEL_CLI_BUILDER/","title":"ModelCLIBuilder: Auto-Generate CLI from Pydantic Models","text":"<p><code>ModelCLIBuilder</code> is a generic framework for auto-generating CLI commands from any Pydantic model. It integrates with <code>ModelManagerService</code> for type-safe configuration management.</p>"},{"location":"MODEL_CLI_BUILDER/#quick-start","title":"Quick Start","text":"<pre><code>from pathlib import Path\nfrom launchsampler.cli.model_cli_builder import ModelCLIBuilder\nfrom launchsampler.models import AppConfig\n\n# Create builder\nbuilder = ModelCLIBuilder(\n    AppConfig,\n    config_path=Path.home() / \".launchsampler\" / \"config.json\"\n)\n\n# Build CLI group with all commands\nconfig = builder.build_group()\n</code></pre> <p>This auto-generates: - <code>config show</code> - Display configuration - <code>config set --field value</code> - Update fields - <code>config validate</code> - Validate configuration file - <code>config reset</code> - Reset to defaults</p>"},{"location":"MODEL_CLI_BUILDER/#features","title":"Features","text":""},{"location":"MODEL_CLI_BUILDER/#1-auto-generated-options","title":"1. Auto-Generated Options","text":"<p>CLI options are automatically generated from Pydantic model fields:</p> <pre><code>class AppConfig(BaseModel):\n    buffer_size: int = Field(default=512, description=\"Audio buffer size\")\n    auto_save: bool = Field(default=True, description=\"Auto-save changes\")\n</code></pre> <p>Generates CLI options: <pre><code>config set --buffer-size 1024\nconfig set --auto-save false\n</code></pre></p>"},{"location":"MODEL_CLI_BUILDER/#2-type-mapping","title":"2. Type Mapping","text":"<p>Pydantic types are automatically mapped to Click types:</p> Pydantic Type Click Type <code>int</code> <code>click.INT</code> <code>str</code> <code>click.STRING</code> <code>float</code> <code>click.FLOAT</code> <code>bool</code> <code>click.BOOL</code> <code>Path</code> <code>click.Path(path_type=Path)</code> <code>Optional[T]</code> Same as <code>T</code>"},{"location":"MODEL_CLI_BUILDER/#3-help-text","title":"3. Help Text","text":"<p>Help text is automatically generated from field descriptions:</p> <pre><code>class Config(BaseModel):\n    port: int = Field(\n        default=8000,\n        description=\"Server port number\"  # \u2190 Used in CLI help\n    )\n</code></pre> <pre><code>$ myapp config set --help\nOptions:\n  --port INTEGER  Server port number (default: 8000)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#4-custom-validators","title":"4. Custom Validators","text":"<p>Add custom validation logic with the <code>ValidatorRegistry</code>:</p> <pre><code>from launchsampler.cli.model_cli_builder import ValidatorRegistry\n\n@ValidatorRegistry.register(\"port\")\ndef validate_port(port: int) -&gt; tuple[bool, str | None]:\n    if port &lt; 1 or port &gt; 65535:\n        return False, \"Port must be between 1 and 65535\"\n    if port &lt; 1024:\n        return True, \"Warning: Port requires root privileges\"\n    return True, None\n</code></pre> <p>The validator returns: - <code>(True, message)</code> - Valid, show info message to user - <code>(False, error)</code> - Invalid, show error and abort</p>"},{"location":"MODEL_CLI_BUILDER/#5-field-level-overrides","title":"5. Field-Level Overrides","text":"<p>Customize individual fields:</p> <pre><code>builder = ModelCLIBuilder(\n    AppConfig,\n    config_path=Path(\"config.json\"),\n    field_overrides={\n        \"buffer_size\": {\n            \"short\": \"b\",  # Add short flag: -b\n            \"help\": \"Audio buffer size in frames\"  # Override help text\n        },\n        \"internal_field\": {\n            \"expose\": False  # Hide from CLI\n        },\n        \"custom_field\": {\n            \"type\": click.Choice(['a', 'b', 'c'])  # Custom Click type\n        }\n    }\n)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#usage-examples","title":"Usage Examples","text":""},{"location":"MODEL_CLI_BUILDER/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code>from pydantic import BaseModel, Field\nfrom pathlib import Path\n\nclass ServerConfig(BaseModel):\n    host: str = \"localhost\"\n    port: int = Field(default=8000, description=\"Server port\")\n    workers: int = 4\n\n# Build CLI\nbuilder = ModelCLIBuilder(\n    ServerConfig,\n    config_path=Path(\"server.json\")\n)\nconfig_cli = builder.build_group()\n</code></pre> <p>Generated CLI: <pre><code># Show all settings\n$ myapp config show\nServerConfig Configuration:\n  host: localhost\n  port: 8000\n  workers: 4\n\n# Update settings\n$ myapp config set --port 8080 --workers 16\n\u2713 port = 8080\n\u2713 workers = 16\nConfiguration saved to server.json\n\n# Show specific field\n$ myapp config show --field port\nport: 8080\n\n# Validate config file\n$ myapp config validate\n\u2713 server.json is valid\n\n# Reset to defaults\n$ myapp config reset --field port\n\u2713 Reset port to default: 8000\n</code></pre></p>"},{"location":"MODEL_CLI_BUILDER/#example-2-with-custom-validators","title":"Example 2: With Custom Validators","text":"<pre><code>from launchsampler.cli.model_cli_builder import ValidatorRegistry\n\n@ValidatorRegistry.register(\"buffer_size\")\ndef validate_buffer_size(size: int) -&gt; tuple[bool, str | None]:\n    \"\"\"Validate buffer size is power of 2.\"\"\"\n    if size &amp; (size - 1) != 0:\n        return False, \"Buffer size must be a power of 2 (512, 1024, 2048, ...)\"\n    return True, f\"Using buffer size: {size} frames\"\n\nbuilder = ModelCLIBuilder(AppConfig, Path(\"config.json\"))\n</code></pre> <pre><code>$ myapp config set --buffer-size 1000\nError validating buffer_size: Buffer size must be a power of 2 (512, 1024, 2048, ...)\n\n$ myapp config set --buffer-size 1024\n\u2713 buffer_size: Using buffer size: 1024 frames\nConfiguration saved to config.json\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#example-3-field-overrides","title":"Example 3: Field Overrides","text":"<pre><code>builder = ModelCLIBuilder(\n    AppConfig,\n    config_path=Path(\"config.json\"),\n    field_overrides={\n        \"default_audio_device\": {\n            \"short\": \"a\",\n            \"help\": \"Audio device ID (use 'myapp audio list' to see devices)\"\n        },\n        \"internal_debug_flag\": {\n            \"expose\": False  # Don't expose in CLI\n        }\n    }\n)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#example-4-complete-example","title":"Example 4: Complete Example","text":"<pre><code># models/config.py\nfrom pydantic import BaseModel, Field\nfrom pathlib import Path\n\nclass DatabaseConfig(BaseModel):\n    host: str = Field(default=\"localhost\", description=\"Database host\")\n    port: int = Field(default=5432, description=\"Database port\")\n    database: str = Field(default=\"myapp\", description=\"Database name\")\n    pool_size: int = Field(default=10, description=\"Connection pool size\")\n\n# cli/commands/database.py\nfrom launchsampler.cli.model_cli_builder import ModelCLIBuilder, ValidatorRegistry\n\n@ValidatorRegistry.register(\"pool_size\")\ndef validate_pool_size(size: int) -&gt; tuple[bool, str | None]:\n    if size &lt; 1:\n        return False, \"Pool size must be at least 1\"\n    if size &gt; 100:\n        return True, \"Warning: Large pool sizes may consume excessive resources\"\n    return True, None\n\nbuilder = ModelCLIBuilder(\n    DatabaseConfig,\n    config_path=Path.home() / \".myapp\" / \"database.json\",\n    field_overrides={\n        \"host\": {\"short\": \"h\"},\n        \"port\": {\"short\": \"p\"}\n    }\n)\n\ndatabase = builder.build_group(name=\"database\")\n\n# cli/main.py\nimport click\nfrom .commands.database import database\n\n@click.group()\ndef cli():\n    \"\"\"MyApp CLI\"\"\"\n    pass\n\ncli.add_command(database)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#individual-command-builders","title":"Individual Command Builders","text":"<p>Instead of building a complete group, you can build individual commands:</p> <pre><code>builder = ModelCLIBuilder(AppConfig, Path(\"config.json\"))\n\n# Build individual commands\nshow_cmd = builder.build_show_command()\nset_cmd = builder.build_set_command()\nvalidate_cmd = builder.build_validate_command()\nreset_cmd = builder.build_reset_command()\n\n# Add to custom group\n@click.group()\ndef config():\n    \"\"\"Custom config group\"\"\"\n    pass\n\nconfig.add_command(show_cmd)\nconfig.add_command(set_cmd)\n# ... add more commands\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#best-practices","title":"Best Practices","text":""},{"location":"MODEL_CLI_BUILDER/#1-model-as-source-of-truth","title":"1. Model as Source of Truth","text":"<p>Define descriptions, types, and defaults in your Pydantic model:</p> <pre><code>class Config(BaseModel):\n    # Good: Description in model\n    port: int = Field(\n        default=8000,\n        description=\"Server port number\"\n    )\n\n    # Avoid: Description in field_overrides\n    # (keeps CLI separate from model)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#2-use-field-descriptions","title":"2. Use Field Descriptions","text":"<p>Always add descriptions to Pydantic fields - they become CLI help text:</p> <pre><code># Good\nbuffer_size: int = Field(\n    default=512,\n    description=\"Audio buffer size in frames\"\n)\n\n# Bad - no help text generated\nbuffer_size: int = 512\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#3-register-validators-for-domain-logic","title":"3. Register Validators for Domain Logic","text":"<p>Use validators for domain-specific checks:</p> <pre><code>@ValidatorRegistry.register(\"audio_device\")\ndef validate_audio_device(device_id: int):\n    # Check if device exists in system\n    # Provide helpful error messages\n    # Return warnings for non-ideal configurations\n    ...\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#4-hide-internal-fields","title":"4. Hide Internal Fields","text":"<p>Don't expose internal fields in the CLI:</p> <pre><code>builder = ModelCLIBuilder(\n    Config,\n    field_overrides={\n        \"_internal_state\": {\"expose\": False},\n        \"debug_flag\": {\"expose\": False}\n    }\n)\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#5-provide-short-flags-for-common-options","title":"5. Provide Short Flags for Common Options","text":"<pre><code>field_overrides={\n    \"audio_device\": {\"short\": \"a\"},\n    \"buffer_size\": {\"short\": \"b\"},\n    \"config_file\": {\"short\": \"c\"}\n}\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Pydantic Model           \u2502\n\u2502 - Field definitions      \u2502\n\u2502 - Type annotations       \u2502\n\u2502 - Descriptions           \u2502\n\u2502 - Defaults               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ModelCLIBuilder          \u2502\n\u2502 - Type mapping           \u2502\n\u2502 - Help generation        \u2502\n\u2502 - Option creation        \u2502\n\u2502 - Validator integration  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Click Commands           \u2502\n\u2502 - show                   \u2502\n\u2502 - set                    \u2502\n\u2502 - validate               \u2502\n\u2502 - reset                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#comparison-with-manual-cli","title":"Comparison with Manual CLI","text":""},{"location":"MODEL_CLI_BUILDER/#manual-approach","title":"Manual Approach","text":"<pre><code>@click.command()\n@click.option('--buffer-size', type=int, help='Audio buffer size')\n@click.option('--auto-save', type=bool, help='Auto-save changes')\n@click.option('--port', type=int, help='Server port')\n# ... 20 more options ...\ndef config(buffer_size, auto_save, port, ...):\n    # Manual validation\n    # Manual loading\n    # Manual saving\n    # Manual error handling\n    pass\n</code></pre>"},{"location":"MODEL_CLI_BUILDER/#modelclibuilder-approach","title":"ModelCLIBuilder Approach","text":"<pre><code>builder = ModelCLIBuilder(AppConfig, Path(\"config.json\"))\nconfig = builder.build_group()\n</code></pre> <p>Benefits: - \u2705 Auto-updates when model changes - \u2705 Type-safe (Pydantic \u2192 Click) - \u2705 Consistent error handling - \u2705 Built-in validate/reset commands - \u2705 Less code (DRY principle) - \u2705 Model is single source of truth</p>"},{"location":"MODEL_CLI_BUILDER/#see-also","title":"See Also","text":"<ul> <li><code>demo_model_cli_builder.py</code> - Complete working example</li> <li><code>src/launchsampler/cli/commands/config_auto.py</code> - AppConfig example</li> <li><code>ModelManagerService</code> - Backend service for model management</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to LaunchSampler will be documented here.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>\ud83d\udea7 LED hardware synchronization</li> <li>\ud83d\udea7 Advanced effects and automation</li> <li>\ud83d\udea7 Multiple Launchpad support</li> </ul>"},{"location":"changelog/#010-2025-01-17","title":"0.1.0 - 2025-01-17","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>\u2705 Core audio engine with lock-free triggering</li> <li>\u2705 Terminal UI (TUI) with Textual</li> <li>\u2705 Edit mode with full sample management</li> <li>\u2705 Play mode with MIDI integration</li> <li>\u2705 Support for all Launchpad models (Mini MK3, Pro MK3, X)</li> <li>\u2705 Four playback modes (One-shot, Loop, Hold, Loop Toggle)</li> <li>\u2705 Sample set management (load, save, organize)</li> <li>\u2705 Keyboard shortcuts for all operations</li> <li>\u2705 Directional operations (copy, move, duplicate)</li> <li>\u2705 Comprehensive test suite (377 tests)</li> <li>\u2705 NavigationService refactoring (extracted from app.py)</li> <li>\u2705 Material for MkDocs documentation</li> </ul>"},{"location":"changelog/#architecture","title":"Architecture","text":"<ul> <li>\u2705 SOLID design principles</li> <li>\u2705 Observer pattern for event-driven sync</li> <li>\u2705 Service layer pattern</li> <li>\u2705 Device abstraction with protocols</li> <li>\u2705 Thread-safe multi-threaded architecture</li> <li>\u2705 Single source of truth for state management</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>\u2705 Architecture documentation</li> <li>\u2705 API reference structure</li> <li>\u2705 User guide structure</li> <li>\u2705 Quick start guide</li> <li>\u2705 Installation guide</li> <li>\u2705 Configuration guide</li> </ul>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>This page documents all available command-line interface commands for LaunchSampler.</p>"},{"location":"cli-reference/#launchsampler","title":"launchsampler","text":"<p>Launchpad Sampler - MIDI-controlled audio sample player for Novation Launchpad.</p> <p>The TUI provides two modes:</p> <ul> <li>Play Mode (default): Full MIDI integration for live performance</li> <li>Edit Mode: Build sets, assign samples, change configurations</li> </ul> <p>You can switch modes anytime by pressing E (edit) or P (play). A full list of shortcuts is available in the palette (press ctrl+p)</p> <p>You can either load an existing set by name, or load samples from a directory.</p> <p>Examples:   # Create new empty set   launchsampler</p>"},{"location":"cli-reference/#start-in-play-mode-with-saved-set","title":"Start in play mode with saved set","text":"<p>launchsampler --set my-drums</p> <p># Start in edit mode to configure a set   launchsampler --set my-drums --mode edit</p> <p># Load from samples directory   launchsampler --samples-dir ./samples</p> <p># Enable debug logging   launchsampler --debug</p> <p># Custom log file   launchsampler --log-file ./my-session.log</p> <p># List audio devices   launchsampler audio list</p> <p># List MIDI devices   launchsampler midi list</p> <p>Usage:</p> <pre><code>launchsampler [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--version</code> boolean Show the version and exit. <code>False</code> <code>--set</code>, <code>-s</code> text Name of saved set to load (from config/sets/) None <code>--mode</code>, <code>-m</code> choice (<code>edit</code> | <code>play</code>) Start in edit or play mode (default: play) <code>play</code> <code>--led-ui</code> / <code>--no-led-ui</code> boolean Enable LED UI on Launchpad hardware (default: enabled) <code>True</code> <code>--samples-dir</code>, <code>-d</code> directory Load samples from directory None <code>-v</code>, <code>--verbose</code> integer range (<code>0</code> and above) Increase verbosity (-v: INFO, -vv: DEBUG) <code>0</code> <code>--debug</code> boolean Enable debug mode (DEBUG level, logs to ./launchsampler-debug.log) <code>False</code> <code>--log-file</code> path Custom log file path None <code>--log-level</code> choice (<code>DEBUG</code> | <code>INFO</code> | <code>WARNING</code> | <code>ERROR</code>) Log level for file logging (default: INFO) <code>INFO</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-audio","title":"launchsampler audio","text":"<p>Audio device commands.</p> <p>Usage:</p> <pre><code>launchsampler audio [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-audio-list","title":"launchsampler audio list","text":"<p>List available audio output devices.</p> <p>Usage:</p> <pre><code>launchsampler audio list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--all</code> boolean Show all audio devices, not just low-latency ones <code>False</code> <code>--detailed</code> boolean Show detailed device information <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-config","title":"launchsampler config","text":"<p>Configure Launchpad Sampler settings</p> <p>Usage:</p> <pre><code>launchsampler config [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--field</code>, <code>-f</code> text Show specific field instead of all fields None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-config-reset","title":"launchsampler config reset","text":"<p>Reset configuration to defaults.</p> <p>FIELDS: Optional field names to reset (resets all if not specified)</p> <p>Usage:</p> <pre><code>launchsampler config reset [OPTIONS] [FIELDS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--yes</code> boolean Confirm the action without prompting. <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-config-set","title":"launchsampler config set","text":"<p>Set one or more model field values.</p> <p>Usage:</p> <pre><code>launchsampler config set [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--sets-dir</code> path Directory where sample sets are stored (default: PydanticUndefined) None <code>--default-audio-device</code>, <code>-a</code> integer Audio device ID or use \"reset --field default_audio_device\" for system default None <code>--default-buffer-size</code>, <code>-b</code> integer Audio buffer size in frames (larger = more stable, higher latency) (default: 512) None <code>--midi-poll-interval</code> float MIDI polling interval in seconds (default: 2.0) None <code>--panic-button-cc-control</code> integer MIDI CC control number for panic button (stop all audio) (default: 19) None <code>--panic-button-cc-value</code> integer MIDI CC value for panic button trigger (default: 127) None <code>--last-set</code> text Last loaded set name None <code>--auto-save</code> boolean Automatically save sets after changes (default: True) None <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-config-validate","title":"launchsampler config validate","text":"<p>Validate the model configuration file.</p> <p>FIELDS: Optional field names to validate (validates all if not specified)</p> <p>Usage:</p> <pre><code>launchsampler config validate [OPTIONS] [FIELDS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-midi","title":"launchsampler midi","text":"<p>MIDI device commands.</p> <p>Usage:</p> <pre><code>launchsampler midi [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-midi-list","title":"launchsampler midi list","text":"<p>List available MIDI ports.</p> <p>Usage:</p> <pre><code>launchsampler midi list [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-midi-monitor","title":"launchsampler midi monitor","text":"<p>Monitor all MIDI input ports and log incoming messages.</p> <p>Connects to all available MIDI input ports and displays messages in real-time. Useful for debugging and testing.</p> <p>Press Ctrl+C to stop monitoring.</p> <p>Usage:</p> <pre><code>launchsampler midi monitor [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--filter-clock</code> / <code>--no-filter-clock</code> boolean Filter out clock messages (default: enabled) <code>True</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"cli-reference/#launchsampler-test","title":"launchsampler test","text":"<p>Test Launchpad lighting modes.</p> <p>Connects to a Launchpad, enters Programmer mode, and demonstrates static, flashing, pulsing, and RGB LED modes on various pads.</p> <p>Press Ctrl+C to stop and exit.</p> <p>Usage:</p> <pre><code>launchsampler test [OPTIONS]\n</code></pre> <p>Options:</p> Name Type Description Default <code>--verbose</code>, <code>-v</code> boolean Enable verbose logging <code>False</code> <code>--help</code> boolean Show this message and exit. <code>False</code>"},{"location":"license/","title":"License","text":"<p>LaunchSampler is released under the MIT License.</p>"},{"location":"license/#mit-license","title":"MIT License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 LaunchSampler Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>LaunchSampler uses the following open-source libraries:</p> <ul> <li>Textual - MIT License</li> <li>Pydantic - MIT License</li> <li>sounddevice - MIT License</li> <li>mido - MIT License</li> <li>numpy - BSD License</li> <li>click - BSD License</li> </ul> <p>See each package's license file for full details.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps you resolve common issues with LaunchSampler.</p>"},{"location":"troubleshooting/#logging-and-diagnostics","title":"Logging and Diagnostics","text":""},{"location":"troubleshooting/#enabling-debug-logging","title":"Enabling Debug Logging","text":"<p>When troubleshooting issues, enable debug logging to capture detailed information:</p> <pre><code>launchsampler --debug\n</code></pre> <p>This creates <code>launchsampler-debug.log</code> in your current directory with detailed diagnostic information.</p> <p>For more information about logging options, see the Logging section in Configuration.</p>"},{"location":"troubleshooting/#permission-errors-linux","title":"Permission Errors (Linux)","text":"<p>On Linux, you may need to add your user to the <code>audio</code> group:</p> <pre><code>sudo usermod -a -G audio $USER\n</code></pre> <p>Then log out and log back in for changes to take effect.</p>"},{"location":"troubleshooting/#audio-issues","title":"Audio Issues","text":""},{"location":"troubleshooting/#audio-dropouts-glitches","title":"Audio Dropouts / Glitches","text":"<p>Symptoms: Crackling, popping, or stuttering audio during playback.</p> <p>Solutions:</p> <ol> <li>Increase buffer size:</li> </ol> <pre><code>launchsampler config --buffer-size 1024\n</code></pre> <ol> <li> <p>Close other audio applications that might be competing for the audio device</p> </li> <li> <p>Use a dedicated audio interface if using built-in audio</p> </li> <li> <p>Check CPU usage - ensure other processes aren't consuming too much CPU</p> </li> </ol>"},{"location":"troubleshooting/#high-latency","title":"High Latency","text":"<p>Symptoms: Noticeable delay between pressing a pad and hearing the sample.</p> <p>Solutions:</p> <ol> <li> <p>Decrease buffer size (if your system can handle it):    <pre><code>launchsampler config --buffer-size 32\n</code></pre></p> </li> <li> <p>Use a better audio API:</p> </li> <li>Windows: ASIO &gt; WASAPI &gt; DirectSound &gt; MME</li> <li>macOS: CoreAudio (default)</li> <li> <p>Linux: ALSA &gt; PulseAudio</p> </li> <li> <p>Update audio drivers to the latest version</p> </li> <li> <p>Use a dedicated audio interface with ASIO support (Windows)</p> </li> </ol>"},{"location":"troubleshooting/#no-audio-output","title":"No Audio Output","text":"<p>Symptoms: No sound when triggering samples.</p> <p>Solutions:</p> <ol> <li> <p>Verify sample files exist and are valid audio files. When a file can't be loaded, it will be shown as unavailable.</p> </li> <li> <p>Revert to default audio device: <pre><code>launchsampler config --audio-device default\n</code></pre></p> </li> <li> <p>Check system volume and ensure LaunchSampler isn't muted</p> </li> <li> <p>Try a different audio device:    By default, the <code>audio list</code> command will only show low latency devices, you can see the full list with:    <pre><code>launchsampler audio list --all\n</code></pre>    Choose a different device ID</p> </li> <li> <p>Check logs for errors: <pre><code>launchsampler --debug\ncat launchsampler-debug.log | grep ERROR\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#wrong-audio-device","title":"Wrong Audio Device","text":"<p>Symptoms: Audio plays through wrong output (e.g., speakers instead of headphones).</p> <p>Solutions:</p> <ol> <li> <p>List available devices: <pre><code>launchsampler audio list\n</code></pre></p> </li> <li> <p>Set device explicitly in config: <pre><code>launchsampler config --audio-device 3\n</code></pre></p> </li> <li> <p>Restart LaunchSampler after changing config</p> </li> </ol>"},{"location":"troubleshooting/#audio-device-unavailable-changed","title":"Audio Device Unavailable / Changed","text":"<p>Symptoms: Configured audio device is no longer available (e.g., external interface unplugged, device ID changed).</p> <p>Automatic Fallback Behavior:</p> <p>LaunchSampler automatically handles invalid or unavailable audio devices with the following fallback sequence:</p> <ol> <li>Tries configured device (<code>default_audio_device</code> in config.json)</li> <li>Falls back to OS default if configured device is invalid</li> <li>Searches for any low-latency device if OS default doesn't support low-latency APIs</li> <li>Shows error only if NO valid low-latency devices are found</li> </ol>"},{"location":"troubleshooting/#audio-device-already-in-use","title":"Audio Device Already in Use","text":"<p>Symptoms: Application fails to start with error: <pre><code>Error opening OutputStream: Invalid device [PaErrorCode -9996]\n</code></pre></p> <p>Cause: The audio device is currently in use by another application or instance of LaunchSampler.</p> <p>Solutions:</p> <ol> <li>Check for running instances:</li> <li>Close any other running instances of LaunchSampler</li> <li> <p>Check task manager/activity monitor for multiple processes</p> </li> <li> <p>Close other audio applications:</p> </li> <li>Close DAWs, music players, or other audio software</li> <li> <p>Check system tray for hidden audio applications</p> </li> <li> <p>Restart audio services (if needed):</p> </li> </ol> <p>=== \"Windows\"        <pre><code># Restart Windows Audio service\nnet stop audiosrv &amp;&amp; net start audiosrv\n</code></pre></p> <p>=== \"macOS\"        <pre><code># Restart CoreAudio\nsudo killall coreaudiod\n</code></pre></p> <p>=== \"Linux\"        <pre><code># Kill processes using audio device\nsudo fuser -k /dev/snd/*\n\n# Or restart PulseAudio\npulseaudio -k &amp;&amp; pulseaudio --start\n</code></pre></p> <ol> <li> <p>Try a different audio device: <pre><code>launchsampler audio list\nlaunchsampler config --audio-device &lt;different-device-id&gt;\n</code></pre></p> </li> <li> <p>Reboot your computer to release all audio device locks</p> </li> </ol>"},{"location":"troubleshooting/#midi-issues","title":"MIDI Issues","text":""},{"location":"troubleshooting/#midi-device-not-detected","title":"MIDI Device Not Detected","text":"<p>Symptoms: Launchpad not recognized or not showing in device list.</p> <p>Solutions:</p> <ol> <li>Check USB connection:</li> <li>Ensure cable is properly connected</li> <li>Try a different USB port</li> <li> <p>Try a different USB cable</p> </li> <li> <p>List MIDI devices: <pre><code>launchsampler midi list\n</code></pre></p> </li> <li> <p>Install manufacturer drivers:</p> </li> <li>Download latest drivers from Novation website</li> <li> <p>Restart computer after installation</p> </li> <li> <p>Check device permissions (Linux): <pre><code>sudo usermod -a -G audio $USER\n# Log out and log back in\n</code></pre></p> </li> <li> <p>Verify device works in other software (e.g., DAW, Launchpad Arcade)</p> </li> </ol>"},{"location":"troubleshooting/#midi-notes-not-triggering-samples","title":"MIDI Notes Not Triggering Samples","text":"<p>Symptoms: Pressing Launchpad pads doesn't trigger samples in Play Mode.</p> <p>Solutions:</p> <ol> <li>Ensure you're in Play Mode:</li> <li>Press P to switch to Play Mode</li> <li> <p>Look for \"Play Mode\" in the status bar</p> </li> <li> <p>Check that pads have samples assigned:</p> </li> <li>Switch to Edit Mode (E)</li> <li> <p>Verify pads show sample information</p> </li> <li> <p>Monitor MIDI input: <pre><code>launchsampler midi monitor\n</code></pre>    Press pads - you should see MIDI messages</p> </li> <li> <p>Check MIDI routing:</p> </li> <li>Ensure no other application is capturing MIDI</li> <li> <p>Close DAWs or other MIDI software</p> </li> <li> <p>Enable debug logging: <pre><code>launchsampler --debug\n</code></pre>    Check for MIDI-related errors</p> </li> </ol>"},{"location":"troubleshooting/#launchpad-leds-not-updating","title":"Launchpad LEDs Not Updating","text":"<p>Symptoms: Launchpad LEDs don't light up or don't reflect pad states.</p> <p>Solutions:</p> <ol> <li>Check Launchpad mode:</li> <li>Some Launchpads have different modes</li> <li>Ensure it's in \"Programmer\" or \"Live\" mode</li> <li> <p>Refer to your Launchpad's manual</p> </li> <li> <p>Verify MIDI output connection: <pre><code>launchsampler midi list\n</code></pre>    Check that MIDI output port is detected</p> </li> <li> <p>Reset Launchpad:</p> </li> <li>Disconnect and reconnect USB</li> <li> <p>Power cycle if battery-powered</p> </li> <li> <p>Check logs for LED errors: <pre><code>launchsampler --debug\ngrep -i \"led\" launchsampler-debug.log\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#application-issues","title":"Application Issues","text":""},{"location":"troubleshooting/#application-wont-start","title":"Application Won't Start","text":"<p>Symptoms: LaunchSampler crashes or exits immediately on startup.</p> <p>Solutions:</p> <ol> <li> <p>Check Python version: <pre><code>python --version  # Should be 3.12 or higher\n</code></pre></p> </li> <li> <p>Enable debug logging: <pre><code>launchsampler --debug 2&gt;&amp;1 | tee startup-error.log\n</code></pre></p> </li> <li> <p>Verify installation: <pre><code>launchsampler --version\n</code></pre></p> </li> <li> <p>Reinstall dependencies: <pre><code># If using pipx\npipx reinstall launchsampler\n\n# If using uv\ncd launchsampler\nuv sync --reinstall\n</code></pre></p> </li> <li> <p>Check for conflicting packages: <pre><code>pip list | grep -i midi\npip list | grep -i audio\n</code></pre></p> </li> <li> <p>Try with minimal config: <pre><code># Backup existing config\nmv ~/.launchsampler/config.json ~/.launchsampler/config.json.bak\n\n# Start with defaults\nlaunchsampler\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#tui-display-issues","title":"TUI Display Issues","text":"<p>Symptoms: Garbled text, incorrect colors, or layout problems in the terminal.</p> <p>Solutions:</p> <ol> <li>Use a modern terminal:</li> <li>Windows: Windows Terminal (recommended)</li> <li>macOS: iTerm2 or Terminal.app</li> <li> <p>Linux: gnome-terminal, kitty, alacritty</p> </li> <li> <p>Check terminal size:</p> </li> <li>Ensure terminal is at least 80x24 characters</li> <li> <p>Resize terminal window</p> </li> <li> <p>Set correct locale: <pre><code>export LANG=en_US.UTF-8\nexport LC_ALL=en_US.UTF-8\n</code></pre></p> </li> <li> <p>Try a different terminal emulator</p> </li> <li> <p>Check terminal color support: <pre><code>echo $COLORTERM  # Should show \"truecolor\" or similar\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#application-freezes-or-becomes-unresponsive","title":"Application Freezes or Becomes Unresponsive","text":"<p>Symptoms: LaunchSampler stops responding to input.</p> <p>Solutions:</p> <ol> <li>Force quit:</li> <li>Press Ctrl+C in terminal</li> <li> <p>Or press Ctrl+Q in the TUI</p> </li> <li> <p>Check CPU usage: <pre><code># In another terminal\ntop -p $(pgrep -f launchsampler)\n</code></pre></p> </li> <li> <p>Check for blocking operations: <pre><code>launchsampler --debug\n# Look for operations that take too long\n</code></pre></p> </li> <li> <p>Reduce sample count:</p> </li> <li>Use fewer simultaneous samples</li> <li> <p>Reduce sample file sizes</p> </li> <li> <p>Increase buffer size to reduce CPU load:    <pre><code>{\n  \"default_buffer_size\": 1024\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#samples-not-loading","title":"Samples Not Loading","text":"<p>Symptoms: Error when loading samples from directory or set file.</p> <p>Solutions:</p> <ol> <li> <p>Check file permissions: <pre><code>ls -l /path/to/samples/\n</code></pre>    Ensure files are readable</p> </li> <li> <p>Verify file formats:</p> </li> <li>Supported: WAV, MP3, FLAC, OGG, AIFF</li> <li> <p>Check file extensions match actual format</p> </li> <li> <p>Check file paths:</p> </li> <li>Use absolute paths</li> <li>Ensure no special characters in paths</li> <li> <p>Avoid spaces in filenames (or use quotes)</p> </li> <li> <p>Verify sample directory exists: <pre><code>launchsampler --samples-dir /path/to/samples --debug\n</code></pre></p> </li> <li> <p>Check disk space: <pre><code>df -h\n</code></pre></p> </li> <li> <p>Look for loading errors in logs: <pre><code>grep -i \"load\" launchsampler-debug.log\ngrep -i \"sample\" launchsampler-debug.log\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#configuration-issues","title":"Configuration Issues","text":""},{"location":"troubleshooting/#config-file-not-found","title":"Config File Not Found","text":"<p>Symptoms: LaunchSampler can't find or load config file.</p> <p>Solutions:</p> <ol> <li>Check config location:</li> </ol> <p>=== \"Linux / macOS\"        <pre><code>ls -la ~/.launchsampler/config.json\n</code></pre></p> <p>=== \"Windows\"        <pre><code>dir %USERPROFILE%\\.launchsampler\\config.json\n</code></pre></p> <ol> <li> <p>Create config directory: <pre><code>mkdir -p ~/.launchsampler\n</code></pre></p> </li> <li> <p>Let LaunchSampler create default config: <pre><code>launchsampler\n# Will auto-create config.json\n</code></pre></p> </li> <li> <p>Manually create config: <pre><code>echo '{\"default_buffer_size\": 512}' &gt; ~/.launchsampler/config.json\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#invalid-config-values","title":"Invalid Config Values","text":"<p>Symptoms: Config validation errors on startup.</p> <p>Solutions:</p> <ol> <li> <p>Validate JSON syntax: <pre><code>python -m json.tool ~/.launchsampler/config.json\n</code></pre></p> </li> <li> <p>Reset to defaults: <pre><code>rm ~/.launchsampler/config.json\nlaunchsampler  # Will create new default config\n</code></pre></p> </li> <li> <p>Check value ranges:</p> </li> <li><code>default_buffer_size</code>: 128, 256, 512, 1024, or 2048</li> <li><code>default_audio_device</code>: Valid device ID from <code>launchsampler audio list</code></li> <li> <p><code>midi_poll_interval</code>: Any positive float (typically 0.5 to 5.0 seconds)</p> </li> <li> <p>Review config documentation:    See Configuration Guide for all valid options</p> </li> </ol>"},{"location":"troubleshooting/#logging-issues","title":"Logging Issues","text":"<p>For logging-specific troubleshooting (log files not created, empty logs, etc.), see the Logging Troubleshooting section in the Configuration guide.</p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-cpu-usage","title":"High CPU Usage","text":"<p>Symptoms: LaunchSampler consumes excessive CPU resources.</p> <p>Solutions:</p> <ol> <li> <p>Increase buffer size: <pre><code>{\n  \"default_buffer_size\": 1024\n}\n</code></pre></p> </li> <li> <p>Reduce simultaneous voices:</p> </li> <li>Use one-shot mode instead of loop</li> <li> <p>Limit number of playing samples</p> </li> <li> <p>Close other applications</p> </li> <li> <p>Check for debug logging:</p> </li> <li>Disable verbose logging in production</li> <li>Use default logging level (WARNING)</li> </ol>"},{"location":"troubleshooting/#slow-sample-loading","title":"Slow Sample Loading","text":"<p>Symptoms: Long delay when loading sets or samples.</p> <p>Solutions:</p> <ol> <li>Use smaller sample files:</li> <li>Convert to lower bit depth (16-bit instead of 24-bit)</li> <li> <p>Use compressed formats (MP3, OGG) for non-critical samples</p> </li> <li> <p>Reduce sample count:</p> </li> <li>Split large sets into multiple smaller sets</li> <li> <p>Load only needed samples</p> </li> <li> <p>Use SSD instead of HDD for sample storage</p> </li> <li> <p>Check disk I/O: <pre><code># Linux\niostat -x 1\n\n# macOS\niostat -w 1\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"troubleshooting/#windows","title":"Windows","text":""},{"location":"troubleshooting/#asio4all-not-working","title":"ASIO4ALL Not Working","text":"<p>Problem: ASIO4ALL driver not recognized.</p> <p>Solutions:</p> <ol> <li>Install ASIO4ALL:</li> <li>Download from http://www.asio4all.org/</li> <li> <p>Run installer as administrator</p> </li> <li> <p>Configure ASIO4ALL:</p> </li> <li>Open ASIO4ALL control panel</li> <li>Enable your audio device</li> <li> <p>Set buffer size</p> </li> <li> <p>Set in LaunchSampler config: <pre><code>{\n\n  \"default_audio_device\": 0\n}\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#permission-errors","title":"Permission Errors","text":"<p>Problem: Access denied errors when accessing files or devices.</p> <p>Solutions:</p> <ol> <li> <p>Run as administrator (only if necessary)</p> </li> <li> <p>Check file permissions in Windows Explorer</p> </li> <li> <p>Use user-writable locations: <pre><code>launchsampler --log-file %USERPROFILE%\\Desktop\\launchsampler.log\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#macos","title":"macOS","text":""},{"location":"troubleshooting/#coreaudio-issues","title":"CoreAudio Issues","text":"<p>Problem: Audio device not accessible or permission errors.</p> <p>Solutions:</p> <ol> <li>Grant microphone permission:</li> <li>System Preferences \u2192 Security &amp; Privacy \u2192 Microphone</li> <li> <p>Enable for Terminal or your terminal app</p> </li> <li> <p>Reset Core Audio: <pre><code>sudo killall coreaudiod\n</code></pre></p> </li> <li> <p>Check audio MIDI setup:</p> </li> <li>Open Audio MIDI Setup.app</li> <li>Verify device is recognized</li> </ol>"},{"location":"troubleshooting/#linux","title":"Linux","text":""},{"location":"troubleshooting/#alsa-errors","title":"ALSA Errors","text":"<p>Problem: \"Device or resource busy\" errors.</p> <p>Solutions:</p> <ol> <li> <p>Add user to audio group: <pre><code>sudo usermod -a -G audio $USER\n# Log out and log back in\n</code></pre></p> </li> <li> <p>Kill processes using audio device: <pre><code>sudo fuser -k /dev/snd/*\n</code></pre></p> </li> <li> <p>Use PulseAudio plugin: <pre><code>sudo apt-get install pulseaudio-utils\n</code></pre></p> </li> <li> <p>Check ALSA configuration: <pre><code>cat /proc/asound/cards\naplay -l\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#pulseaudio-issues","title":"PulseAudio Issues","text":"<p>Problem: No audio with PulseAudio.</p> <p>Solutions:</p> <ol> <li> <p>Restart PulseAudio: <pre><code>pulseaudio -k\npulseaudio --start\n</code></pre></p> </li> <li> <p>Check PulseAudio devices: <pre><code>pacmd list-sinks\n</code></pre></p> </li> <li> <p>Set default sink: <pre><code>pactl set-default-sink &lt;sink-name&gt;\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you can't resolve your issue:</p> <ol> <li> <p>Enable debug logging: <pre><code>launchsampler --debug\n</code></pre></p> </li> <li> <p>Gather system information: <pre><code>launchsampler --version\npython --version\nuname -a  # Linux/macOS\n</code></pre></p> </li> <li> <p>Check existing issues:</p> </li> <li> <p>GitHub Issues</p> </li> <li> <p>Create a new issue:</p> </li> <li>Include debug log (relevant portions)</li> <li>System information</li> <li>Steps to reproduce</li> <li> <p>Expected vs actual behavior</p> </li> <li> <p>Join the community:</p> </li> <li>GitHub Discussions</li> </ol>"},{"location":"troubleshooting/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Guide - Detailed config options and logging</li> <li>Installation - Install and verify setup</li> <li>User Guide - Learn how to use LaunchSampler</li> </ul>"},{"location":"api/audio/","title":"Audio","text":"<p>Low-level audio primitives and sample loading</p> <p>Audio engine for sample playback.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData","title":"<code>AudioData(data, sample_rate, num_channels, num_frames, format=None, subtype=None)</code>  <code>dataclass</code>","text":"<p>Raw audio data storage.</p> <p>This is kept separate from Pydantic models for performance. Contains the actual audio buffer that will be played back.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Duration in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of audio data array.</p>"},{"location":"api/audio/#launchsampler.audio.AudioData.from_array","title":"<code>from_array(data, sample_rate)</code>  <code>classmethod</code>","text":"<p>Create AudioData from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float32]</code> <p>Audio data as float32 array   Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData instance</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>@classmethod\ndef from_array(\n    cls,\n    data: npt.NDArray[np.float32],\n    sample_rate: int\n) -&gt; \"AudioData\":\n    \"\"\"\n    Create AudioData from a NumPy array.\n\n    Args:\n        data: Audio data as float32 array\n              Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel\n        sample_rate: Sample rate in Hz\n\n    Returns:\n        AudioData instance\n    \"\"\"\n    if data.ndim == 1:\n        # Mono audio\n        num_channels = 1\n        num_frames = len(data)\n    elif data.ndim == 2:\n        # Multi-channel audio\n        num_frames, num_channels = data.shape\n    else:\n        raise ValueError(f\"Audio data must be 1D or 2D, got {data.ndim}D\")\n\n    # Ensure float32 dtype\n    if data.dtype != np.float32:\n        data = data.astype(np.float32)\n\n    return cls(\n        data=data,\n        sample_rate=sample_rate,\n        num_channels=num_channels,\n        num_frames=num_frames\n    )\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.get_mono","title":"<code>get_mono()</code>","text":"<p>Get mono version of audio data.</p> <p>If already mono, returns original data. If stereo/multi-channel, returns average of all channels.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_mono(self) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Get mono version of audio data.\n\n    If already mono, returns original data.\n    If stereo/multi-channel, returns average of all channels.\n    \"\"\"\n    if self.num_channels == 1:\n        return self.data\n    else:\n        return np.mean(self.data, axis=1, dtype=np.float32)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.normalize","title":"<code>normalize(target_level=0.95)</code>","text":"<p>Normalize audio data to target level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target peak level (0.0 to 1.0)</p> <code>0.95</code> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def normalize(self, target_level: float = 0.95) -&gt; None:\n    \"\"\"\n    Normalize audio data to target level.\n\n    Args:\n        target_level: Target peak level (0.0 to 1.0)\n    \"\"\"\n    peak = np.abs(self.data).max()\n    if peak &gt; 0:\n        self.data *= (target_level / peak)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioData.get_info","title":"<code>get_info()</code>","text":"<p>Get comprehensive audio file information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with audio metadata including duration, sample rate, </p> <code>dict</code> <p>channels, format, file size, etc.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_info(self) -&gt; dict:\n    \"\"\"\n    Get comprehensive audio file information.\n\n    Returns:\n        Dictionary with audio metadata including duration, sample rate, \n        channels, format, file size, etc.\n    \"\"\"\n    # Calculate file size in bytes (based on loaded data in memory)\n    size_bytes = self.data.nbytes\n\n    info = {\n        'duration': self.duration,\n        'sample_rate': self.sample_rate,\n        'num_channels': self.num_channels,\n        'num_frames': self.num_frames,\n        'size_bytes': size_bytes,\n        'size_str': format_bytes(size_bytes),\n    }\n\n    # Add format info if available\n    if self.format:\n        info['format'] = self.format\n    if self.subtype:\n        info['subtype'] = self.subtype\n\n    return info\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState","title":"<code>PlaybackState(is_playing=False, position=0.0, mode=PlaybackMode.ONE_SHOT, volume=1.0, audio_data=None)</code>  <code>dataclass</code>","text":"<p>Runtime playback state for a single pad.</p> <p>This is NOT a Pydantic model because it's purely internal state that changes rapidly during audio playback and should have minimal overhead.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Get playback progress as fraction (0.0 to 1.0).</p> <p>Returns 0.0 if no audio data.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.time_elapsed","title":"<code>time_elapsed</code>  <code>property</code>","text":"<p>Get elapsed playback time in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.time_remaining","title":"<code>time_remaining</code>  <code>property</code>","text":"<p>Get remaining playback time in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.start","title":"<code>start()</code>","text":"<p>Start playback from the beginning.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start playback from the beginning.\"\"\"\n    if self.audio_data is None:\n        raise ValueError(\"Cannot start playback without audio data\")\n\n    self.is_playing = True\n    self.position = 0.0\n    self._loop_count = 0\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.stop","title":"<code>stop()</code>","text":"<p>Stop playback.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop playback.\"\"\"\n    self.is_playing = False\n    # Reset toggle state when stopping\n    if self.mode == PlaybackMode.LOOP_TOGGLE:\n        self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.reset","title":"<code>reset()</code>","text":"<p>Reset to initial state.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to initial state.\"\"\"\n    self.is_playing = False\n    self.position = 0.0\n    self._loop_count = 0\n    self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.advance","title":"<code>advance(num_frames)</code>","text":"<p>Advance playback position by num_frames.</p> <p>Handles looping and stopping based on playback mode.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to advance</p> required Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def advance(self, num_frames: int) -&gt; None:\n    \"\"\"\n    Advance playback position by num_frames.\n\n    Handles looping and stopping based on playback mode.\n\n    Args:\n        num_frames: Number of frames to advance\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return\n\n    self.position += num_frames\n\n    # Check if we've reached the end\n    if self.position &gt;= self.audio_data.num_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Loop back to start\n            self.position = self.position % self.audio_data.num_frames\n            self._loop_count += 1\n        else:\n            # ONE_SHOT or HOLD - stop at end\n            self.stop()\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.PlaybackState.get_frames","title":"<code>get_frames(num_frames)</code>","text":"<p>Get next audio frames for playback.</p> <p>Handles seamless looping when in LOOP mode by wrapping around the end of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to get</p> required <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Audio frames as float32 array, or None if not playing</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_frames(self, num_frames: int) -&gt; Optional[npt.NDArray[np.float32]]:\n    \"\"\"\n    Get next audio frames for playback.\n\n    Handles seamless looping when in LOOP mode by wrapping around\n    the end of the buffer.\n\n    Args:\n        num_frames: Number of frames to get\n\n    Returns:\n        Audio frames as float32 array, or None if not playing\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return None\n\n    start_pos = int(self.position)\n    total_frames = self.audio_data.num_frames\n\n    # Handle end of buffer for non-loop modes\n    if start_pos &gt;= total_frames:\n        return None\n\n    end_pos = start_pos + num_frames\n\n    # Check if we need to wrap around (for LOOP mode)\n    if end_pos &gt; total_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Seamlessly wrap around for looping\n            # Get frames from current position to end\n            if self.audio_data.num_channels == 1:\n                first_part = self.audio_data.data[start_pos:total_frames]\n            else:\n                first_part = self.audio_data.data[start_pos:total_frames, :]\n\n            # Calculate how many frames we need from the beginning\n            remaining_frames = num_frames - (total_frames - start_pos)\n\n            # Get frames from beginning\n            if self.audio_data.num_channels == 1:\n                second_part = self.audio_data.data[0:remaining_frames]\n                frames = np.concatenate([first_part, second_part])\n            else:\n                second_part = self.audio_data.data[0:remaining_frames, :]\n                frames = np.concatenate([first_part, second_part], axis=0)\n        else:\n            # For ONE_SHOT and HOLD, truncate at end\n            end_pos = total_frames\n            if self.audio_data.num_channels == 1:\n                frames = self.audio_data.data[start_pos:end_pos]\n            else:\n                frames = self.audio_data.data[start_pos:end_pos, :]\n    else:\n        # Normal case - extract frames\n        if self.audio_data.num_channels == 1:\n            frames = self.audio_data.data[start_pos:end_pos]\n        else:\n            frames = self.audio_data.data[start_pos:end_pos, :]\n\n    # Apply volume\n    if self.volume != 1.0:\n        frames = frames * self.volume\n\n    return frames\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice","title":"<code>AudioDevice(buffer_size=128, num_channels=2, device=None)</code>","text":"<p>Generic low-latency audio output device and stream management.</p> <p>Handles device querying, validation, and stream lifecycle. No application-specific logic - purely generic audio I/O.</p> <p>Initialize audio device.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>Audio buffer size in frames (lower = less latency)</p> <code>128</code> <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> <code>device</code> <code>Optional[int]</code> <p>Output device ID (None for default)</p> <code>None</code> Note <p>If the specified device is invalid or unavailable, falls back to the system default device with a warning.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __init__(\n    self,\n    buffer_size: int = 128,\n    num_channels: int = 2,\n    device: Optional[int] = None\n):\n    \"\"\"\n    Initialize audio device.\n\n    Args:\n        buffer_size: Audio buffer size in frames (lower = less latency)\n        num_channels: Number of output channels (1=mono, 2=stereo)\n        device: Output device ID (None for default)\n\n    Note:\n        If the specified device is invalid or unavailable, falls back to\n        the system default device with a warning.\n    \"\"\"\n    self.buffer_size = buffer_size\n    self.num_channels = num_channels\n\n    # Validate device if specified, fall back to default if invalid\n    if device is not None:\n        try:\n            self._validate_device(device)\n            self.device = device\n        except (ValueError, Exception) as e:\n            logger.warning(\n                f\"Configured audio device (ID: {device}) is invalid or unavailable: {e}. \"\n                f\"Falling back to system default device.\"\n            )\n            self.device = None\n    else:\n        self.device = None\n\n    # Stream state\n    self._stream: Optional[sd.OutputStream] = None\n    self._is_running = False\n    self._callback: Optional[Callable[[np.ndarray, int], None]] = None\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio stream is running.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.latency","title":"<code>latency</code>  <code>property</code>","text":"<p>Get current stream latency in seconds.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.sample_rate","title":"<code>sample_rate</code>  <code>property</code>","text":"<p>Get current sample rate from the device.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the name of the current audio device.</p>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.set_callback","title":"<code>set_callback(callback)</code>","text":"<p>Set audio callback function.</p> <p>The callback will be called with (outdata, frames) for each audio block.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ndarray, int], None]</code> <p>Function(outdata: np.ndarray, frames: int) -&gt; None</p> required Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def set_callback(self, callback: Callable[[np.ndarray, int], None]) -&gt; None:\n    \"\"\"\n    Set audio callback function.\n\n    The callback will be called with (outdata, frames) for each audio block.\n\n    Args:\n        callback: Function(outdata: np.ndarray, frames: int) -&gt; None\n    \"\"\"\n    self._callback = callback\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.start","title":"<code>start()</code>","text":"<p>Start audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio stream.\"\"\"\n    if self._is_running:\n        return\n\n    if self._callback is None:\n        raise RuntimeError(\"No audio callback set. Call set_callback() first.\")\n\n    device_id = self.device or sd.default.device[1]\n\n    # Try to find a valid low-latency device\n    device_id = self._find_valid_device(device_id)\n\n    # Update self.device to the validated device ID\n    self.device = device_id\n\n    self._log_device_info(device_id)\n\n    # Select stream configuration\n    stream_kwargs = self._get_stream_config(device_id)\n\n    # Try to start the stream\n    self._start_stream(stream_kwargs)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.stop","title":"<code>stop()</code>","text":"<p>Stop audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio stream.\"\"\"\n    if not self._is_running:\n        return\n\n    if self._stream:\n        self._stream.stop()\n        self._stream.close()\n        self._stream = None\n\n    self._is_running = False\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.list_output_devices","title":"<code>list_output_devices(all_devices=False)</code>  <code>staticmethod</code>","text":"<p>List available audio output devices.</p> <p>Parameters:</p> Name Type Description Default <code>all_devices</code> <code>bool</code> <p>If True, list all devices. If False, only low-latency devices.</p> <code>False</code> <p>On Windows (low-latency only): ASIO and WASAPI devices On macOS (low-latency only): Core Audio devices On Linux (low-latency only): ALSA and JACK devices</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str, str, Any]]</code> <p>Tuple of (devices, api_names) where:</p> <code>str</code> <ul> <li>devices: List of tuples (device_id, device_name, host_api_name, device_info)</li> </ul> <code>Tuple[List[Tuple[int, str, str, Any]], str]</code> <ul> <li>api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")</li> </ul> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef list_output_devices(all_devices: bool = False) -&gt; Tuple[List[Tuple[int, str, str, Any]], str]:\n    \"\"\"\n    List available audio output devices.\n\n    Args:\n        all_devices: If True, list all devices. If False, only low-latency devices.\n\n    On Windows (low-latency only): ASIO and WASAPI devices\n    On macOS (low-latency only): Core Audio devices\n    On Linux (low-latency only): ALSA and JACK devices\n\n    Returns:\n        Tuple of (devices, api_names) where:\n        - devices: List of tuples (device_id, device_name, host_api_name, device_info)\n        - api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")\n    \"\"\"\n    devices = sd.query_devices()\n    hostapis = sd.query_hostapis()\n\n    low_latency_apis, api_names = AudioDevice._get_platform_apis()\n    available_devices = []\n\n    for i, device in enumerate(devices):\n        if device['max_output_channels'] &gt; 0:\n            hostapi = hostapis[device['hostapi']]\n            hostapi_name = hostapi['name']\n\n            if all_devices or any(api in hostapi_name for api in low_latency_apis):\n                available_devices.append((i, device['name'], hostapi_name, device))\n\n    return available_devices, api_names\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.get_devices_by_host_api","title":"<code>get_devices_by_host_api(all_devices=False)</code>  <code>staticmethod</code>","text":"<p>Get audio output devices grouped by host API.</p> <p>Parameters:</p> Name Type Description Default <code>all_devices</code> <code>bool</code> <p>If True, include all devices. If False, only low-latency devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, List[Tuple[int, str, Any]]]</code> <p>Dictionary mapping host API name to list of (device_id, device_name, device_info) tuples</p> Example <p>{     \"Windows WASAPI\": [(2, \"Speakers\", {...}), (3, \"Headphones\", {...})],     \"MME\": [(0, \"Speakers\", {...}), (1, \"Headphones\", {...})] }</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_devices_by_host_api(all_devices: bool = False) -&gt; dict[str, List[Tuple[int, str, Any]]]:\n    \"\"\"\n    Get audio output devices grouped by host API.\n\n    Args:\n        all_devices: If True, include all devices. If False, only low-latency devices.\n\n    Returns:\n        Dictionary mapping host API name to list of (device_id, device_name, device_info) tuples\n\n    Example:\n        {\n            \"Windows WASAPI\": [(2, \"Speakers\", {...}), (3, \"Headphones\", {...})],\n            \"MME\": [(0, \"Speakers\", {...}), (1, \"Headphones\", {...})]\n        }\n    \"\"\"\n    devices, _ = AudioDevice.list_output_devices(all_devices=all_devices)\n\n    devices_by_api = {}\n    for device_id, name, host_api, info in devices:\n        if host_api not in devices_by_api:\n            devices_by_api[host_api] = []\n        devices_by_api[host_api].append((device_id, name, info))\n\n    return devices_by_api\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.get_default_device","title":"<code>get_default_device()</code>  <code>staticmethod</code>","text":"<p>Get default output device ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>Device ID</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_default_device() -&gt; int:\n    \"\"\"\n    Get default output device ID.\n\n    Returns:\n        Device ID\n    \"\"\"\n    return sd.default.device[1]  # Output device\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.get_all_host_apis","title":"<code>get_all_host_apis()</code>  <code>staticmethod</code>","text":"<p>Get all available host APIs.</p> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of host API info dictionaries</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_all_host_apis() -&gt; List[dict]:\n    \"\"\"\n    Get all available host APIs.\n\n    Returns:\n        List of host API info dictionaries\n    \"\"\"\n    return sd.query_hostapis()\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioDevice.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader","title":"<code>SampleLoader(target_sample_rate=None)</code>","text":"<p>Load audio files into AudioData structures.</p> <p>Handles WAV, FLAC, OGG, and other formats supported by soundfile.</p> <p>Initialize sample loader.</p> <p>Parameters:</p> Name Type Description Default <code>target_sample_rate</code> <code>Optional[int]</code> <p>If set, resample all audio to this rate.                If None, use original sample rate.</p> <code>None</code> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def __init__(self, target_sample_rate: Optional[int] = None):\n    \"\"\"\n    Initialize sample loader.\n\n    Args:\n        target_sample_rate: If set, resample all audio to this rate.\n                           If None, use original sample rate.\n    \"\"\"\n    self.target_sample_rate = target_sample_rate\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader.load","title":"<code>load(path)</code>","text":"<p>Load audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData containing the loaded audio</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>RuntimeError</code> <p>If file cannot be loaded</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def load(self, path: Path) -&gt; AudioData:\n    \"\"\"\n    Load audio file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        AudioData containing the loaded audio\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        RuntimeError: If file cannot be loaded\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    try:\n        # Get file info for metadata\n        info = sf.info(str(path))\n\n        # Load audio file\n        data, sample_rate = sf.read(str(path), dtype='float32')\n\n        # Handle empty files\n        if len(data) == 0:\n            raise RuntimeError(f\"Audio file is empty: {path}\")\n\n        # Resample if needed\n        if self.target_sample_rate and sample_rate != self.target_sample_rate:\n            data = self._resample(data, sample_rate, self.target_sample_rate)\n            sample_rate = self.target_sample_rate\n\n        # Create AudioData with metadata\n        audio_data = AudioData.from_array(data, sample_rate)\n        audio_data.format = info.format\n        audio_data.subtype = info.subtype\n        return audio_data\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load audio file {path}: {e}\") from e\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.SampleLoader.get_info","title":"<code>get_info(path)</code>  <code>staticmethod</code>","text":"<p>Get audio file info without loading the full file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'sample_rate', 'channels', 'frames', 'duration'</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>@staticmethod\ndef get_info(path: Path) -&gt; dict:\n    \"\"\"\n    Get audio file info without loading the full file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        Dictionary with 'sample_rate', 'channels', 'frames', 'duration'\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    info = sf.info(str(path))\n    return {\n        'sample_rate': info.samplerate,\n        'channels': info.channels,\n        'frames': info.frames,\n        'duration': info.duration,\n        'format': info.format,\n        'subtype': info.subtype,\n    }\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer","title":"<code>AudioMixer(num_channels=2)</code>","text":"<p>Mix multiple audio sources into a single output.</p> <p>Thread-safe for use in audio callbacks.</p> <p>Initialize audio mixer.</p> <p>Parameters:</p> Name Type Description Default <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def __init__(self, num_channels: int = 2):\n    \"\"\"\n    Initialize audio mixer.\n\n    Args:\n        num_channels: Number of output channels (1=mono, 2=stereo)\n    \"\"\"\n    self.num_channels = num_channels\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.mix","title":"<code>mix(playback_states, num_frames)</code>","text":"<p>Mix multiple playback states into a single buffer.</p> <p>Parameters:</p> Name Type Description Default <code>playback_states</code> <code>List[PlaybackState]</code> <p>List of PlaybackState objects to mix</p> required <code>num_frames</code> <code>int</code> <p>Number of frames to generate</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono</p> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def mix(\n    self,\n    playback_states: List[PlaybackState],\n    num_frames: int\n) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Mix multiple playback states into a single buffer.\n\n    Args:\n        playback_states: List of PlaybackState objects to mix\n        num_frames: Number of frames to generate\n\n    Returns:\n        Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono\n    \"\"\"\n    # Create output buffer\n    if self.num_channels == 1:\n        output = np.zeros(num_frames, dtype=np.float32)\n    else:\n        output = np.zeros((num_frames, self.num_channels), dtype=np.float32)\n\n    # Mix each playing source\n    for state in playback_states:\n        if not state.is_playing or state.audio_data is None:\n            continue\n\n        # Get frames from this source\n        frames = state.get_frames(num_frames)\n        if frames is None:\n            continue\n\n        # Handle channel mismatch\n        frames_to_add = self._match_channels(frames, state.audio_data.num_channels)\n\n        # Add to output (clip to available length)\n        add_length = min(len(frames_to_add), num_frames)\n        if self.num_channels == 1:\n            output[:add_length] += frames_to_add[:add_length]\n        else:\n            output[:add_length, :] += frames_to_add[:add_length, :]\n\n        # Advance the playback position\n        state.advance(add_length)\n\n    return output\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.apply_master_volume","title":"<code>apply_master_volume(buffer, volume)</code>  <code>staticmethod</code>","text":"<p>Apply master volume to buffer in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to modify</p> required <code>volume</code> <code>float</code> <p>Volume multiplier (0.0 to 1.0)</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef apply_master_volume(\n    buffer: npt.NDArray[np.float32],\n    volume: float\n) -&gt; None:\n    \"\"\"\n    Apply master volume to buffer in-place.\n\n    Args:\n        buffer: Audio buffer to modify\n        volume: Volume multiplier (0.0 to 1.0)\n    \"\"\"\n    if volume != 1.0:\n        buffer *= volume\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.clip","title":"<code>clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Clip audio buffer to valid range [-1.0, 1.0] in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Clip audio buffer to valid range [-1.0, 1.0] in-place.\n\n    Args:\n        buffer: Audio buffer to clip\n    \"\"\"\n    np.clip(buffer, -1.0, 1.0, out=buffer)\n</code></pre>"},{"location":"api/audio/#launchsampler.audio.AudioMixer.soft_clip","title":"<code>soft_clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Apply soft clipping (tanh) to prevent harsh distortion.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to soft clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef soft_clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Apply soft clipping (tanh) to prevent harsh distortion.\n\n    Args:\n        buffer: Audio buffer to soft clip\n    \"\"\"\n    np.tanh(buffer, out=buffer)\n</code></pre>"},{"location":"api/audio/data/","title":"Data","text":""},{"location":"api/audio/data/#launchsampler.audio.data","title":"<code>data</code>","text":"<p>Audio data structures using dataclasses for performance.</p> <p>These dataclasses store actual audio data (NumPy arrays) and runtime state. They are NOT Pydantic models because: - They contain non-serializable data (NumPy arrays) - They need minimal overhead for real-time audio processing - They are internal to the audio engine, not part of the API</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData","title":"<code>AudioData(data, sample_rate, num_channels, num_frames, format=None, subtype=None)</code>  <code>dataclass</code>","text":"<p>Raw audio data storage.</p> <p>This is kept separate from Pydantic models for performance. Contains the actual audio buffer that will be played back.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Duration in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Shape of audio data array.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.from_array","title":"<code>from_array(data, sample_rate)</code>  <code>classmethod</code>","text":"<p>Create AudioData from a NumPy array.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float32]</code> <p>Audio data as float32 array   Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel</p> required <code>sample_rate</code> <code>int</code> <p>Sample rate in Hz</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData instance</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>@classmethod\ndef from_array(\n    cls,\n    data: npt.NDArray[np.float32],\n    sample_rate: int\n) -&gt; \"AudioData\":\n    \"\"\"\n    Create AudioData from a NumPy array.\n\n    Args:\n        data: Audio data as float32 array\n              Shape: (num_frames,) for mono or (num_frames, num_channels) for multi-channel\n        sample_rate: Sample rate in Hz\n\n    Returns:\n        AudioData instance\n    \"\"\"\n    if data.ndim == 1:\n        # Mono audio\n        num_channels = 1\n        num_frames = len(data)\n    elif data.ndim == 2:\n        # Multi-channel audio\n        num_frames, num_channels = data.shape\n    else:\n        raise ValueError(f\"Audio data must be 1D or 2D, got {data.ndim}D\")\n\n    # Ensure float32 dtype\n    if data.dtype != np.float32:\n        data = data.astype(np.float32)\n\n    return cls(\n        data=data,\n        sample_rate=sample_rate,\n        num_channels=num_channels,\n        num_frames=num_frames\n    )\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.get_mono","title":"<code>get_mono()</code>","text":"<p>Get mono version of audio data.</p> <p>If already mono, returns original data. If stereo/multi-channel, returns average of all channels.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_mono(self) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Get mono version of audio data.\n\n    If already mono, returns original data.\n    If stereo/multi-channel, returns average of all channels.\n    \"\"\"\n    if self.num_channels == 1:\n        return self.data\n    else:\n        return np.mean(self.data, axis=1, dtype=np.float32)\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.normalize","title":"<code>normalize(target_level=0.95)</code>","text":"<p>Normalize audio data to target level.</p> <p>Parameters:</p> Name Type Description Default <code>target_level</code> <code>float</code> <p>Target peak level (0.0 to 1.0)</p> <code>0.95</code> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def normalize(self, target_level: float = 0.95) -&gt; None:\n    \"\"\"\n    Normalize audio data to target level.\n\n    Args:\n        target_level: Target peak level (0.0 to 1.0)\n    \"\"\"\n    peak = np.abs(self.data).max()\n    if peak &gt; 0:\n        self.data *= (target_level / peak)\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.AudioData.get_info","title":"<code>get_info()</code>","text":"<p>Get comprehensive audio file information.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with audio metadata including duration, sample rate, </p> <code>dict</code> <p>channels, format, file size, etc.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_info(self) -&gt; dict:\n    \"\"\"\n    Get comprehensive audio file information.\n\n    Returns:\n        Dictionary with audio metadata including duration, sample rate, \n        channels, format, file size, etc.\n    \"\"\"\n    # Calculate file size in bytes (based on loaded data in memory)\n    size_bytes = self.data.nbytes\n\n    info = {\n        'duration': self.duration,\n        'sample_rate': self.sample_rate,\n        'num_channels': self.num_channels,\n        'num_frames': self.num_frames,\n        'size_bytes': size_bytes,\n        'size_str': format_bytes(size_bytes),\n    }\n\n    # Add format info if available\n    if self.format:\n        info['format'] = self.format\n    if self.subtype:\n        info['subtype'] = self.subtype\n\n    return info\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState","title":"<code>PlaybackState(is_playing=False, position=0.0, mode=PlaybackMode.ONE_SHOT, volume=1.0, audio_data=None)</code>  <code>dataclass</code>","text":"<p>Runtime playback state for a single pad.</p> <p>This is NOT a Pydantic model because it's purely internal state that changes rapidly during audio playback and should have minimal overhead.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Get playback progress as fraction (0.0 to 1.0).</p> <p>Returns 0.0 if no audio data.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.time_elapsed","title":"<code>time_elapsed</code>  <code>property</code>","text":"<p>Get elapsed playback time in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.time_remaining","title":"<code>time_remaining</code>  <code>property</code>","text":"<p>Get remaining playback time in seconds.</p>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.start","title":"<code>start()</code>","text":"<p>Start playback from the beginning.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start playback from the beginning.\"\"\"\n    if self.audio_data is None:\n        raise ValueError(\"Cannot start playback without audio data\")\n\n    self.is_playing = True\n    self.position = 0.0\n    self._loop_count = 0\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.stop","title":"<code>stop()</code>","text":"<p>Stop playback.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop playback.\"\"\"\n    self.is_playing = False\n    # Reset toggle state when stopping\n    if self.mode == PlaybackMode.LOOP_TOGGLE:\n        self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.reset","title":"<code>reset()</code>","text":"<p>Reset to initial state.</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset to initial state.\"\"\"\n    self.is_playing = False\n    self.position = 0.0\n    self._loop_count = 0\n    self._loop_toggle_state = False\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.advance","title":"<code>advance(num_frames)</code>","text":"<p>Advance playback position by num_frames.</p> <p>Handles looping and stopping based on playback mode.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to advance</p> required Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def advance(self, num_frames: int) -&gt; None:\n    \"\"\"\n    Advance playback position by num_frames.\n\n    Handles looping and stopping based on playback mode.\n\n    Args:\n        num_frames: Number of frames to advance\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return\n\n    self.position += num_frames\n\n    # Check if we've reached the end\n    if self.position &gt;= self.audio_data.num_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Loop back to start\n            self.position = self.position % self.audio_data.num_frames\n            self._loop_count += 1\n        else:\n            # ONE_SHOT or HOLD - stop at end\n            self.stop()\n</code></pre>"},{"location":"api/audio/data/#launchsampler.audio.data.PlaybackState.get_frames","title":"<code>get_frames(num_frames)</code>","text":"<p>Get next audio frames for playback.</p> <p>Handles seamless looping when in LOOP mode by wrapping around the end of the buffer.</p> <p>Parameters:</p> Name Type Description Default <code>num_frames</code> <code>int</code> <p>Number of frames to get</p> required <p>Returns:</p> Type Description <code>Optional[NDArray[float32]]</code> <p>Audio frames as float32 array, or None if not playing</p> Source code in <code>src/launchsampler/audio/data.py</code> <pre><code>def get_frames(self, num_frames: int) -&gt; Optional[npt.NDArray[np.float32]]:\n    \"\"\"\n    Get next audio frames for playback.\n\n    Handles seamless looping when in LOOP mode by wrapping around\n    the end of the buffer.\n\n    Args:\n        num_frames: Number of frames to get\n\n    Returns:\n        Audio frames as float32 array, or None if not playing\n    \"\"\"\n    if not self.is_playing or self.audio_data is None:\n        return None\n\n    start_pos = int(self.position)\n    total_frames = self.audio_data.num_frames\n\n    # Handle end of buffer for non-loop modes\n    if start_pos &gt;= total_frames:\n        return None\n\n    end_pos = start_pos + num_frames\n\n    # Check if we need to wrap around (for LOOP mode)\n    if end_pos &gt; total_frames:\n        if self.mode == PlaybackMode.LOOP or self.mode == PlaybackMode.LOOP_TOGGLE:\n            # Seamlessly wrap around for looping\n            # Get frames from current position to end\n            if self.audio_data.num_channels == 1:\n                first_part = self.audio_data.data[start_pos:total_frames]\n            else:\n                first_part = self.audio_data.data[start_pos:total_frames, :]\n\n            # Calculate how many frames we need from the beginning\n            remaining_frames = num_frames - (total_frames - start_pos)\n\n            # Get frames from beginning\n            if self.audio_data.num_channels == 1:\n                second_part = self.audio_data.data[0:remaining_frames]\n                frames = np.concatenate([first_part, second_part])\n            else:\n                second_part = self.audio_data.data[0:remaining_frames, :]\n                frames = np.concatenate([first_part, second_part], axis=0)\n        else:\n            # For ONE_SHOT and HOLD, truncate at end\n            end_pos = total_frames\n            if self.audio_data.num_channels == 1:\n                frames = self.audio_data.data[start_pos:end_pos]\n            else:\n                frames = self.audio_data.data[start_pos:end_pos, :]\n    else:\n        # Normal case - extract frames\n        if self.audio_data.num_channels == 1:\n            frames = self.audio_data.data[start_pos:end_pos]\n        else:\n            frames = self.audio_data.data[start_pos:end_pos, :]\n\n    # Apply volume\n    if self.volume != 1.0:\n        frames = frames * self.volume\n\n    return frames\n</code></pre>"},{"location":"api/audio/device/","title":"Device","text":""},{"location":"api/audio/device/#launchsampler.audio.device","title":"<code>device</code>","text":"<p>Generic audio device and stream management.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice","title":"<code>AudioDevice(buffer_size=128, num_channels=2, device=None)</code>","text":"<p>Generic low-latency audio output device and stream management.</p> <p>Handles device querying, validation, and stream lifecycle. No application-specific logic - purely generic audio I/O.</p> <p>Initialize audio device.</p> <p>Parameters:</p> Name Type Description Default <code>buffer_size</code> <code>int</code> <p>Audio buffer size in frames (lower = less latency)</p> <code>128</code> <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> <code>device</code> <code>Optional[int]</code> <p>Output device ID (None for default)</p> <code>None</code> Note <p>If the specified device is invalid or unavailable, falls back to the system default device with a warning.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __init__(\n    self,\n    buffer_size: int = 128,\n    num_channels: int = 2,\n    device: Optional[int] = None\n):\n    \"\"\"\n    Initialize audio device.\n\n    Args:\n        buffer_size: Audio buffer size in frames (lower = less latency)\n        num_channels: Number of output channels (1=mono, 2=stereo)\n        device: Output device ID (None for default)\n\n    Note:\n        If the specified device is invalid or unavailable, falls back to\n        the system default device with a warning.\n    \"\"\"\n    self.buffer_size = buffer_size\n    self.num_channels = num_channels\n\n    # Validate device if specified, fall back to default if invalid\n    if device is not None:\n        try:\n            self._validate_device(device)\n            self.device = device\n        except (ValueError, Exception) as e:\n            logger.warning(\n                f\"Configured audio device (ID: {device}) is invalid or unavailable: {e}. \"\n                f\"Falling back to system default device.\"\n            )\n            self.device = None\n    else:\n        self.device = None\n\n    # Stream state\n    self._stream: Optional[sd.OutputStream] = None\n    self._is_running = False\n    self._callback: Optional[Callable[[np.ndarray, int], None]] = None\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio stream is running.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.latency","title":"<code>latency</code>  <code>property</code>","text":"<p>Get current stream latency in seconds.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.sample_rate","title":"<code>sample_rate</code>  <code>property</code>","text":"<p>Get current sample rate from the device.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the name of the current audio device.</p>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.set_callback","title":"<code>set_callback(callback)</code>","text":"<p>Set audio callback function.</p> <p>The callback will be called with (outdata, frames) for each audio block.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ndarray, int], None]</code> <p>Function(outdata: np.ndarray, frames: int) -&gt; None</p> required Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def set_callback(self, callback: Callable[[np.ndarray, int], None]) -&gt; None:\n    \"\"\"\n    Set audio callback function.\n\n    The callback will be called with (outdata, frames) for each audio block.\n\n    Args:\n        callback: Function(outdata: np.ndarray, frames: int) -&gt; None\n    \"\"\"\n    self._callback = callback\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.start","title":"<code>start()</code>","text":"<p>Start audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio stream.\"\"\"\n    if self._is_running:\n        return\n\n    if self._callback is None:\n        raise RuntimeError(\"No audio callback set. Call set_callback() first.\")\n\n    device_id = self.device or sd.default.device[1]\n\n    # Try to find a valid low-latency device\n    device_id = self._find_valid_device(device_id)\n\n    # Update self.device to the validated device ID\n    self.device = device_id\n\n    self._log_device_info(device_id)\n\n    # Select stream configuration\n    stream_kwargs = self._get_stream_config(device_id)\n\n    # Try to start the stream\n    self._start_stream(stream_kwargs)\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.stop","title":"<code>stop()</code>","text":"<p>Stop audio stream.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio stream.\"\"\"\n    if not self._is_running:\n        return\n\n    if self._stream:\n        self._stream.stop()\n        self._stream.close()\n        self._stream = None\n\n    self._is_running = False\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.list_output_devices","title":"<code>list_output_devices(all_devices=False)</code>  <code>staticmethod</code>","text":"<p>List available audio output devices.</p> <p>Parameters:</p> Name Type Description Default <code>all_devices</code> <code>bool</code> <p>If True, list all devices. If False, only low-latency devices.</p> <code>False</code> <p>On Windows (low-latency only): ASIO and WASAPI devices On macOS (low-latency only): Core Audio devices On Linux (low-latency only): ALSA and JACK devices</p> <p>Returns:</p> Type Description <code>List[Tuple[int, str, str, Any]]</code> <p>Tuple of (devices, api_names) where:</p> <code>str</code> <ul> <li>devices: List of tuples (device_id, device_name, host_api_name, device_info)</li> </ul> <code>Tuple[List[Tuple[int, str, str, Any]], str]</code> <ul> <li>api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")</li> </ul> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef list_output_devices(all_devices: bool = False) -&gt; Tuple[List[Tuple[int, str, str, Any]], str]:\n    \"\"\"\n    List available audio output devices.\n\n    Args:\n        all_devices: If True, list all devices. If False, only low-latency devices.\n\n    On Windows (low-latency only): ASIO and WASAPI devices\n    On macOS (low-latency only): Core Audio devices\n    On Linux (low-latency only): ALSA and JACK devices\n\n    Returns:\n        Tuple of (devices, api_names) where:\n        - devices: List of tuples (device_id, device_name, host_api_name, device_info)\n        - api_names: String describing the platform APIs (e.g., \"ASIO/WASAPI\")\n    \"\"\"\n    devices = sd.query_devices()\n    hostapis = sd.query_hostapis()\n\n    low_latency_apis, api_names = AudioDevice._get_platform_apis()\n    available_devices = []\n\n    for i, device in enumerate(devices):\n        if device['max_output_channels'] &gt; 0:\n            hostapi = hostapis[device['hostapi']]\n            hostapi_name = hostapi['name']\n\n            if all_devices or any(api in hostapi_name for api in low_latency_apis):\n                available_devices.append((i, device['name'], hostapi_name, device))\n\n    return available_devices, api_names\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.get_devices_by_host_api","title":"<code>get_devices_by_host_api(all_devices=False)</code>  <code>staticmethod</code>","text":"<p>Get audio output devices grouped by host API.</p> <p>Parameters:</p> Name Type Description Default <code>all_devices</code> <code>bool</code> <p>If True, include all devices. If False, only low-latency devices.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, List[Tuple[int, str, Any]]]</code> <p>Dictionary mapping host API name to list of (device_id, device_name, device_info) tuples</p> Example <p>{     \"Windows WASAPI\": [(2, \"Speakers\", {...}), (3, \"Headphones\", {...})],     \"MME\": [(0, \"Speakers\", {...}), (1, \"Headphones\", {...})] }</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_devices_by_host_api(all_devices: bool = False) -&gt; dict[str, List[Tuple[int, str, Any]]]:\n    \"\"\"\n    Get audio output devices grouped by host API.\n\n    Args:\n        all_devices: If True, include all devices. If False, only low-latency devices.\n\n    Returns:\n        Dictionary mapping host API name to list of (device_id, device_name, device_info) tuples\n\n    Example:\n        {\n            \"Windows WASAPI\": [(2, \"Speakers\", {...}), (3, \"Headphones\", {...})],\n            \"MME\": [(0, \"Speakers\", {...}), (1, \"Headphones\", {...})]\n        }\n    \"\"\"\n    devices, _ = AudioDevice.list_output_devices(all_devices=all_devices)\n\n    devices_by_api = {}\n    for device_id, name, host_api, info in devices:\n        if host_api not in devices_by_api:\n            devices_by_api[host_api] = []\n        devices_by_api[host_api].append((device_id, name, info))\n\n    return devices_by_api\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.get_default_device","title":"<code>get_default_device()</code>  <code>staticmethod</code>","text":"<p>Get default output device ID.</p> <p>Returns:</p> Type Description <code>int</code> <p>Device ID</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_default_device() -&gt; int:\n    \"\"\"\n    Get default output device ID.\n\n    Returns:\n        Device ID\n    \"\"\"\n    return sd.default.device[1]  # Output device\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.get_all_host_apis","title":"<code>get_all_host_apis()</code>  <code>staticmethod</code>","text":"<p>Get all available host APIs.</p> <p>Returns:</p> Type Description <code>List[dict]</code> <p>List of host API info dictionaries</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>@staticmethod\ndef get_all_host_apis() -&gt; List[dict]:\n    \"\"\"\n    Get all available host APIs.\n\n    Returns:\n        List of host API info dictionaries\n    \"\"\"\n    return sd.query_hostapis()\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/audio/device/#launchsampler.audio.device.AudioDevice.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/audio/device.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/audio/loader/","title":"Loader","text":""},{"location":"api/audio/loader/#launchsampler.audio.loader","title":"<code>loader</code>","text":"<p>Sample loader for loading audio files.</p>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader","title":"<code>SampleLoader(target_sample_rate=None)</code>","text":"<p>Load audio files into AudioData structures.</p> <p>Handles WAV, FLAC, OGG, and other formats supported by soundfile.</p> <p>Initialize sample loader.</p> <p>Parameters:</p> Name Type Description Default <code>target_sample_rate</code> <code>Optional[int]</code> <p>If set, resample all audio to this rate.                If None, use original sample rate.</p> <code>None</code> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def __init__(self, target_sample_rate: Optional[int] = None):\n    \"\"\"\n    Initialize sample loader.\n\n    Args:\n        target_sample_rate: If set, resample all audio to this rate.\n                           If None, use original sample rate.\n    \"\"\"\n    self.target_sample_rate = target_sample_rate\n</code></pre>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader.load","title":"<code>load(path)</code>","text":"<p>Load audio file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>AudioData</code> <p>AudioData containing the loaded audio</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>RuntimeError</code> <p>If file cannot be loaded</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>def load(self, path: Path) -&gt; AudioData:\n    \"\"\"\n    Load audio file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        AudioData containing the loaded audio\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        RuntimeError: If file cannot be loaded\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    try:\n        # Get file info for metadata\n        info = sf.info(str(path))\n\n        # Load audio file\n        data, sample_rate = sf.read(str(path), dtype='float32')\n\n        # Handle empty files\n        if len(data) == 0:\n            raise RuntimeError(f\"Audio file is empty: {path}\")\n\n        # Resample if needed\n        if self.target_sample_rate and sample_rate != self.target_sample_rate:\n            data = self._resample(data, sample_rate, self.target_sample_rate)\n            sample_rate = self.target_sample_rate\n\n        # Create AudioData with metadata\n        audio_data = AudioData.from_array(data, sample_rate)\n        audio_data.format = info.format\n        audio_data.subtype = info.subtype\n        return audio_data\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to load audio file {path}: {e}\") from e\n</code></pre>"},{"location":"api/audio/loader/#launchsampler.audio.loader.SampleLoader.get_info","title":"<code>get_info(path)</code>  <code>staticmethod</code>","text":"<p>Get audio file info without loading the full file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'sample_rate', 'channels', 'frames', 'duration'</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> Source code in <code>src/launchsampler/audio/loader.py</code> <pre><code>@staticmethod\ndef get_info(path: Path) -&gt; dict:\n    \"\"\"\n    Get audio file info without loading the full file.\n\n    Args:\n        path: Path to audio file\n\n    Returns:\n        Dictionary with 'sample_rate', 'channels', 'frames', 'duration'\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Audio file not found: {path}\")\n\n    info = sf.info(str(path))\n    return {\n        'sample_rate': info.samplerate,\n        'channels': info.channels,\n        'frames': info.frames,\n        'duration': info.duration,\n        'format': info.format,\n        'subtype': info.subtype,\n    }\n</code></pre>"},{"location":"api/audio/mixer/","title":"Mixer","text":""},{"location":"api/audio/mixer/#launchsampler.audio.mixer","title":"<code>mixer</code>","text":"<p>Audio mixer for combining multiple playback states.</p>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer","title":"<code>AudioMixer(num_channels=2)</code>","text":"<p>Mix multiple audio sources into a single output.</p> <p>Thread-safe for use in audio callbacks.</p> <p>Initialize audio mixer.</p> <p>Parameters:</p> Name Type Description Default <code>num_channels</code> <code>int</code> <p>Number of output channels (1=mono, 2=stereo)</p> <code>2</code> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def __init__(self, num_channels: int = 2):\n    \"\"\"\n    Initialize audio mixer.\n\n    Args:\n        num_channels: Number of output channels (1=mono, 2=stereo)\n    \"\"\"\n    self.num_channels = num_channels\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.mix","title":"<code>mix(playback_states, num_frames)</code>","text":"<p>Mix multiple playback states into a single buffer.</p> <p>Parameters:</p> Name Type Description Default <code>playback_states</code> <code>List[PlaybackState]</code> <p>List of PlaybackState objects to mix</p> required <code>num_frames</code> <code>int</code> <p>Number of frames to generate</p> required <p>Returns:</p> Type Description <code>NDArray[float32]</code> <p>Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono</p> Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>def mix(\n    self,\n    playback_states: List[PlaybackState],\n    num_frames: int\n) -&gt; npt.NDArray[np.float32]:\n    \"\"\"\n    Mix multiple playback states into a single buffer.\n\n    Args:\n        playback_states: List of PlaybackState objects to mix\n        num_frames: Number of frames to generate\n\n    Returns:\n        Mixed audio buffer (num_frames, num_channels) or (num_frames,) for mono\n    \"\"\"\n    # Create output buffer\n    if self.num_channels == 1:\n        output = np.zeros(num_frames, dtype=np.float32)\n    else:\n        output = np.zeros((num_frames, self.num_channels), dtype=np.float32)\n\n    # Mix each playing source\n    for state in playback_states:\n        if not state.is_playing or state.audio_data is None:\n            continue\n\n        # Get frames from this source\n        frames = state.get_frames(num_frames)\n        if frames is None:\n            continue\n\n        # Handle channel mismatch\n        frames_to_add = self._match_channels(frames, state.audio_data.num_channels)\n\n        # Add to output (clip to available length)\n        add_length = min(len(frames_to_add), num_frames)\n        if self.num_channels == 1:\n            output[:add_length] += frames_to_add[:add_length]\n        else:\n            output[:add_length, :] += frames_to_add[:add_length, :]\n\n        # Advance the playback position\n        state.advance(add_length)\n\n    return output\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.apply_master_volume","title":"<code>apply_master_volume(buffer, volume)</code>  <code>staticmethod</code>","text":"<p>Apply master volume to buffer in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to modify</p> required <code>volume</code> <code>float</code> <p>Volume multiplier (0.0 to 1.0)</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef apply_master_volume(\n    buffer: npt.NDArray[np.float32],\n    volume: float\n) -&gt; None:\n    \"\"\"\n    Apply master volume to buffer in-place.\n\n    Args:\n        buffer: Audio buffer to modify\n        volume: Volume multiplier (0.0 to 1.0)\n    \"\"\"\n    if volume != 1.0:\n        buffer *= volume\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.clip","title":"<code>clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Clip audio buffer to valid range [-1.0, 1.0] in-place.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Clip audio buffer to valid range [-1.0, 1.0] in-place.\n\n    Args:\n        buffer: Audio buffer to clip\n    \"\"\"\n    np.clip(buffer, -1.0, 1.0, out=buffer)\n</code></pre>"},{"location":"api/audio/mixer/#launchsampler.audio.mixer.AudioMixer.soft_clip","title":"<code>soft_clip(buffer)</code>  <code>staticmethod</code>","text":"<p>Apply soft clipping (tanh) to prevent harsh distortion.</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>NDArray[float32]</code> <p>Audio buffer to soft clip</p> required Source code in <code>src/launchsampler/audio/mixer.py</code> <pre><code>@staticmethod\ndef soft_clip(buffer: npt.NDArray[np.float32]) -&gt; None:\n    \"\"\"\n    Apply soft clipping (tanh) to prevent harsh distortion.\n\n    Args:\n        buffer: Audio buffer to soft clip\n    \"\"\"\n    np.tanh(buffer, out=buffer)\n</code></pre>"},{"location":"api/core/","title":"Core","text":"<p>Audio playback engine and state management</p> <p>Core sampler engine.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine","title":"<code>SamplerEngine(audio_device, num_pads=64, state_machine=None)</code>","text":"<p>Audio playback engine for multi-pad samplers.</p> <p>Device-agnostic engine that manages audio playback for N pads. Works with any MIDI controller that provides pad triggers.</p> <p>Composes generic audio primitives (device, loader, mixer) with pad-based playback management.</p> Threading Model <p>This engine operates across multiple threads:</p> <ol> <li>UI Thread (Textual):</li> <li>Calls load_sample() / unload_sample() via EditObserver pattern</li> <li> <p>Uses self._lock to safely modify _playback_states</p> </li> <li> <p>MIDI Thread:</p> </li> <li>Calls trigger_pad() / release_pad()</li> <li> <p>Lock-free: writes to _trigger_queue (Queue is thread-safe)</p> </li> <li> <p>Audio Callback Thread (sounddevice):</p> </li> <li>Runs _audio_callback() to mix and render audio</li> <li>Reads from _trigger_queue (lock-free)</li> <li>Reads/writes _playback_states WITHOUT lock (owns playback state)</li> </ol> <p>Lock Strategy:     - self._lock protects _playback_states during load/unload (rare ops)     - Triggers use lock-free queue for minimal latency (frequent ops)     - Audio callback avoids locks entirely to prevent audio glitches     - Stale reads during concurrent modifications are acceptable       (affects at most one 5ms audio block)</p> <p>Initialize sampler engine.</p> <p>Parameters:</p> Name Type Description Default <code>audio_device</code> <code>AudioDevice</code> <p>Configured AudioDevice instance</p> required <code>num_pads</code> <code>int</code> <p>Number of pads to manage (default: 64 for Launchpad)</p> <code>64</code> <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __init__(\n    self,\n    audio_device: AudioDevice,\n    num_pads: int = 64,\n    state_machine: Optional[SamplerStateMachine] = None\n):\n    \"\"\"\n    Initialize sampler engine.\n\n    Args:\n        audio_device: Configured AudioDevice instance\n        num_pads: Number of pads to manage (default: 64 for Launchpad)\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self._device = audio_device\n    self._num_pads = num_pads\n    self._loader = SampleLoader(target_sample_rate=audio_device.sample_rate)\n    self._mixer = AudioMixer(num_channels=audio_device.num_channels)\n\n    # Application state\n    self._audio_cache: Dict[str, AudioData] = {}  # path -&gt; AudioData\n    self._playback_states: Dict[int, PlaybackState] = {}  # pad_index -&gt; PlaybackState\n    self._master_volume = 1.0\n\n    # State machine for event dispatch (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Thread safety\n    self._lock = Lock()  # Only for sample loading/unloading, not for triggers\n\n    # Lock-free trigger queue for low-latency pad triggering\n    # Sized generously to handle burst inputs without blocking\n    self._trigger_queue: Queue[tuple[str, int]] = Queue(maxsize=256)\n\n    # Register audio callback\n    self._device.set_callback(self._audio_callback)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio device is running.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads managed by this engine.</p>"},{"location":"api/core/#launchsampler.core.SamplerEngine.load_sample","title":"<code>load_sample(pad_index, pad, normalize=True)</code>","text":"<p>Load audio sample for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>pad</code> <code>Pad</code> <p>Pad model with sample information</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize audio after loading</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict from concurrent modification with the audio callback thread. File I/O occurs outside the lock for better performance.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def load_sample(self, pad_index: int, pad: Pad, normalize: bool = True) -&gt; bool:\n    \"\"\"\n    Load audio sample for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        pad: Pad model with sample information\n        normalize: Whether to normalize audio after loading\n\n    Returns:\n        True if loaded successfully, False otherwise\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict from\n        concurrent modification with the audio callback thread.\n        File I/O occurs outside the lock for better performance.\n    \"\"\"\n    if pad_index &lt; 0 or pad_index &gt;= self._num_pads:\n        logger.error(f\"Invalid pad index: {pad_index} (valid: 0-{self._num_pads-1})\")\n        return False\n\n    if not pad.is_assigned or pad.sample is None:\n        return False\n\n    path_str = str(pad.sample.path)\n\n    try:\n        # Check cache first\n        if path_str not in self._audio_cache:\n            audio_data = self._loader.load(pad.sample.path)\n            self._audio_cache[path_str] = audio_data\n        else:\n            audio_data = self._audio_cache[path_str]\n\n        # Normalize audio if needed\n        if normalize:\n            audio_data.normalize()\n\n        # Create or update playback state\n        with self._lock:\n            if pad_index not in self._playback_states:\n                self._playback_states[pad_index] = PlaybackState()\n\n            state = self._playback_states[pad_index]\n            state.audio_data = audio_data\n            state.mode = pad.mode\n            state.volume = pad.volume\n            state.reset()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error loading sample for pad {pad_index}: {e}\")\n        return False\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.unload_sample","title":"<code>unload_sample(pad_index)</code>","text":"<p>Unload sample from pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict. If a pad is triggered after unloading but before the audio callback processes it, the callback safely skips missing pads (see _audio_callback line ~347).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unload_sample(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Unload sample from pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict.\n        If a pad is triggered after unloading but before the\n        audio callback processes it, the callback safely skips\n        missing pads (see _audio_callback line ~347).\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            was_playing = self._playback_states[pad_index].is_playing\n            self._playback_states[pad_index].stop()\n            # Remove the entry entirely to ensure fresh state when reloading\n            del self._playback_states[pad_index]\n\n            # Notify state machine if pad was playing\n            if was_playing:\n                self._state_machine.notify_pad_stopped(pad_index)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger playback for a pad.</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger playback for a pad.\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write - if queue is full, drop the trigger\n        # This should never happen with a 256-entry queue unless system is severely overloaded\n        self._trigger_queue.put_nowait((\"trigger\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} trigger\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release pad (for HOLD mode).</p> <p>For HOLD mode: Stops playback immediately For other modes: Ignored (sample plays according to mode)</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release pad (for HOLD mode).\n\n    For HOLD mode: Stops playback immediately\n    For other modes: Ignored (sample plays according to mode)\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"release\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} release\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop playback for a pad (works for all modes).</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop playback for a pad (works for all modes).\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"stop\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> <p>Uses the queue mechanism to ensure proper playback events are fired.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"\n    Stop all playing pads.\n\n    Uses the queue mechanism to ensure proper playback events are fired.\n    \"\"\"\n    # Get all pad indices (need lock to safely read keys)\n    with self._lock:\n        pad_indices = list(self._playback_states.keys())\n\n    # Queue stop actions for all pads (lock-free)\n    for pad_index in pad_indices:\n        try:\n            self._trigger_queue.put_nowait((\"stop\", pad_index))\n        except Full:\n            logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop during stop_all\")\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.update_pad_volume","title":"<code>update_pad_volume(pad_index, volume)</code>","text":"<p>Update volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_volume(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Update volume for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        volume: New volume (0.0-1.0)\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].volume = volume\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.update_pad_mode","title":"<code>update_pad_mode(pad_index, mode)</code>","text":"<p>Update playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; None:\n    \"\"\"\n    Update playback mode for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        mode: New playback mode\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].mode = mode\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    self._master_volume = max(0.0, min(1.0, volume))\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_machine.register_observer(observer)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_machine.unregister_observer(observer)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing, False otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        True if pad is playing, False otherwise\n    \"\"\"\n    return self._state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pad indices.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pad indices.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    return self._state_machine.get_playing_pads()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_playback_info","title":"<code>get_playback_info(pad_index)</code>","text":"<p>Get playback information for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with playback info or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playback_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get playback information for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with playback info or None\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return {\n            'is_playing': state.is_playing,\n            'progress': state.progress,\n            'time_elapsed': state.time_elapsed,\n            'time_remaining': state.time_remaining,\n            'mode': state.mode.value,\n            'volume': state.volume,\n        }\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get AudioData for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get AudioData for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return state.audio_data\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.get_audio_info","title":"<code>get_audio_info(pad_index)</code>","text":"<p>Get audio file information for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with audio info including duration, sample rate, channels, format, etc., or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get audio file information for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with audio info including duration, sample rate, channels, format, etc., or None\n    \"\"\"\n    audio_data = self.get_audio_data(pad_index)\n    return audio_data.get_info() if audio_data else None\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear audio cache (useful to free memory).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear audio cache (useful to free memory).\"\"\"\n    with self._lock:\n        self._audio_cache.clear()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.start","title":"<code>start()</code>","text":"<p>Start audio device and begin playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio device and begin playback.\"\"\"\n    self._device.start()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.stop","title":"<code>stop()</code>","text":"<p>Stop audio device and all playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio device and all playback.\"\"\"\n    self.stop_all()\n    self._device.stop()\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/#launchsampler.core.SamplerEngine.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/player/","title":"Player","text":""},{"location":"api/core/player/#launchsampler.core.player","title":"<code>player</code>","text":"<p>Core player logic - UI-agnostic.</p> <p>This can be used in: - TUI application - GUI application - Headless server - CLI tool - Test environment</p>"},{"location":"api/core/player/#launchsampler.core.player.Player","title":"<code>Player(config, state_machine=None)</code>","text":"<p>               Bases: <code>StateObserver</code>, <code>EditObserver</code>, <code>MidiObserver</code></p> <p>Core player for Launchpad sampling.</p> <p>This class manages audio playback without any UI dependencies. It can be used in any application (TUI, GUI, CLI, headless).</p> <p>Implements: - StateObserver: for playback events from audio engine - EditObserver: for editing events from editor service - MidiObserver: for MIDI input events (triggered by orchestrator)</p> <p>Responsibilities: - Audio engine lifecycle - Playback state observation - Edit event observation and audio sync - MIDI input observation and audio triggering - Set loading into audio engine</p> <p>NOT responsible for: - MIDI controller lifecycle (managed by orchestrator) - UI rendering - User input beyond MIDI - Editing operations - File browsing</p> <p>Initialize player.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __init__(self, config: AppConfig, state_machine: Optional[SamplerStateMachine] = None):\n    \"\"\"\n    Initialize player.\n\n    Args:\n        config: Application configuration\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self.config = config\n    self.current_set: Optional[Set] = None\n\n    # State machine (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Audio components\n    self._audio_device: Optional[AudioDevice] = None\n    self._engine: Optional[SamplerEngine] = None\n\n    # Callbacks for external notification (deprecated - use register_state_observer)\n    self._on_playback_change: Optional[Callable[[PlaybackEvent, int], None]] = None\n\n    # State observers (multiple observers supported)\n    self._state_observers = ObserverManager[StateObserver](observer_type_name=\"state\")\n\n    # State\n    self._is_running = False\n    self._last_error: Optional[Exception] = None\n    logger.info(\"Player initialized\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if player is running.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.audio_device_name","title":"<code>audio_device_name</code>  <code>property</code>","text":"<p>Get name of audio device.</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.engine","title":"<code>engine</code>  <code>property</code>","text":"<p>Get the sampler engine (read-only access).</p>"},{"location":"api/core/player/#launchsampler.core.player.Player.start","title":"<code>start(initial_set=None)</code>","text":"<p>Start player (audio only - MIDI is managed by orchestrator).</p> <p>Parameters:</p> Name Type Description Default <code>initial_set</code> <code>Optional[Set]</code> <p>Optional set to load on startup</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if started successfully</p> <p>Raises:</p> Type Description <code>AudioDeviceError</code> <p>If audio device fails to start</p> <code>LaunchSamplerError</code> <p>If other initialization errors occur</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def start(self, initial_set: Optional[Set] = None) -&gt; bool:\n    \"\"\"\n    Start player (audio only - MIDI is managed by orchestrator).\n\n    Args:\n        initial_set: Optional set to load on startup\n\n    Returns:\n        True if started successfully\n\n    Raises:\n        AudioDeviceError: If audio device fails to start\n        LaunchSamplerError: If other initialization errors occur\n    \"\"\"\n    if self._is_running:\n        logger.warning(\"Player already running\")\n        return True\n\n    # Load initial set if provided\n    if initial_set:\n        self.current_set = initial_set\n\n    # Start audio engine\n    if not self._start_audio():\n        logger.error(\"Failed to start audio\")\n        # Re-raise the stored exception with better context\n        if self._last_error:\n            raise self._last_error\n        else:\n            raise RuntimeError(\"Failed to start audio - unknown error\")\n\n    self._is_running = True\n    logger.info(\"Player started\")\n    return True\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop","title":"<code>stop()</code>","text":"<p>Stop player (audio only - MIDI is managed by orchestrator).</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop player (audio only - MIDI is managed by orchestrator).\"\"\"\n    if not self._is_running:\n        return\n\n    self._stop_audio()\n\n    self._is_running = False\n    logger.info(\"Player stopped\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.load_set","title":"<code>load_set(set_obj)</code>","text":"<p>Load a new set.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>Set to load</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def load_set(self, set_obj: Set) -&gt; None:\n    \"\"\"\n    Load a new set.\n\n    Args:\n        set_obj: Set to load\n    \"\"\"\n    self.current_set = set_obj\n\n    # Load into engine if running\n    if self._engine and self._is_running:\n        self._load_set_into_engine(set_obj)\n\n    logger.info(f\"Loaded set: {set_obj.name} with {len(set_obj.launchpad.assigned_pads)} samples\")\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger a pad (from any source: MIDI, keyboard, UI, etc).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to trigger (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger a pad (from any source: MIDI, keyboard, UI, etc).\n\n    Args:\n        pad_index: Index of pad to trigger (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.trigger_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release a pad (for HOLD/LOOP modes).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to release (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release a pad (for HOLD/LOOP modes).\n\n    Args:\n        pad_index: Index of pad to release (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.release_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop a specific pad immediately (works for all modes).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to stop (0-63)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop a specific pad immediately (works for all modes).\n\n    Args:\n        pad_index: Index of pad to stop (0-63)\n    \"\"\"\n    if self._engine:\n        self._engine.stop_pad(pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"Stop all playing pads.\"\"\"\n    if self._engine:\n        self._engine.stop_all()\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    if self._engine:\n        self._engine.set_master_volume(volume)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>This is called from the MIDI thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_midi_event(self, event: MidiEvent, pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    This is called from the MIDI thread.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    if event == MidiEvent.NOTE_ON:\n        # MIDI pad pressed - trigger audio if sample is assigned\n        if self.current_set and pad_index &gt;= 0:\n            pad = self.current_set.launchpad.pads[pad_index]\n            if pad.is_assigned:\n                self.trigger_pad(pad_index)\n        else:\n            logger.warning(f\"MIDI NOTE_ON received but cannot trigger: current_set={self.current_set is not None}, pad_index={pad_index}\")\n\n    elif event == MidiEvent.NOTE_OFF:\n        # MIDI pad released - release audio if mode supports it\n        if self.current_set and pad_index &gt;= 0:\n            pad = self.current_set.launchpad.pads[pad_index]\n            if pad.is_assigned and pad.mode in (PlaybackMode.LOOP, PlaybackMode.HOLD):\n                self.release_pad(pad_index)\n\n    elif event == MidiEvent.CONTROL_CHANGE:\n        # Handle panic button (stop all audio)\n        if (control == self.config.panic_button_cc_control and\n            value == self.config.panic_button_cc_value):\n            logger.info(f\"Panic button triggered via MIDI CC (control={control}, value={value})\")\n            self.stop_all()\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>This is called from the audio thread, so we forward to all observers.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    This is called from the audio thread, so we forward to all observers.\n    \"\"\"\n    # Legacy callback support (deprecated)\n    if self._on_playback_change:\n        self._on_playback_change(event, pad_index)\n\n    # Notify all state observers\n    self._state_observers.notify('on_playback_event', event, pad_index)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and sync audio engine.</p> <p>This eliminates the need for manual _reload_pad() calls throughout the codebase. When any editing operation occurs (assign, clear, move, etc.), this observer automatically syncs the audio engine.</p> Threading <p>Called from the UI thread (Textual's main loop). Delegates to SamplerEngine methods which use locks for thread safety.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def on_edit_event(\n    self,\n    event: EditEvent,\n    pad_indices: list[int],\n    pads: list\n) -&gt; None:\n    \"\"\"\n    Handle editing events and sync audio engine.\n\n    This eliminates the need for manual _reload_pad() calls throughout\n    the codebase. When any editing operation occurs (assign, clear, move,\n    etc.), this observer automatically syncs the audio engine.\n\n    Threading:\n        Called from the UI thread (Textual's main loop).\n        Delegates to SamplerEngine methods which use locks for thread safety.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    if not self._engine:\n        return\n\n    logger.debug(f\"Player received edit event: {event.value} for pads {pad_indices}\")\n\n    for pad_index, pad in zip(pad_indices, pads):\n        if event in (\n            EditEvent.PAD_ASSIGNED,\n            EditEvent.PAD_DUPLICATED,\n            EditEvent.PAD_MODE_CHANGED\n        ):\n            # Reload sample into engine\n            if pad.is_assigned:\n                logger.info(f\"Loading sample '{pad.sample.name}' into pad {pad_index} (event: {event.value})\")\n                self._engine.load_sample(pad_index, pad)\n            else:\n                logger.info(f\"Unloading pad {pad_index} (event: {event.value})\")\n                self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_MOVED:\n            # For moves, reload both pads (source and target)\n            if pad.is_assigned:\n                logger.info(f\"Loading sample '{pad.sample.name}' into pad {pad_index} (moved)\")\n                self._engine.load_sample(pad_index, pad)\n            else:\n                logger.info(f\"Unloading pad {pad_index} (moved)\")\n                self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_CLEARED:\n            # Unload sample\n            logger.info(f\"Unloading pad {pad_index} (cleared)\")\n            self._engine.unload_sample(pad_index)\n\n        elif event == EditEvent.PAD_VOLUME_CHANGED:\n            # Update volume without reloading (more efficient)\n            logger.debug(f\"Updating volume for pad {pad_index} to {pad.volume}\")\n            self._engine.update_pad_volume(pad_index, pad.volume)\n\n        elif event == EditEvent.PADS_CLEARED:\n            # Multiple pads cleared - reload each\n            logger.info(f\"Unloading multiple pads: {pad_indices}\")\n            for idx, p in zip(pad_indices, pads):\n                self._engine.unload_sample(idx)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.register_state_observer","title":"<code>register_state_observer(observer)</code>","text":"<p>Register an observer for playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def register_state_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer for playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_observers.register(observer)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.unregister_state_observer","title":"<code>unregister_state_observer(observer)</code>","text":"<p>Unregister a state observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def unregister_state_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister a state observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_observers.unregister(observer)\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.set_playback_callback","title":"<code>set_playback_callback(callback)</code>","text":"<p>Register callback for playback events (DEPRECATED).</p> <p>Use register_state_observer() instead for proper observer pattern support.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[PlaybackEvent, int], None]</code> <p>Function to call on playback events (from audio engine)</p> required Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def set_playback_callback(self, callback: Callable[[PlaybackEvent, int], None]) -&gt; None:\n    \"\"\"\n    Register callback for playback events (DEPRECATED).\n\n    Use register_state_observer() instead for proper observer pattern support.\n\n    Args:\n        callback: Function to call on playback events (from audio engine)\n    \"\"\"\n    self._on_playback_change = callback\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Index of pad to check\n\n    Returns:\n        True if pad is playing\n    \"\"\"\n    return self._engine.is_pad_playing(pad_index) if self._engine else False\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pads.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pads.\n\n    Returns:\n        List of pad indices\n    \"\"\"\n    return self._engine.get_playing_pads() if self._engine else []\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get audio waveform data for a pad (for visualization).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get audio data for</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get audio waveform data for a pad (for visualization).\n\n    Args:\n        pad_index: Index of pad to get audio data for\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    if self._engine:\n        return self._engine.get_audio_data(pad_index)\n    return None\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/player/#launchsampler.core.player.Player.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/player.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/sampler_engine/","title":"Sampler Engine","text":""},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine","title":"<code>sampler_engine</code>","text":"<p>Device-agnostic audio playback engine for multi-pad samplers.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine","title":"<code>SamplerEngine(audio_device, num_pads=64, state_machine=None)</code>","text":"<p>Audio playback engine for multi-pad samplers.</p> <p>Device-agnostic engine that manages audio playback for N pads. Works with any MIDI controller that provides pad triggers.</p> <p>Composes generic audio primitives (device, loader, mixer) with pad-based playback management.</p> Threading Model <p>This engine operates across multiple threads:</p> <ol> <li>UI Thread (Textual):</li> <li>Calls load_sample() / unload_sample() via EditObserver pattern</li> <li> <p>Uses self._lock to safely modify _playback_states</p> </li> <li> <p>MIDI Thread:</p> </li> <li>Calls trigger_pad() / release_pad()</li> <li> <p>Lock-free: writes to _trigger_queue (Queue is thread-safe)</p> </li> <li> <p>Audio Callback Thread (sounddevice):</p> </li> <li>Runs _audio_callback() to mix and render audio</li> <li>Reads from _trigger_queue (lock-free)</li> <li>Reads/writes _playback_states WITHOUT lock (owns playback state)</li> </ol> <p>Lock Strategy:     - self._lock protects _playback_states during load/unload (rare ops)     - Triggers use lock-free queue for minimal latency (frequent ops)     - Audio callback avoids locks entirely to prevent audio glitches     - Stale reads during concurrent modifications are acceptable       (affects at most one 5ms audio block)</p> <p>Initialize sampler engine.</p> <p>Parameters:</p> Name Type Description Default <code>audio_device</code> <code>AudioDevice</code> <p>Configured AudioDevice instance</p> required <code>num_pads</code> <code>int</code> <p>Number of pads to manage (default: 64 for Launchpad)</p> <code>64</code> <code>state_machine</code> <code>Optional[SamplerStateMachine]</code> <p>Optional shared state machine for dependency injection.           If None, creates a new instance (for backward compatibility).</p> <code>None</code> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __init__(\n    self,\n    audio_device: AudioDevice,\n    num_pads: int = 64,\n    state_machine: Optional[SamplerStateMachine] = None\n):\n    \"\"\"\n    Initialize sampler engine.\n\n    Args:\n        audio_device: Configured AudioDevice instance\n        num_pads: Number of pads to manage (default: 64 for Launchpad)\n        state_machine: Optional shared state machine for dependency injection.\n                      If None, creates a new instance (for backward compatibility).\n    \"\"\"\n    self._device = audio_device\n    self._num_pads = num_pads\n    self._loader = SampleLoader(target_sample_rate=audio_device.sample_rate)\n    self._mixer = AudioMixer(num_channels=audio_device.num_channels)\n\n    # Application state\n    self._audio_cache: Dict[str, AudioData] = {}  # path -&gt; AudioData\n    self._playback_states: Dict[int, PlaybackState] = {}  # pad_index -&gt; PlaybackState\n    self._master_volume = 1.0\n\n    # State machine for event dispatch (injected or created)\n    self._state_machine = state_machine or SamplerStateMachine()\n\n    # Thread safety\n    self._lock = Lock()  # Only for sample loading/unloading, not for triggers\n\n    # Lock-free trigger queue for low-latency pad triggering\n    # Sized generously to handle burst inputs without blocking\n    self._trigger_queue: Queue[tuple[str, int]] = Queue(maxsize=256)\n\n    # Register audio callback\n    self._device.set_callback(self._audio_callback)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.is_running","title":"<code>is_running</code>  <code>property</code>","text":"<p>Check if audio device is running.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.active_voices","title":"<code>active_voices</code>  <code>property</code>","text":"<p>Get number of currently playing voices.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads managed by this engine.</p>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.load_sample","title":"<code>load_sample(pad_index, pad, normalize=True)</code>","text":"<p>Load audio sample for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>pad</code> <code>Pad</code> <p>Pad model with sample information</p> required <code>normalize</code> <code>bool</code> <p>Whether to normalize audio after loading</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict from concurrent modification with the audio callback thread. File I/O occurs outside the lock for better performance.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def load_sample(self, pad_index: int, pad: Pad, normalize: bool = True) -&gt; bool:\n    \"\"\"\n    Load audio sample for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        pad: Pad model with sample information\n        normalize: Whether to normalize audio after loading\n\n    Returns:\n        True if loaded successfully, False otherwise\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict from\n        concurrent modification with the audio callback thread.\n        File I/O occurs outside the lock for better performance.\n    \"\"\"\n    if pad_index &lt; 0 or pad_index &gt;= self._num_pads:\n        logger.error(f\"Invalid pad index: {pad_index} (valid: 0-{self._num_pads-1})\")\n        return False\n\n    if not pad.is_assigned or pad.sample is None:\n        return False\n\n    path_str = str(pad.sample.path)\n\n    try:\n        # Check cache first\n        if path_str not in self._audio_cache:\n            audio_data = self._loader.load(pad.sample.path)\n            self._audio_cache[path_str] = audio_data\n        else:\n            audio_data = self._audio_cache[path_str]\n\n        # Normalize audio if needed\n        if normalize:\n            audio_data.normalize()\n\n        # Create or update playback state\n        with self._lock:\n            if pad_index not in self._playback_states:\n                self._playback_states[pad_index] = PlaybackState()\n\n            state = self._playback_states[pad_index]\n            state.audio_data = audio_data\n            state.mode = pad.mode\n            state.volume = pad.volume\n            state.reset()\n\n        return True\n\n    except Exception as e:\n        logger.error(f\"Error loading sample for pad {pad_index}: {e}\")\n        return False\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.unload_sample","title":"<code>unload_sample(pad_index)</code>","text":"<p>Unload sample from pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Thread Safety <p>Safe to call from UI thread via EditObserver pattern. Uses self._lock to protect _playback_states dict. If a pad is triggered after unloading but before the audio callback processes it, the callback safely skips missing pads (see _audio_callback line ~347).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unload_sample(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Unload sample from pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Thread Safety:\n        Safe to call from UI thread via EditObserver pattern.\n        Uses self._lock to protect _playback_states dict.\n        If a pad is triggered after unloading but before the\n        audio callback processes it, the callback safely skips\n        missing pads (see _audio_callback line ~347).\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            was_playing = self._playback_states[pad_index].is_playing\n            self._playback_states[pad_index].stop()\n            # Remove the entry entirely to ensure fresh state when reloading\n            del self._playback_states[pad_index]\n\n            # Notify state machine if pad was playing\n            if was_playing:\n                self._state_machine.notify_pad_stopped(pad_index)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.trigger_pad","title":"<code>trigger_pad(pad_index)</code>","text":"<p>Trigger playback for a pad.</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def trigger_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Trigger playback for a pad.\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write - if queue is full, drop the trigger\n        # This should never happen with a 256-entry queue unless system is severely overloaded\n        self._trigger_queue.put_nowait((\"trigger\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} trigger\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.release_pad","title":"<code>release_pad(pad_index)</code>","text":"<p>Release pad (for HOLD mode).</p> <p>For HOLD mode: Stops playback immediately For other modes: Ignored (sample plays according to mode)</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread (e.g., MIDI input thread).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def release_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Release pad (for HOLD mode).\n\n    For HOLD mode: Stops playback immediately\n    For other modes: Ignored (sample plays according to mode)\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread (e.g., MIDI input thread).\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"release\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} release\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop_pad","title":"<code>stop_pad(pad_index)</code>","text":"<p>Stop playback for a pad (works for all modes).</p> <p>Lock-free implementation using queue for minimal latency. Safe to call from any thread.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Stop playback for a pad (works for all modes).\n\n    Lock-free implementation using queue for minimal latency.\n    Safe to call from any thread.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n    \"\"\"\n    try:\n        # Non-blocking queue write\n        self._trigger_queue.put_nowait((\"stop\", pad_index))\n    except Full:\n        logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop_all","title":"<code>stop_all()</code>","text":"<p>Stop all playing pads.</p> <p>Uses the queue mechanism to ensure proper playback events are fired.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop_all(self) -&gt; None:\n    \"\"\"\n    Stop all playing pads.\n\n    Uses the queue mechanism to ensure proper playback events are fired.\n    \"\"\"\n    # Get all pad indices (need lock to safely read keys)\n    with self._lock:\n        pad_indices = list(self._playback_states.keys())\n\n    # Queue stop actions for all pads (lock-free)\n    for pad_index in pad_indices:\n        try:\n            self._trigger_queue.put_nowait((\"stop\", pad_index))\n        except Full:\n            logger.warning(f\"Trigger queue full, dropped pad {pad_index} stop during stop_all\")\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.update_pad_volume","title":"<code>update_pad_volume(pad_index, volume)</code>","text":"<p>Update volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_volume(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Update volume for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        volume: New volume (0.0-1.0)\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].volume = volume\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.update_pad_mode","title":"<code>update_pad_mode(pad_index, mode)</code>","text":"<p>Update playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required Thread Safety <p>Safe to call from UI thread. Uses self._lock.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def update_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; None:\n    \"\"\"\n    Update playback mode for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n        mode: New playback mode\n\n    Thread Safety:\n        Safe to call from UI thread. Uses self._lock.\n    \"\"\"\n    with self._lock:\n        if pad_index in self._playback_states:\n            self._playback_states[pad_index].mode = mode\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.set_master_volume","title":"<code>set_master_volume(volume)</code>","text":"<p>Set master output volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <code>float</code> <p>Master volume (0.0-1.0)</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def set_master_volume(self, volume: float) -&gt; None:\n    \"\"\"\n    Set master output volume.\n\n    Args:\n        volume: Master volume (0.0-1.0)\n    \"\"\"\n    self._master_volume = max(0.0, min(1.0, volume))\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback state events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback state events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._state_machine.register_observer(observer)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._state_machine.unregister_observer(observer)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing, False otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        True if pad is playing, False otherwise\n    \"\"\"\n    return self._state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pad indices.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pad indices.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    return self._state_machine.get_playing_pads()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_playback_info","title":"<code>get_playback_info(pad_index)</code>","text":"<p>Get playback information for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with playback info or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_playback_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get playback information for a pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with playback info or None\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return {\n            'is_playing': state.is_playing,\n            'progress': state.progress,\n            'time_elapsed': state.time_elapsed,\n            'time_remaining': state.time_remaining,\n            'mode': state.mode.value,\n            'volume': state.volume,\n        }\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_audio_data","title":"<code>get_audio_data(pad_index)</code>","text":"<p>Get AudioData for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[AudioData]</code> <p>AudioData object if pad has audio loaded, None otherwise</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_data(self, pad_index: int) -&gt; Optional[AudioData]:\n    \"\"\"\n    Get AudioData for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        AudioData object if pad has audio loaded, None otherwise\n    \"\"\"\n    with self._lock:\n        if pad_index not in self._playback_states:\n            return None\n\n        state = self._playback_states[pad_index]\n        return state.audio_data\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.get_audio_info","title":"<code>get_audio_info(pad_index)</code>","text":"<p>Get audio file information for a loaded pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index (0 to num_pads-1)</p> required <p>Returns:</p> Type Description <code>Optional[dict]</code> <p>Dictionary with audio info including duration, sample rate, channels, format, etc., or None</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def get_audio_info(self, pad_index: int) -&gt; Optional[dict]:\n    \"\"\"\n    Get audio file information for a loaded pad.\n\n    Args:\n        pad_index: Pad index (0 to num_pads-1)\n\n    Returns:\n        Dictionary with audio info including duration, sample rate, channels, format, etc., or None\n    \"\"\"\n    audio_data = self.get_audio_data(pad_index)\n    return audio_data.get_info() if audio_data else None\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.clear_cache","title":"<code>clear_cache()</code>","text":"<p>Clear audio cache (useful to free memory).</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def clear_cache(self) -&gt; None:\n    \"\"\"Clear audio cache (useful to free memory).\"\"\"\n    with self._lock:\n        self._audio_cache.clear()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.start","title":"<code>start()</code>","text":"<p>Start audio device and begin playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start audio device and begin playback.\"\"\"\n    self._device.start()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.stop","title":"<code>stop()</code>","text":"<p>Stop audio device and all playback.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop audio device and all playback.\"\"\"\n    self.stop_all()\n    self._device.stop()\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/core/sampler_engine/#launchsampler.core.sampler_engine.SamplerEngine.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/core/sampler_engine.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/core/state_machine/","title":"State Machine","text":""},{"location":"api/core/state_machine/#launchsampler.core.state_machine","title":"<code>state_machine</code>","text":"<p>State machine for managing sampler playback state and event dispatch.</p>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine","title":"<code>SamplerStateMachine()</code>","text":"<p>Manages playback state and dispatches events to observers.</p> <p>This class acts as the single source of truth for playback state and coordinates event dispatch to registered observers. It is thread-safe and designed to be called from the audio thread.</p> <p>The state machine tracks: - Which pads are currently playing - Which pads are triggered but not yet playing - Registered observers that receive events</p> <p>Initialize the state machine.</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the state machine.\"\"\"\n    self._lock = Lock()\n    self._playing_pads: set[int] = set()\n    self._triggered_pads: set[int] = set()\n    # ObserverManager has its own lock - don't share to avoid deadlock when notifying while holding _lock\n    self._observers = ObserverManager[StateObserver](observer_type_name=\"state\")\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive playback events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Object implementing StateObserver protocol</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def register_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive playback events.\n\n    Args:\n        observer: Object implementing StateObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>StateObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def unregister_observer(self, observer: StateObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_triggered","title":"<code>notify_pad_triggered(pad_index)</code>","text":"<p>Notify that a pad trigger event occurred (note on received).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of triggered pad</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_triggered(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad trigger event occurred (note on received).\n\n    Args:\n        pad_index: Index of triggered pad\n    \"\"\"\n    with self._lock:\n        self._triggered_pads.add(pad_index)\n    # Notify observers AFTER releasing lock to avoid deadlock\n    self._notify_observers(PlaybackEvent.PAD_TRIGGERED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_playing","title":"<code>notify_pad_playing(pad_index)</code>","text":"<p>Notify that a pad playing event occurred (audio started).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that started playing</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_playing(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad playing event occurred (audio started).\n\n    Args:\n        pad_index: Index of pad that started playing\n    \"\"\"\n    with self._lock:\n        self._triggered_pads.discard(pad_index)\n        self._playing_pads.add(pad_index)\n    # Notify observers AFTER releasing lock to avoid deadlock\n    self._notify_observers(PlaybackEvent.PAD_PLAYING, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_stopped","title":"<code>notify_pad_stopped(pad_index)</code>","text":"<p>Notify that a pad stopped event occurred (note off or interrupt).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that was stopped</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_stopped(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad stopped event occurred (note off or interrupt).\n\n    Args:\n        pad_index: Index of pad that was stopped\n    \"\"\"\n    with self._lock:\n        was_playing = pad_index in self._playing_pads\n        self._triggered_pads.discard(pad_index)\n        self._playing_pads.discard(pad_index)\n\n    # Notify observers AFTER releasing lock to avoid deadlock\n    if was_playing:\n        self._notify_observers(PlaybackEvent.PAD_STOPPED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.notify_pad_finished","title":"<code>notify_pad_finished(pad_index)</code>","text":"<p>Notify that a pad finished event occurred (playback completed naturally).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad that finished playing</p> required Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def notify_pad_finished(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Notify that a pad finished event occurred (playback completed naturally).\n\n    Args:\n        pad_index: Index of pad that finished playing\n    \"\"\"\n    with self._lock:\n        was_playing = pad_index in self._playing_pads\n        self._playing_pads.discard(pad_index)\n\n    # Notify observers AFTER releasing lock to avoid deadlock\n    if was_playing:\n        self._notify_observers(PlaybackEvent.PAD_FINISHED, pad_index)\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.is_pad_playing","title":"<code>is_pad_playing(pad_index)</code>","text":"<p>Check if a pad is currently playing.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if pad is playing</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def is_pad_playing(self, pad_index: int) -&gt; bool:\n    \"\"\"\n    Check if a pad is currently playing.\n\n    Args:\n        pad_index: Index of pad to check\n\n    Returns:\n        True if pad is playing\n    \"\"\"\n    with self._lock:\n        return pad_index in self._playing_pads\n</code></pre>"},{"location":"api/core/state_machine/#launchsampler.core.state_machine.SamplerStateMachine.get_playing_pads","title":"<code>get_playing_pads()</code>","text":"<p>Get list of all currently playing pads.</p> <p>Returns:</p> Type Description <code>list[int]</code> <p>List of pad indices that are currently playing</p> Source code in <code>src/launchsampler/core/state_machine.py</code> <pre><code>def get_playing_pads(self) -&gt; list[int]:\n    \"\"\"\n    Get list of all currently playing pads.\n\n    Returns:\n        List of pad indices that are currently playing\n    \"\"\"\n    with self._lock:\n        return list(self._playing_pads)\n</code></pre>"},{"location":"api/devices/","title":"Devices","text":"<p>MIDI device interface and hardware adapters</p> <p>Generic device infrastructure for grid-based MIDI controllers.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController","title":"<code>DeviceController(poll_interval=5.0)</code>","text":"<p>High-level controller for grid-based MIDI devices.</p> <p>Composes MidiManager with device registry to provide a clean, user-facing API for controlling any supported grid device (Launchpad, APC, etc.).</p> <p>The controller automatically detects connected devices using the registry and provides a unified API regardless of the specific hardware model.</p> <p>Initialize device controller.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __init__(self, poll_interval: float = 5.0):\n    \"\"\"\n    Initialize device controller.\n\n    Args:\n        poll_interval: How often to check for device changes (seconds)\n    \"\"\"\n    # Create device registry\n    self._registry = DeviceRegistry()\n\n    # Detected device config (set when device is detected)\n    self._detected_config: Optional[DeviceConfig] = None\n\n    # Use generic MidiManager with config-driven device filter and port selectors\n    self._midi = MidiManager(\n        device_filter=self._device_filter,\n        poll_interval=poll_interval,\n        input_port_selector=self._select_input_port,\n        output_port_selector=self._select_output_port\n    )\n    self._midi.on_message(self._handle_message)\n    self._midi.on_connection_changed(self._handle_connection_changed)\n\n    # Observer pattern for MIDI events\n    self._observers = ObserverManager[MidiObserver](observer_type_name=\"MIDI\")\n\n    # Device instance (created when connected)\n    self._device: Optional[GenericDevice] = None\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if a device is connected.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the model name of the connected device.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceController.start","title":"<code>start()</code>","text":"<p>Start monitoring for supported MIDI devices.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for supported MIDI devices.\"\"\"\n    self._midi.start()\n    logger.info(\"DeviceController started\")\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    # Shutdown device output (exit programmer mode) before stopping MIDI\n    if self._device:\n        try:\n            self._device.output.shutdown()\n            logger.info(\"Device shut down\")\n        except Exception as e:\n            logger.error(f\"Error shutting down device: {e}\")\n        self._device = None\n\n    self._midi.stop()\n    logger.info(\"DeviceController stopped\")\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register observer for MIDI events.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def register_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Register observer for MIDI events.\"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister observer.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def unregister_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Unregister observer.\"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_color","title":"<code>set_pad_color(pad_index, color)</code>","text":"<p>Set LED color for a pad (RGB mode).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_color(self, pad_index: int, color: Color) -&gt; bool:\n    \"\"\"\n    Set LED color for a pad (RGB mode).\n\n    Args:\n        pad_index: Pad 0-63\n        color: RGB color\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad color: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad color: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Bulk update multiple LED colors (more efficient than individual updates).</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[tuple[int, Color]]</code> <p>List of (pad_index, color) tuples</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_leds_bulk(self, updates: list[tuple[int, Color]]) -&gt; bool:\n    \"\"\"\n    Bulk update multiple LED colors (more efficient than individual updates).\n\n    Args:\n        updates: List of (pad_index, color) tuples\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set LEDs bulk: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_leds_bulk(updates)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting LEDs bulk: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_static","title":"<code>set_pad_static(pad_index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_static(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad static: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_static(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad static: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_flashing","title":"<code>set_pad_flashing(pad_index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_flashing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad flashing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_flashing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad flashing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceController.set_pad_pulsing","title":"<code>set_pad_pulsing(pad_index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_pulsing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad pulsing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_pulsing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad pulsing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceEvent","title":"<code>DeviceEvent</code>","text":"<p>Generic device event (input from hardware).</p>"},{"location":"api/devices/#launchsampler.devices.PadPressEvent","title":"<code>PadPressEvent(pad_index, velocity)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was pressed.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int, velocity: int):\n    self.pad_index = pad_index  # Logical 0-63\n    self.velocity = velocity\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.PadReleaseEvent","title":"<code>PadReleaseEvent(pad_index)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was released.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int):\n    self.pad_index = pad_index  # Logical 0-63\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceInput","title":"<code>DeviceInput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device input handling.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming message into device event.</p> <p>Must handle hardware-specific note mapping internally and return events with logical pad indices (0-63).</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def parse_message(self, msg) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming message into device event.\n\n    Must handle hardware-specific note mapping internally and\n    return events with logical pad indices (0-63).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput","title":"<code>DeviceOutput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device output/display control.</p>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the output device.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the output device.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown and cleanup.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown and cleanup.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED by logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_led(self, index: int, color: 'Color') -&gt; None:\n    \"\"\"\n    Set single LED by logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, 'Color']]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/#launchsampler.devices.DeviceOutput.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/config/","title":"Config","text":""},{"location":"api/devices/config/#launchsampler.devices.config","title":"<code>config</code>","text":"<p>Pydantic-based device configuration for runtime use.</p> <p>This module defines DeviceConfig, which is the flattened runtime representation created by merging family defaults with device-specific overrides.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig","title":"<code>DeviceConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Flattened device configuration (family + device merged).</p> <p>This is the runtime representation used by the application. Created by merging family defaults with device-specific overrides.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Human-readable device name.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Number of pads on device.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Grid size.</p>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.matches","title":"<code>matches(port_name)</code>","text":"<p>Check if port name matches this device's detection patterns.</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def matches(self, port_name: str) -&gt; bool:\n    \"\"\"Check if port name matches this device's detection patterns.\"\"\"\n    return any(pattern in port_name for pattern in self.detection_patterns)\n</code></pre>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.select_input_port","title":"<code>select_input_port(matching_ports)</code>","text":"<p>Select best input port from matching ports using OS-specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>matching_ports</code> <code>list[str]</code> <p>List of port names that already match detection patterns</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Selected port name or None if list is empty</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def select_input_port(self, matching_ports: list[str]) -&gt; Optional[str]:\n    \"\"\"\n    Select best input port from matching ports using OS-specific rules.\n\n    Args:\n        matching_ports: List of port names that already match detection patterns\n\n    Returns:\n        Selected port name or None if list is empty\n    \"\"\"\n    if not matching_ports:\n        return None\n\n    rules = self.input_port_selection.get_for_current_os()\n    return self._apply_port_rules(matching_ports, rules)\n</code></pre>"},{"location":"api/devices/config/#launchsampler.devices.config.DeviceConfig.select_output_port","title":"<code>select_output_port(matching_ports)</code>","text":"<p>Select best output port from matching ports using OS-specific rules.</p> <p>Parameters:</p> Name Type Description Default <code>matching_ports</code> <code>list[str]</code> <p>List of port names that already match detection patterns</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Selected port name or None if list is empty</p> Source code in <code>src/launchsampler/devices/config.py</code> <pre><code>def select_output_port(self, matching_ports: list[str]) -&gt; Optional[str]:\n    \"\"\"\n    Select best output port from matching ports using OS-specific rules.\n\n    Args:\n        matching_ports: List of port names that already match detection patterns\n\n    Returns:\n        Selected port name or None if list is empty\n    \"\"\"\n    if not matching_ports:\n        return None\n\n    rules = self.output_port_selection.get_for_current_os()\n    return self._apply_port_rules(matching_ports, rules)\n</code></pre>"},{"location":"api/devices/controller/","title":"Controller","text":""},{"location":"api/devices/controller/#launchsampler.devices.controller","title":"<code>controller</code>","text":"<p>Generic device controller for grid-based MIDI controllers.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--architecture-overview","title":"Architecture Overview","text":"<p>The DeviceController is the main user-facing API for interacting with MIDI grid controllers. It sits at the top of the device architecture and hides all hardware complexity from the application.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--connection-flow","title":"Connection Flow","text":"<p>::</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         USER APPLICATION                            \u2502\n\u2502                    (Your Sampler Software)                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                             \u2502\n                    Uses high-level API\n                             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DeviceController                                 \u2502\n\u2502                  (devices/controller.py)                            \u2502\n\u2502                                                                     \u2502\n\u2502  \ud83c\udfae What it does:                                                   \u2502\n\u2502    - Manages connection to the device                              \u2502\n\u2502    - Provides user-friendly methods (set_pad_color, etc.)          \u2502\n\u2502    - Handles observers (notify when buttons pressed)               \u2502\n\u2502    - Hides all the complexity below                                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                 \u2502                        \u2502\n    Asks for help    Detects devices         Sends messages\n           \u2193                 \u2193                        \u2193\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 DeviceRegistry\u2502 \u2502 MidiManager  \u2502      \u2502  MidiManager    \u2502\n   \u2502 (registry.py) \u2502 \u2502 (generic)    \u2502      \u2502  (output)       \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n    Loads config &amp;\n    creates device\n           \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        GenericDevice                                 \u2502\n\u2502                         (device.py)                                  \u2502\n\u2502                                                                      \u2502\n\u2502  Two sides:                                                          \u2502\n\u2502    - Input: MIDI messages \u2192 Events (button presses)                 \u2502\n\u2502    - Output: Commands \u2192 MIDI messages (LED control)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller--key-design-principle","title":"Key Design Principle","text":"<p>The DeviceController knows NOTHING about: - MIDI note numbers - SysEx messages - Hardware-specific quirks</p> <p>It only deals with logical pad indices (0-63) and abstract colors. All hardware translation happens in the layers below.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller--usage-example","title":"Usage Example","text":"<p>.. code-block:: python</p> <pre><code>controller = DeviceController()\ncontroller.start()\ncontroller.set_pad_color(21, Color(255, 0, 0))  # Works with ANY device!\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController","title":"<code>DeviceController(poll_interval=5.0)</code>","text":"<p>High-level controller for grid-based MIDI devices.</p> <p>Composes MidiManager with device registry to provide a clean, user-facing API for controlling any supported grid device (Launchpad, APC, etc.).</p> <p>The controller automatically detects connected devices using the registry and provides a unified API regardless of the specific hardware model.</p> <p>Initialize device controller.</p> <p>Parameters:</p> Name Type Description Default <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __init__(self, poll_interval: float = 5.0):\n    \"\"\"\n    Initialize device controller.\n\n    Args:\n        poll_interval: How often to check for device changes (seconds)\n    \"\"\"\n    # Create device registry\n    self._registry = DeviceRegistry()\n\n    # Detected device config (set when device is detected)\n    self._detected_config: Optional[DeviceConfig] = None\n\n    # Use generic MidiManager with config-driven device filter and port selectors\n    self._midi = MidiManager(\n        device_filter=self._device_filter,\n        poll_interval=poll_interval,\n        input_port_selector=self._select_input_port,\n        output_port_selector=self._select_output_port\n    )\n    self._midi.on_message(self._handle_message)\n    self._midi.on_connection_changed(self._handle_connection_changed)\n\n    # Observer pattern for MIDI events\n    self._observers = ObserverManager[MidiObserver](observer_type_name=\"MIDI\")\n\n    # Device instance (created when connected)\n    self._device: Optional[GenericDevice] = None\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if a device is connected.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.device_name","title":"<code>device_name</code>  <code>property</code>","text":"<p>Get the model name of the connected device.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.start","title":"<code>start()</code>","text":"<p>Start monitoring for supported MIDI devices.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for supported MIDI devices.\"\"\"\n    self._midi.start()\n    logger.info(\"DeviceController started\")\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    # Shutdown device output (exit programmer mode) before stopping MIDI\n    if self._device:\n        try:\n            self._device.output.shutdown()\n            logger.info(\"Device shut down\")\n        except Exception as e:\n            logger.error(f\"Error shutting down device: {e}\")\n        self._device = None\n\n    self._midi.stop()\n    logger.info(\"DeviceController stopped\")\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register observer for MIDI events.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def register_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Register observer for MIDI events.\"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister observer.</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def unregister_observer(self, observer: MidiObserver) -&gt; None:\n    \"\"\"Unregister observer.\"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_color","title":"<code>set_pad_color(pad_index, color)</code>","text":"<p>Set LED color for a pad (RGB mode).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_color(self, pad_index: int, color: Color) -&gt; bool:\n    \"\"\"\n    Set LED color for a pad (RGB mode).\n\n    Args:\n        pad_index: Pad 0-63\n        color: RGB color\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad color: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad color: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Bulk update multiple LED colors (more efficient than individual updates).</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>list[tuple[int, Color]]</code> <p>List of (pad_index, color) tuples</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_leds_bulk(self, updates: list[tuple[int, Color]]) -&gt; bool:\n    \"\"\"\n    Bulk update multiple LED colors (more efficient than individual updates).\n\n    Args:\n        updates: List of (pad_index, color) tuples\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set LEDs bulk: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_leds_bulk(updates)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting LEDs bulk: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_static","title":"<code>set_pad_static(pad_index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_static(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad static: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_static(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad static: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_flashing","title":"<code>set_pad_flashing(pad_index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_flashing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad flashing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_flashing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad flashing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/controller/#launchsampler.devices.controller.DeviceController.set_pad_pulsing","title":"<code>set_pad_pulsing(pad_index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad 0-63</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/devices/controller.py</code> <pre><code>def set_pad_pulsing(self, pad_index: int, color: int) -&gt; bool:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        pad_index: Pad 0-63\n        color: Palette color index (0-127)\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    if not self._device:\n        logger.warning(\"Cannot set pad pulsing: No device connected\")\n        return False\n\n    try:\n        self._device.output.set_led_pulsing(pad_index, color)\n        return True\n    except Exception as e:\n        logger.error(f\"Error setting pad pulsing: {e}\")\n        return False\n</code></pre>"},{"location":"api/devices/device/","title":"Device","text":""},{"location":"api/devices/device/#launchsampler.devices.device","title":"<code>device</code>","text":"<p>Generic device implementation using config-driven architecture.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice","title":"<code>GenericDevice(config, input_handler, output_handler)</code>","text":"<p>Generic MIDI device implementation.</p> <p>Composes generic input parsing with device-specific output control and note mapping, configured via DeviceConfig.</p> <p>Initialize generic device.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required <code>input_handler</code> <code>DeviceInput</code> <p>Device input parser (usually GenericInput with device mapper)</p> required <code>output_handler</code> <code>DeviceOutput</code> <p>Device-specific output controller</p> required Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>def __init__(\n    self,\n    config: DeviceConfig,\n    input_handler: DeviceInput,\n    output_handler: DeviceOutput\n):\n    \"\"\"\n    Initialize generic device.\n\n    Args:\n        config: Device configuration\n        input_handler: Device input parser (usually GenericInput with device mapper)\n        output_handler: Device-specific output controller\n    \"\"\"\n    self.config = config\n    self._input = input_handler\n    self._output = output_handler\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.input","title":"<code>input</code>  <code>property</code>","text":"<p>Get input handler.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.output","title":"<code>output</code>  <code>property</code>","text":"<p>Get output controller.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.num_pads","title":"<code>num_pads</code>  <code>property</code>","text":"<p>Get number of pads on this device.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get grid size.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Get human-readable device name.</p>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.matches","title":"<code>matches(port_name, config)</code>  <code>staticmethod</code>","text":"<p>Check if port name matches device.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef matches(port_name: str, config: DeviceConfig) -&gt; bool:\n    \"\"\"Check if port name matches device.\"\"\"\n    return config.matches(port_name)\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.select_input_port","title":"<code>select_input_port(matching_ports, config)</code>  <code>staticmethod</code>","text":"<p>Select best input port using device config.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef select_input_port(matching_ports: list[str], config: DeviceConfig) -&gt; Optional[str]:\n    \"\"\"Select best input port using device config.\"\"\"\n    return config.select_input_port(matching_ports)\n</code></pre>"},{"location":"api/devices/device/#launchsampler.devices.device.GenericDevice.select_output_port","title":"<code>select_output_port(matching_ports, config)</code>  <code>staticmethod</code>","text":"<p>Select best output port using device config.</p> Source code in <code>src/launchsampler/devices/device.py</code> <pre><code>@staticmethod\ndef select_output_port(matching_ports: list[str], config: DeviceConfig) -&gt; Optional[str]:\n    \"\"\"Select best output port using device config.\"\"\"\n    return config.select_output_port(matching_ports)\n</code></pre>"},{"location":"api/devices/input/","title":"Input","text":""},{"location":"api/devices/input/#launchsampler.devices.input","title":"<code>input</code>","text":"<p>Generic MIDI input parsing for all devices.</p>"},{"location":"api/devices/input/#launchsampler.devices.input--input-flow-button-press-your-code","title":"Input Flow: Button Press \u2192 Your Code","text":"<p>This module handles the INPUT SIDE of device communication - transforming hardware MIDI messages into logical application events.</p>"},{"location":"api/devices/input/#launchsampler.devices.input--the-flow","title":"The Flow","text":"<p>::</p> <pre><code>Hardware Button Press\n      \u2193\n[MIDI Message: note_on 36, velocity 100]\n      \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      GenericInput                    \u2502\n\u2502       (input.py)                     \u2502\n\u2502                                      \u2502\n\u2502  parse_message(msg):                 \u2502\n\u2502    if msg.type == 'note_on':         \u2502\n\u2502      index = mapper.note_to_index(36)\u2502\n\u2502      return PadPressEvent(index=5)   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502 Uses mapper\n             \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   LaunchpadMK3Mapper                 \u2502\n\u2502   (adapters/launchpad_mk3.py)        \u2502\n\u2502                                      \u2502\n\u2502  note_to_index(36):                  \u2502\n\u2502    offset = 11                       \u2502\n\u2502    row_spacing = 10                  \u2502\n\u2502    note_index = note - offset = 25   \u2502\n\u2502    row = 25 // 10 = 2                \u2502\n\u2502    col = 25 % 10 = 5                 \u2502\n\u2502    return row * 8 + col = 21         \u2502\n\u2502                                      \u2502\n\u2502  Hardware layout:                    \u2502\n\u2502    Note 11 = bottom-left (0,0)       \u2502\n\u2502    Note 36 = pad at (2,5)            \u2502\n\u2502    Logical index 21                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2193\n[PadPressEvent(pad_index=21, velocity=100)]\n      \u2193\nYour application observers get notified\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input--key-concepts","title":"Key Concepts","text":"<p>Hardware Independence: GenericInput knows nothing about specific devices. It just asks the mapper \"what logical index is this MIDI note?\"</p> <p>Logical vs Hardware Indices: - Hardware: MIDI note 36 (device-specific) - Logical: Pad index 21 (universal across all devices)</p> <p>Velocity Handling: MIDI velocity (0-127) is preserved for pressure-sensitive applications. Note that velocity=0 on note_on is actually a note_off.</p>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper","title":"<code>NoteMapper</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device-specific note mapping.</p>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper.note_to_index","title":"<code>note_to_index(note)</code>","text":"<p>Convert hardware MIDI note to logical pad index.</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def note_to_index(self, note: int) -&gt; Optional[int]:\n    \"\"\"Convert hardware MIDI note to logical pad index.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.NoteMapper.index_to_note","title":"<code>index_to_note(index)</code>","text":"<p>Convert logical pad index to hardware MIDI note.</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def index_to_note(self, index: int) -&gt; int:\n    \"\"\"Convert logical pad index to hardware MIDI note.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.GenericInput","title":"<code>GenericInput(mapper)</code>","text":"<p>               Bases: <code>DeviceInput</code></p> <p>Generic MIDI input parser.</p> <p>Handles standard MIDI messages (note_on, note_off, control_change) and delegates hardware-specific note mapping to a device mapper.</p> <p>Initialize generic input parser.</p> <p>Parameters:</p> Name Type Description Default <code>mapper</code> <code>NoteMapper</code> <p>Device-specific note mapper for converting    hardware MIDI notes to logical pad indices</p> required Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def __init__(self, mapper: NoteMapper):\n    \"\"\"\n    Initialize generic input parser.\n\n    Args:\n        mapper: Device-specific note mapper for converting\n               hardware MIDI notes to logical pad indices\n    \"\"\"\n    self.mapper = mapper\n</code></pre>"},{"location":"api/devices/input/#launchsampler.devices.input.GenericInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming MIDI message into device events.</p> <p>Transforms hardware MIDI note numbers to logical pad indices using the device-specific note mapper.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Message</code> <p>MIDI message</p> required <p>Returns:</p> Type Description <code>Optional[DeviceEvent]</code> <p>DeviceEvent with logical pad index, or None if message</p> <code>Optional[DeviceEvent]</code> <p>should be ignored or is not supported</p> Source code in <code>src/launchsampler/devices/input.py</code> <pre><code>def parse_message(self, msg: mido.Message) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming MIDI message into device events.\n\n    Transforms hardware MIDI note numbers to logical pad indices\n    using the device-specific note mapper.\n\n    Args:\n        msg: MIDI message\n\n    Returns:\n        DeviceEvent with logical pad index, or None if message\n        should be ignored or is not supported\n    \"\"\"\n    # Filter out clock messages\n    if msg.type == 'clock':\n        return None\n\n    # Handle note on/off\n    if msg.type == 'note_on':\n        # Convert note to logical index using device mapper\n        pad_index = self.mapper.note_to_index(msg.note)\n        if pad_index is None:\n            return None  # Invalid note, not a grid pad\n\n        # Note on with velocity 0 is actually note off\n        if msg.velocity &gt; 0:\n            return PadPressEvent(pad_index, msg.velocity)\n        else:\n            return PadReleaseEvent(pad_index)\n\n    elif msg.type == 'note_off':\n        pad_index = self.mapper.note_to_index(msg.note)\n        if pad_index is None:\n            return None\n        return PadReleaseEvent(pad_index)\n\n    elif msg.type == 'control_change':\n        return ControlChangeEvent(msg.control, msg.value)\n\n    return None\n</code></pre>"},{"location":"api/devices/protocols/","title":"Protocols","text":""},{"location":"api/devices/protocols/#launchsampler.devices.protocols","title":"<code>protocols</code>","text":"<p>Generic device protocols and abstractions.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceEvent","title":"<code>DeviceEvent</code>","text":"<p>Generic device event (input from hardware).</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.PadPressEvent","title":"<code>PadPressEvent(pad_index, velocity)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was pressed.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int, velocity: int):\n    self.pad_index = pad_index  # Logical 0-63\n    self.velocity = velocity\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.PadReleaseEvent","title":"<code>PadReleaseEvent(pad_index)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>Pad was released.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, pad_index: int):\n    self.pad_index = pad_index  # Logical 0-63\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.ControlChangeEvent","title":"<code>ControlChangeEvent(control, value)</code>","text":"<p>               Bases: <code>DeviceEvent</code></p> <p>MIDI control change received.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def __init__(self, control: int, value: int):\n    self.control = control\n    self.value = value\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceInput","title":"<code>DeviceInput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device input handling.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceInput.parse_message","title":"<code>parse_message(msg)</code>","text":"<p>Parse incoming message into device event.</p> <p>Must handle hardware-specific note mapping internally and return events with logical pad indices (0-63).</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def parse_message(self, msg) -&gt; Optional[DeviceEvent]:\n    \"\"\"\n    Parse incoming message into device event.\n\n    Must handle hardware-specific note mapping internally and\n    return events with logical pad indices (0-63).\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput","title":"<code>DeviceOutput</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for device output/display control.</p>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the output device.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Initialize the output device.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown and cleanup.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Shutdown and cleanup.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED by logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_led(self, index: int, color: 'Color') -&gt; None:\n    \"\"\"\n    Set single LED by logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, 'Color']]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/protocols/#launchsampler.devices.protocols.DeviceOutput.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs.</p> Source code in <code>src/launchsampler/devices/protocols.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs.\"\"\"\n    ...\n</code></pre>"},{"location":"api/devices/registry/","title":"Registry","text":""},{"location":"api/devices/registry/#launchsampler.devices.registry","title":"<code>registry</code>","text":"<p>Device registry using Pydantic models for configuration validation.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry--the-smart-factory","title":"The Smart Factory","text":"<p>The DeviceRegistry is the \"factory\" that knows how to build the right device controller based on what's plugged into USB. It reads configuration from devices.json and assembles complete devices from modular components.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry--how-device-detection-works","title":"How Device Detection Works","text":"<p>::</p> <pre><code>USB Device Connected: \"Launchpad Pro MK3 MIDI\"\n                              \u2193\nRegistry checks devices.json: \"Does 'LPProMK3' match patterns?\"\n                              \u2193 YES\nRegistry: \"This is a Launchpad Pro MK3\"\n         \"It implements: LaunchpadMK3\"\n         \"Prefer port: LPProMK3 MIDI 0\"\n                              \u2193\nRegistry looks up implementation: get_implementation(\"LaunchpadMK3\")\n                              \u2193 Returns\n         (LaunchpadMK3Mapper, LaunchpadMK3Output)\n                              \u2193\nRegistry creates: GenericDevice(\n    mapper=LaunchpadMK3Mapper(),\n    input=GenericInput(mapper),\n    output=LaunchpadMK3Output(midi_manager, config)\n)\n                              \u2193\nReturns fully assembled device to DeviceController\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry--device-creation-flow","title":"Device Creation Flow","text":"<p>::</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        DeviceRegistry                                \u2502\n\u2502                       (registry.py)                                  \u2502\n\u2502                                                                      \u2502\n\u2502  \ud83c\udfed What it does:                                                    \u2502\n\u2502    1. Loads devices.json at startup                                 \u2502\n\u2502    2. When USB device appears, checks if name matches patterns      \u2502\n\u2502    3. Selects the right USB ports (OS-specific rules)               \u2502\n\u2502    4. Assembles a GenericDevice from parts:                         \u2502\n\u2502       - Mapper (note translation)                                   \u2502\n\u2502       - Input handler (MIDI parser)                                 \u2502\n\u2502       - Output handler (LED controller)                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Reads configuration\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        devices.json                                \u2502\n\u2502                     (Configuration File)                           \u2502\n\u2502                                                                    \u2502\n\u2502  \ud83d\udccb Contains:                                                      \u2502\n\u2502    - Family: \"launchpad_mk3\"                                       \u2502\n\u2502    - Detection patterns: [\"Launchpad Pro\", \"LPProMK3\"]            \u2502\n\u2502    - Capabilities: {num_pads: 64, grid_size: 8}                   \u2502\n\u2502    - Port selection rules (Windows/Mac/Linux)                     \u2502\n\u2502    - SysEx header: [0, 32, 41, 2, 14]                             \u2502\n\u2502    - Implements: \"LaunchpadMK3\" \u2190 Links to code                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502\n        \u2502 Points to implementation\n        \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              adapters/__init__.py                                  \u2502\n\u2502              (Implementation Registry)                             \u2502\n\u2502                                                                    \u2502\n\u2502  \ud83d\udd0d Registry lookup:                                               \u2502\n\u2502    \"LaunchpadMK3\" \u2192 (LaunchpadMK3Mapper, LaunchpadMK3Output)      \u2502\n\u2502                                                                    \u2502\n\u2502  To add new device:                                                \u2502\n\u2502    register_implementation(\"APC40\", APC40Mapper, APC40Output)     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry--key-features","title":"Key Features","text":"<p>Open/Closed Principle: Add new devices without modifying registry code. Simply add a new entry to devices.json and register the implementation.</p> <p>OS-Specific Port Selection: Handles platform differences in MIDI port naming. Different rules for Windows, macOS, and Linux.</p> <p>Declarative Configuration: All device capabilities and quirks defined in JSON, not scattered through if/else statements in code.</p> <p>Validation: Pydantic models ensure devices.json is always valid at runtime.</p>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry","title":"<code>DeviceRegistry(config_path=None)</code>","text":"<p>Registry of all supported MIDI devices.</p> <p>Loads device configurations from JSON using Pydantic validation and provides device detection and instantiation services.</p> <p>Initialize device registry.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Optional[Path]</code> <p>Path to devices.json config file.         If None, uses default location.</p> <code>None</code> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def __init__(self, config_path: Optional[Path] = None):\n    \"\"\"\n    Initialize device registry.\n\n    Args:\n        config_path: Path to devices.json config file.\n                    If None, uses default location.\n    \"\"\"\n    if config_path is None:\n        config_path = Path(__file__).parent / \"devices.json\"\n\n    self.config_path = config_path\n    self.schema: DeviceRegistrySchema = self._load_schema()\n    self.devices: list[DeviceConfig] = self._flatten_configs()\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.detect_device","title":"<code>detect_device(port_name)</code>","text":"<p>Detect which device config matches a port name.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>MIDI port name string</p> required <p>Returns:</p> Type Description <code>Optional[DeviceConfig]</code> <p>Matching DeviceConfig or None if no match found</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def detect_device(self, port_name: str) -&gt; Optional[DeviceConfig]:\n    \"\"\"\n    Detect which device config matches a port name.\n\n    Args:\n        port_name: MIDI port name string\n\n    Returns:\n        Matching DeviceConfig or None if no match found\n    \"\"\"\n    for config in self.devices:\n        if config.matches(port_name):\n            logger.debug(f\"Detected {config.model} from port: {port_name}\")\n            return config\n\n    logger.debug(f\"No device matched port: {port_name}\")\n    return None\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.get_all_patterns","title":"<code>get_all_patterns()</code>","text":"<p>Get all detection patterns across all devices.</p> <p>Useful for creating a device_filter function for MidiManager.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of all detection patterns</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def get_all_patterns(self) -&gt; list[str]:\n    \"\"\"\n    Get all detection patterns across all devices.\n\n    Useful for creating a device_filter function for MidiManager.\n\n    Returns:\n        List of all detection patterns\n    \"\"\"\n    patterns = set()\n    for config in self.devices:\n        patterns.update(config.detection_patterns)\n    return list(patterns)\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.matches_any_device","title":"<code>matches_any_device(port_name)</code>","text":"<p>Check if port name matches any registered device.</p> <p>Parameters:</p> Name Type Description Default <code>port_name</code> <code>str</code> <p>MIDI port name string</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if port matches any device</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def matches_any_device(self, port_name: str) -&gt; bool:\n    \"\"\"\n    Check if port name matches any registered device.\n\n    Args:\n        port_name: MIDI port name string\n\n    Returns:\n        True if port matches any device\n    \"\"\"\n    return self.detect_device(port_name) is not None\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.DeviceRegistry.create_device","title":"<code>create_device(config, midi_manager)</code>","text":"<p>Create a device instance from configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required <code>midi_manager</code> <code>MidiManager</code> <p>MIDI manager instance</p> required <p>Returns:</p> Type Description <code>GenericDevice</code> <p>GenericDevice instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If implementation not found</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def create_device(\n    self,\n    config: DeviceConfig,\n    midi_manager: \"MidiManager\"\n) -&gt; \"GenericDevice\":\n    \"\"\"\n    Create a device instance from configuration.\n\n    Args:\n        config: Device configuration\n        midi_manager: MIDI manager instance\n\n    Returns:\n        GenericDevice instance\n\n    Raises:\n        ValueError: If implementation not found\n    \"\"\"\n    from .adapters import get_adapter\n    from .device import GenericDevice\n    from .input import GenericInput\n\n    # Look up adapter classes\n    adapter = get_adapter(config.implements)\n    if adapter is None:\n        raise ValueError(f\"Unknown adapter: {config.implements}\")\n\n    MapperClass, OutputClass = adapter\n\n    # Instantiate device-specific components\n    mapper = MapperClass(config)\n    input_handler = GenericInput(mapper)\n    output_handler = OutputClass(midi_manager, config)\n\n    # Wrap in GenericDevice\n    return GenericDevice(config, input_handler, output_handler)\n</code></pre>"},{"location":"api/devices/registry/#launchsampler.devices.registry.get_registry","title":"<code>get_registry()</code>","text":"<p>Get singleton DeviceRegistry instance.</p> Source code in <code>src/launchsampler/devices/registry.py</code> <pre><code>def get_registry() -&gt; DeviceRegistry:\n    \"\"\"Get singleton DeviceRegistry instance.\"\"\"\n    global _registry\n    if _registry is None:\n        _registry = DeviceRegistry()\n    return _registry\n</code></pre>"},{"location":"api/devices/schema/","title":"Schema","text":""},{"location":"api/devices/schema/#launchsampler.devices.schema","title":"<code>schema</code>","text":"<p>Pydantic models for device configuration schema.</p> <p>This module defines the structure of the devices.json configuration file using Pydantic v2 for type safety and validation.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.PortSelectionRules","title":"<code>PortSelectionRules</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Port selection rules for a specific OS.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.OSPortSelection","title":"<code>OSPortSelection</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>OS-specific port selection rules.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.OSPortSelection.get_for_current_os","title":"<code>get_for_current_os()</code>","text":"<p>Get rules for current operating system.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>def get_for_current_os(self) -&gt; PortSelectionRules:\n    \"\"\"Get rules for current operating system.\"\"\"\n    os_name = platform.system().lower()\n    return getattr(self, os_name, PortSelectionRules())\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceCapabilities","title":"<code>DeviceCapabilities</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device hardware capabilities.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceOverrides","title":"<code>DeviceOverrides</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device-specific overrides for family defaults.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.Device","title":"<code>Device</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Individual device configuration within a family.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.Device.validate_sysex_header","title":"<code>validate_sysex_header(v)</code>  <code>classmethod</code>","text":"<p>Validate SysEx header bytes are in valid range.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@field_validator(\"sysex_header\")\n@classmethod\ndef validate_sysex_header(cls, v: Optional[list[int]]) -&gt; Optional[list[int]]:\n    \"\"\"Validate SysEx header bytes are in valid range.\"\"\"\n    if v is not None:\n        for byte in v:\n            if not 0 &lt;= byte &lt;= 127:\n                raise ValueError(f\"SysEx byte {byte} out of range (0-127)\")\n    return v\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceFamily","title":"<code>DeviceFamily</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Device family configuration (e.g., Launchpad MK3 family).</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema","title":"<code>DeviceRegistrySchema</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Root schema for the devices.json configuration file.</p>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.from_json_file","title":"<code>from_json_file(path)</code>  <code>classmethod</code>","text":"<p>Load registry from JSON file with validation.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@classmethod\ndef from_json_file(cls, path: Path) -&gt; \"DeviceRegistrySchema\":\n    \"\"\"Load registry from JSON file with validation.\"\"\"\n    with open(path, \"r\") as f:\n        return cls.model_validate_json(f.read())\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.to_json_file","title":"<code>to_json_file(path, indent=2)</code>","text":"<p>Save registry to JSON file.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>def to_json_file(self, path: Path, indent: int = 2) -&gt; None:\n    \"\"\"Save registry to JSON file.\"\"\"\n    with open(path, \"w\") as f:\n        f.write(self.model_dump_json(indent=indent))\n</code></pre>"},{"location":"api/devices/schema/#launchsampler.devices.schema.DeviceRegistrySchema.generate_json_schema","title":"<code>generate_json_schema(path)</code>  <code>classmethod</code>","text":"<p>Generate JSON schema for documentation and IDE support.</p> Source code in <code>src/launchsampler/devices/schema.py</code> <pre><code>@classmethod\ndef generate_json_schema(cls, path: Path) -&gt; None:\n    \"\"\"Generate JSON schema for documentation and IDE support.\"\"\"\n    import json\n    schema = cls.model_json_schema()\n    with open(path, \"w\") as f:\n        json.dump(schema, f, indent=2)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/","title":"Launchpad Mk3","text":""},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3","title":"<code>launchpad_mk3</code>","text":"<p>Launchpad MK3 family implementation (Pro, Mini, X).</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--hardware-specific-implementation","title":"Hardware-Specific Implementation","text":"<p>This module contains the device-specific \"brains\" for Launchpad MK3 devices. It translates between logical pad indices and hardware MIDI notes, and builds SysEx messages for LED control.</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--mapper-logical-hardware-translation","title":"Mapper: Logical \u2194 Hardware Translation","text":"<p>The LaunchpadMK3Mapper translates between logical indices and MIDI notes.</p> <p>Input Side (Button Press)::</p> <pre><code>Hardware Button Press \u2192 MIDI note 36\n                            \u2193\nLaunchpadMK3Mapper.note_to_index(36):\n  offset = 11\n  row_spacing = 10\n  note_index = 36 - 11 = 25\n  row = 25 // 10 = 2\n  col = 25 % 10 = 5\n  return row * 8 + col = 21\n                            \u2193\nLogical pad index 21\n</code></pre> <p>Output Side (LED Control)::</p> <pre><code>Your code: set_pad_color(index=21, Color(255, 0, 0))\n                            \u2193\nLaunchpadMK3Mapper.index_to_note(21):\n  row = 21 // 8 = 2\n  col = 21 % 8 = 5\n  note = 11 + (row * 10) + col\n  return 11 + 20 + 5 = 36\n                            \u2193\nMIDI note 36\n                            \u2193\nLaunchpadSysEx.led_lighting([(RGB, 36, 255, 0, 0)])\n                            \u2193\n[0xF0, 0, 32, 41, 2, 14, 0x03, 3, 36, 255, 0, 0, 0xF7]\n                            \u2193\nHardware LED turns RED\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--hardware-layout","title":"Hardware Layout","text":"<p>Launchpad MK3 in programmer mode uses this note layout::</p> <pre><code>Row 7: 81 82 83 84 85 86 87 88    (top row)\nRow 6: 71 72 73 74 75 76 77 78\nRow 5: 61 62 63 64 65 66 67 68\nRow 4: 51 52 53 54 55 56 57 58\nRow 3: 41 42 43 44 45 46 47 48\nRow 2: 31 32 33 34 35 36 37 38\nRow 1: 21 22 23 24 25 26 27 28\nRow 0: 11 12 13 14 15 16 17 18    (bottom row)\n       \u2514\u2500 bottom-left pad\n</code></pre> <p>Note the row spacing of 10 (includes gaps like 19, 29, etc.)</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3--key-design-decisions","title":"Key Design Decisions","text":"<p>Why separate Mapper from Output?</p> <ul> <li>Mapper: Pure mathematical translation (no side effects)</li> <li>Output: Manages hardware state and sends MIDI messages</li> </ul> <p>This separation makes testing trivial - you can verify note mapping without needing actual hardware.</p> <p>Why store offset/spacing as constants?</p> <p>All MK3 devices (Pro, Mini, X) use the same programmer mode layout. If Novation releases an MK4 with different layout, create a new mapper class.</p>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper","title":"<code>LaunchpadMK3Mapper(config)</code>","text":"<p>Note mapper for Launchpad MK3 family devices.</p> <p>Maps between MIDI notes and logical pad indices/coordinates. All MK3 models (Pro, Mini, X) use the same note layout in programmer mode.</p> <p>Initialize note mapper.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>DeviceConfig</code> <p>Device configuration</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def __init__(self, config: DeviceConfig):\n    \"\"\"\n    Initialize note mapper.\n\n    Args:\n        config: Device configuration\n    \"\"\"\n    self.config = config\n    self.offset = self.PROGRAMMER_MODE_OFFSET\n    self.row_spacing = self.PROGRAMMER_MODE_ROW_SPACING\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.note_to_index","title":"<code>note_to_index(note)</code>","text":"<p>Convert MIDI note to logical pad index (0-63).</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>MIDI note number</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Pad index (0-63) or None if invalid note</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def note_to_index(self, note: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert MIDI note to logical pad index (0-63).\n\n    Args:\n        note: MIDI note number\n\n    Returns:\n        Pad index (0-63) or None if invalid note\n    \"\"\"\n    x, y = self.note_to_xy(note)\n    if x is None or y is None:\n        return None\n\n    return y * 8 + x\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>int</code> <p>MIDI note number</p> required <p>Returns:</p> Type Description <code>Tuple[Optional[int], Optional[int]]</code> <p>(x, y) tuple or (None, None) if invalid</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; Tuple[Optional[int], Optional[int]]:\n    \"\"\"\n    Convert MIDI note to (x, y) coordinates.\n\n    Args:\n        note: MIDI note number\n\n    Returns:\n        (x, y) tuple or (None, None) if invalid\n    \"\"\"\n    if note &lt; self.offset or note &gt; (self.offset + 7 * self.row_spacing + 7):\n        return (None, None)\n\n    adjusted = note - self.offset\n    row = adjusted // self.row_spacing\n    col = adjusted % self.row_spacing\n\n    if col &gt; 7 or row &gt; 7:\n        return (None, None)\n\n    return (col, row)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.index_to_note","title":"<code>index_to_note(index)</code>","text":"<p>Convert logical pad index to MIDI note.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Pad index (0-63)</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>MIDI note number or None if invalid index</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def index_to_note(self, index: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert logical pad index to MIDI note.\n\n    Args:\n        index: Pad index (0-63)\n\n    Returns:\n        MIDI note number or None if invalid index\n    \"\"\"\n    if not 0 &lt;= index &lt; 64:\n        return None\n\n    row = index // 8\n    col = index % 8\n\n    return self.xy_to_note(col, row)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Mapper.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>column (0-7)</p> required <code>y</code> <code>int</code> <p>row (0-7)</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>MIDI note number or None if invalid coordinates</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; Optional[int]:\n    \"\"\"\n    Convert (x, y) coordinates to MIDI note.\n\n    Args:\n        x: column (0-7)\n        y: row (0-7)\n\n    Returns:\n        MIDI note number or None if invalid coordinates\n    \"\"\"\n    if not (0 &lt;= x &lt; 8 and 0 &lt;= y &lt; 8):\n        return None\n\n    return self.offset + (y * self.row_spacing) + x\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output","title":"<code>LaunchpadMK3Output(midi_manager, config)</code>","text":"<p>               Bases: <code>DeviceOutput</code></p> <p>Output controller for Launchpad MK3 family.</p> <p>Handles LED control and device initialization for Launchpad Pro MK3, Mini MK3, and X models.</p> <p>Initialize Launchpad MK3 output controller.</p> <p>Parameters:</p> Name Type Description Default <code>midi_manager</code> <code>MidiManager</code> <p>MIDI manager for sending messages</p> required <code>config</code> <code>DeviceConfig</code> <p>Device configuration with SysEx header</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def __init__(self, midi_manager: MidiManager, config: DeviceConfig):\n    \"\"\"\n    Initialize Launchpad MK3 output controller.\n\n    Args:\n        midi_manager: MIDI manager for sending messages\n        config: Device configuration with SysEx header\n    \"\"\"\n    self.midi = midi_manager\n    self.config = config\n    self.mapper = LaunchpadMK3Mapper(config)\n    self.sysex = LaunchpadSysEx.from_header(config.sysex_header)\n    self._initialized = False\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.initialize","title":"<code>initialize()</code>","text":"<p>Enter programmer mode.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"Enter programmer mode.\"\"\"\n    if self._initialized:\n        logger.warning(f\"{self.config.model} already initialized\")\n        return\n\n    msg = self.sysex.programmer_mode(enable=True)\n    if self.midi.send(msg):\n        logger.info(f\"Entered programmer mode ({self.config.model})\")\n        self._initialized = True\n    else:\n        logger.error(\"Failed to enter programmer mode\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.shutdown","title":"<code>shutdown()</code>","text":"<p>Exit programmer mode and clear LEDs.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Exit programmer mode and clear LEDs.\"\"\"\n    if not self._initialized:\n        return\n\n    self.clear_all()\n\n    msg = self.sysex.programmer_mode(enable=False)\n    if self.midi.send(msg):\n        logger.info(\"Exited programmer mode\")\n        self._initialized = False\n    else:\n        logger.error(\"Failed to exit programmer mode\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led","title":"<code>set_led(index, color)</code>","text":"<p>Set single LED using logical index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>Color</code> <p>RGB color (0-127 per channel)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led(self, index: int, color: Color) -&gt; None:\n    \"\"\"\n    Set single LED using logical index.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: RGB color (0-127 per channel)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.RGB.value, note, color.r, color.g, color.b)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_leds_bulk","title":"<code>set_leds_bulk(updates)</code>","text":"<p>Set multiple LEDs efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>updates</code> <code>List[Tuple[int, Color]]</code> <p>List of (logical_index, color) tuples</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_leds_bulk(self, updates: List[Tuple[int, Color]]) -&gt; None:\n    \"\"\"\n    Set multiple LEDs efficiently.\n\n    Args:\n        updates: List of (logical_index, color) tuples\n    \"\"\"\n    if not updates:\n        return\n\n    specs = []\n    for index, color in updates:\n        note = self.mapper.index_to_note(index)\n        if note is None:\n            logger.warning(f\"Skipping invalid pad index: {index}\")\n            continue\n        specs.append((LightingMode.RGB.value, note, color.r, color.g, color.b))\n\n    if not specs:\n        return\n\n    msg = self.sysex.led_lighting(specs)\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set {len(specs)} LEDs in bulk\")\n    else:\n        logger.debug(f\"Set {len(specs)} LEDs in bulk\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_flashing","title":"<code>set_led_flashing(index, color)</code>","text":"<p>Set LED to flash using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_flashing(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to flash using palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.FLASHING.value, note, 0, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} flashing (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_pulsing","title":"<code>set_led_pulsing(index, color)</code>","text":"<p>Set LED to pulse using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_pulsing(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to pulse using palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.PULSING.value, note, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} pulsing (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_led_static","title":"<code>set_led_static(index, color)</code>","text":"<p>Set LED to static palette color.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Logical pad index (0-63)</p> required <code>color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_led_static(self, index: int, color: int) -&gt; None:\n    \"\"\"\n    Set LED to static palette color.\n\n    Args:\n        index: Logical pad index (0-63)\n        color: Palette color index (0-127)\n    \"\"\"\n    note = self.mapper.index_to_note(index)\n    if note is None:\n        logger.error(f\"Invalid pad index: {index}\")\n        return\n\n    spec = (LightingMode.STATIC.value, note, color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set LED {index} static (note {note})\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_control_led","title":"<code>set_control_led(cc_number, color)</code>","text":"<p>Set LED for control button using RGB color.</p> <p>Parameters:</p> Name Type Description Default <code>cc_number</code> <code>int</code> <p>MIDI CC control number</p> required <code>color</code> <code>Color</code> <p>RGB color (0-127 per channel)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_control_led(self, cc_number: int, color: Color) -&gt; None:\n    \"\"\"\n    Set LED for control button using RGB color.\n\n    Args:\n        cc_number: MIDI CC control number\n        color: RGB color (0-127 per channel)\n    \"\"\"\n    spec = (LightingMode.RGB.value, cc_number, color.r, color.g, color.b)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set control LED for CC {cc_number}\")\n    else:\n        logger.debug(f\"Set control LED for CC {cc_number}\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.set_control_led_static","title":"<code>set_control_led_static(cc_number, palette_color)</code>","text":"<p>Set LED for control button using palette color.</p> <p>Parameters:</p> Name Type Description Default <code>cc_number</code> <code>int</code> <p>MIDI CC control number</p> required <code>palette_color</code> <code>int</code> <p>Palette color index (0-127)</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def set_control_led_static(self, cc_number: int, palette_color: int) -&gt; None:\n    \"\"\"\n    Set LED for control button using palette color.\n\n    Args:\n        cc_number: MIDI CC control number\n        palette_color: Palette color index (0-127)\n    \"\"\"\n    spec = (LightingMode.STATIC.value, cc_number, palette_color)\n    msg = self.sysex.led_lighting([spec])\n\n    if not self.midi.send(msg):\n        logger.warning(f\"Failed to set control LED for CC {cc_number}\")\n    else:\n        logger.debug(f\"Set control LED for CC {cc_number} to palette {palette_color}\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_mk3/#launchsampler.devices.adapters.launchpad_mk3.LaunchpadMK3Output.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all LEDs (set to black).</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_mk3.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all LEDs (set to black).\"\"\"\n    specs = []\n    for index in range(64):\n        note = self.mapper.index_to_note(index)\n        if note is not None:\n            specs.append((LightingMode.STATIC.value, note, 0))\n\n    msg = self.sysex.led_lighting(specs)\n\n    if not self.midi.send(msg):\n        logger.warning(\"Failed to clear all LEDs\")\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/","title":"Launchpad Sysex","text":""},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex","title":"<code>launchpad_sysex</code>","text":"<p>Low-level SysEx message builder for Launchpad devices.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--sysex-the-launchpads-secret-language","title":"SysEx: The Launchpad's Secret Language","text":"<p>This module builds System Exclusive (SysEx) MIDI messages that control Launchpad hardware features like LED colors and device modes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--what-is-sysex","title":"What is SysEx?","text":"<p>SysEx messages are manufacturer-specific MIDI messages that allow control beyond standard MIDI. They follow this format::</p> <pre><code>[0xF0] [Manufacturer ID] [Device-specific data...] [0xF7]\n Start                                              End\n</code></pre> <p>For Novation Launchpad devices::</p> <pre><code>[0xF0, 0x00, 0x20, 0x29, 0x02, 0x0E, ...]\n \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502    \u2514\u2500 Model ID (0x0E = MK3)\n \u2502         Novation      \u2514\u2500 SysEx command type\n Start of SysEx\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--led-lighting-message-flow","title":"LED Lighting Message Flow","text":"<p>::</p> <pre><code>Your code calls:\nset_pad_color(index=21, Color(255, 0, 0))\n      \u2193\nLaunchpadMK3Output.set_led(21, color):\n  note = mapper.index_to_note(21)  # Returns 36\n  sysex = LaunchpadSysEx.led_lighting([\n    (RGB, 36, 255, 0, 0)\n  ])\n      \u2193\nLaunchpadSysEx.led_lighting(...):\n  Build message:\n    header = [0x00, 0x20, 0x29, 0x02, 0x0E]\n    command = 0x03  (LED lighting command)\n    data = [3, 36, 255, 0, 0]\n           \u2502  \u2502   \u2514\u2500\u2500\u2500 RGB values\n           \u2502  \u2514\u2500 MIDI note (hardware-specific)\n           \u2514\u2500 Lighting mode (3 = RGB)\n      \u2193\nComplete SysEx message:\n[0xF0, 0x00, 0x20, 0x29, 0x02, 0x0E, 0x03, 3, 36, 255, 0, 0, 0xF7]\n      \u2193\nSent via MIDI output\n      \u2193\nHardware LED turns RED\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--sysex-commands","title":"SysEx Commands","text":"<p>The Launchpad MK3 supports these SysEx commands:</p> <ul> <li>0x03: LED Lighting (set LED colors)</li> <li>0x0E: Programmer Mode (enable/disable custom mode)</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--lighting-modes","title":"Lighting Modes","text":"<p>When setting LED colors, you can use different modes:</p> <ul> <li>STATIC (0): Use a color from the device palette (0-127)</li> <li>FLASHING (1): Flash between two palette colors</li> <li>PULSING (2): Pulse a palette color</li> <li>RGB (3): Direct RGB color (most common, used by this implementation)</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--example-rgb-message","title":"Example RGB Message","text":"<p>To light pad at MIDI note 36 with red color::</p> <pre><code>Data: [3, 36, 255, 0, 0]\n       \u2502  \u2502   \u2502   \u2502  \u2502\n       \u2502  \u2502   \u2502   \u2502  \u2514\u2500 Blue: 0\n       \u2502  \u2502   \u2502   \u2514\u2500 Green: 0\n       \u2502  \u2502   \u2514\u2500 Red: 255\n       \u2502  \u2514\u2500 MIDI note: 36\n       \u2514\u2500 Mode: RGB (3)\n</code></pre> <p>You can send multiple LED specs in one message::</p> <pre><code>led_lighting([\n    (RGB, 36, 255, 0, 0),    # Note 36: Red\n    (RGB, 37, 0, 255, 0),    # Note 37: Green\n    (RGB, 38, 0, 0, 255),    # Note 38: Blue\n])\n</code></pre> <p>This is more efficient than sending three separate messages.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--key-design-principle","title":"Key Design Principle","text":"<p>Hardware abstraction boundary: This module is the LOWEST level of hardware interaction. It knows about MIDI notes (not logical indices) and SysEx byte sequences (not Color objects).</p> <p>The layer above (LaunchpadMK3Output) handles the translation from high-level concepts to low-level bytes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex--references","title":"References","text":"<ul> <li>Launchpad Pro MK3 Programmer's Reference Manual</li> <li>MIDI System Exclusive specification</li> </ul>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LightingMode","title":"<code>LightingMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>LED lighting modes.</p>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx","title":"<code>LaunchpadSysEx(header)</code>","text":"<p>Low-level SysEx message builder for Launchpad devices.</p> <p>Initialize with SysEx header.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>list[int]</code> <p>Raw SysEx header bytes</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def __init__(self, header: list[int]):\n    \"\"\"\n    Initialize with SysEx header.\n\n    Args:\n        header: Raw SysEx header bytes\n    \"\"\"\n    self.header = header\n    self.model = None  # Kept for backwards compatibility\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.from_header","title":"<code>from_header(header)</code>  <code>classmethod</code>","text":"<p>Create LaunchpadSysEx from raw SysEx header.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>list[int]</code> <p>Raw SysEx header bytes</p> required <p>Returns:</p> Type Description <code>LaunchpadSysEx</code> <p>LaunchpadSysEx instance</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>@classmethod\ndef from_header(cls, header: list[int]) -&gt; 'LaunchpadSysEx':\n    \"\"\"\n    Create LaunchpadSysEx from raw SysEx header.\n\n    Args:\n        header: Raw SysEx header bytes\n\n    Returns:\n        LaunchpadSysEx instance\n    \"\"\"\n    return cls(header)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.programmer_mode","title":"<code>programmer_mode(enable)</code>","text":"<p>Build programmer mode toggle message.</p> Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def programmer_mode(self, enable: bool) -&gt; mido.Message:\n    \"\"\"Build programmer mode toggle message.\"\"\"\n    data = self.header + [0x0E, 0x01 if enable else 0x00]\n    return mido.Message('sysex', data=data)\n</code></pre>"},{"location":"api/devices/adapters/launchpad_sysex/#launchsampler.devices.adapters.launchpad_sysex.LaunchpadSysEx.led_lighting","title":"<code>led_lighting(specs)</code>","text":"<p>Build LED lighting SysEx message.</p> <p>Parameters:</p> Name Type Description Default <code>specs</code> <code>List[Tuple]</code> <p>List of (lighting_type, led_note, *data_bytes)    NOTE: led_note is hardware MIDI note, not logical index</p> required Source code in <code>src/launchsampler/devices/adapters/launchpad_sysex.py</code> <pre><code>def led_lighting(self, specs: List[Tuple]) -&gt; mido.Message:\n    \"\"\"\n    Build LED lighting SysEx message.\n\n    Args:\n        specs: List of (lighting_type, led_note, *data_bytes)\n               NOTE: led_note is hardware MIDI note, not logical index\n    \"\"\"\n    data = self.header + [0x03]\n    for spec in specs:\n        data.extend(spec)\n    return mido.Message('sysex', data=data)\n</code></pre>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>Exception hierarchy and error handling utilities</p> <p>Custom exception hierarchy for LaunchSampler.</p> <p>This module defines application-specific exceptions that provide: - Clear error categories (audio, device, validation, etc.) - User-friendly messages - Context preservation - Recovery hints</p>"},{"location":"api/exceptions/#launchsampler.exceptions--exception-hierarchy","title":"Exception Hierarchy","text":"<pre><code>LaunchSamplerError (base)\n\u251c\u2500\u2500 AudioDeviceError\n\u2502   \u251c\u2500\u2500 AudioDeviceInUseError\n\u2502   \u2514\u2500\u2500 AudioDeviceNotFoundError\n\u2514\u2500\u2500 ConfigurationError\n    \u251c\u2500\u2500 ConfigFileInvalidError\n    \u2514\u2500\u2500 ConfigValidationError\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions--usage","title":"Usage","text":"<p>All custom exceptions inherit from <code>LaunchSamplerError</code>, which provides:</p> <ul> <li><code>user_message</code>: Human-friendly message for display to users</li> <li><code>technical_message</code>: Detailed message for logging</li> <li><code>recoverable</code>: Whether the error can be recovered from</li> <li><code>recovery_hint</code>: Optional suggestion for how to fix the issue</li> </ul>"},{"location":"api/exceptions/#launchsampler.exceptions--example-audio-device-in-use","title":"Example: Audio Device In Use","text":"<pre><code>from launchsampler.exceptions import AudioDeviceInUseError\n\n# Raise when device is already in use\nraise AudioDeviceInUseError(device_id=3, original_error=\"PaErrorCode -9996\")\n\n# User sees: \"Audio device is already in use by another application.\"\n# Recovery hint: \"Please close other instances... Run 'launchsampler audio list'...\"\n# Logs show: Technical details including original error\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions--example-config-validation-error","title":"Example: Config Validation Error","text":"<pre><code>from launchsampler.exceptions import ConfigValidationError\n\n# Raise when config value is invalid\nraise ConfigValidationError(\n    field=\"panic_button_cc_value\",\n    value=\"hunder\",\n    error_msg=\"Input should be a valid integer\",\n    file_path=\"/path/to/config.json\"\n)\n\n# User sees: \"Invalid configuration value for 'panic_button_cc_value': Input should be a valid integer\"\n# Recovery hint: \"Update the 'panic_button_cc_value' value in your configuration\nConfig file: /path/to/config.json\"\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions--best-practices","title":"Best Practices","text":"<ol> <li>Always use specific exception types rather than generic <code>RuntimeError</code></li> <li>Provide recovery hints to help users fix the problem</li> <li>Preserve original exceptions using <code>from e</code> when re-raising</li> <li>Separate user vs technical messages for better UX and debugging</li> </ol> <p>See <code>launchsampler.exceptions.handlers</code> for utilities to handle these exceptions systematically.</p>"},{"location":"api/exceptions/#launchsampler.exceptions.LaunchSamplerError","title":"<code>LaunchSamplerError(user_message, technical_message=None, recoverable=False, recovery_hint=None, *args, **kwargs)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all LaunchSampler errors.</p> <p>All custom exceptions inherit from this to allow catching all app-specific errors in one place.</p> <p>Attributes:</p> Name Type Description <code>user_message</code> <p>Human-friendly message for display</p> <code>technical_message</code> <p>Detailed message for logging</p> <code>recoverable</code> <p>Whether the error can be recovered from</p> <code>recovery_hint</code> <p>Optional hint for how to fix the issue</p> <p>Initialize a LaunchSampler error.</p> <p>Parameters:</p> Name Type Description Default <code>user_message</code> <code>str</code> <p>Message to show to users</p> required <code>technical_message</code> <code>Optional[str]</code> <p>Detailed message for logs (defaults to user_message)</p> <code>None</code> <code>recoverable</code> <code>bool</code> <p>True if operation can be retried/recovered</p> <code>False</code> <code>recovery_hint</code> <code>Optional[str]</code> <p>Suggestion for how to fix the issue</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    technical_message: Optional[str] = None,\n    recoverable: bool = False,\n    recovery_hint: Optional[str] = None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Initialize a LaunchSampler error.\n\n    Args:\n        user_message: Message to show to users\n        technical_message: Detailed message for logs (defaults to user_message)\n        recoverable: True if operation can be retried/recovered\n        recovery_hint: Suggestion for how to fix the issue\n    \"\"\"\n    super().__init__(user_message, *args, **kwargs)\n    self.user_message = user_message\n    self.technical_message = technical_message or user_message\n    self.recoverable = recoverable\n    self.recovery_hint = recovery_hint\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.LaunchSamplerError.__str__","title":"<code>__str__()</code>","text":"<p>Return user-friendly message.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return user-friendly message.\"\"\"\n    return self.user_message\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.LaunchSamplerError.get_full_message","title":"<code>get_full_message()</code>","text":"<p>Get complete error message with recovery hint.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def get_full_message(self) -&gt; str:\n    \"\"\"Get complete error message with recovery hint.\"\"\"\n    msg = self.user_message\n    if self.recovery_hint:\n        msg += f\"\\n\\nSuggestion: {self.recovery_hint}\"\n    return msg\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.AudioDeviceError","title":"<code>AudioDeviceError(user_message, device_id=None, **kwargs)</code>","text":"<p>               Bases: <code>LaunchSamplerError</code></p> <p>Audio device initialization or operation failed.</p> <p>Initialize audio device error.</p> <p>Parameters:</p> Name Type Description Default <code>user_message</code> <code>str</code> <p>User-friendly error message</p> required <code>device_id</code> <code>Optional[int]</code> <p>The device ID that failed (if applicable)</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    device_id: Optional[int] = None,\n    **kwargs\n):\n    \"\"\"\n    Initialize audio device error.\n\n    Args:\n        user_message: User-friendly error message\n        device_id: The device ID that failed (if applicable)\n    \"\"\"\n    super().__init__(user_message, **kwargs)\n    self.device_id = device_id\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.AudioDeviceInUseError","title":"<code>AudioDeviceInUseError(device_id=None, original_error=None)</code>","text":"<p>               Bases: <code>AudioDeviceError</code></p> <p>Audio device is already in use by another application.</p> <p>Initialize device-in-use error.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>Optional[int]</code> <p>The device ID that's in use</p> <code>None</code> <code>original_error</code> <code>Optional[str]</code> <p>The original error message from the audio library</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(self, device_id: Optional[int] = None, original_error: Optional[str] = None):\n    \"\"\"\n    Initialize device-in-use error.\n\n    Args:\n        device_id: The device ID that's in use\n        original_error: The original error message from the audio library\n    \"\"\"\n    user_msg = \"Audio device is already in use by another application.\"\n    tech_msg = user_msg\n    if original_error:\n        tech_msg += f\"\\nOriginal error: {original_error}\"\n\n    recovery = (\n        \"Please close other instances of LaunchSampler or other audio applications. \"\n        \"Run 'launchsampler audio list' to see available devices.\"\n    )\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=tech_msg,\n        device_id=device_id,\n        recoverable=True,\n        recovery_hint=recovery\n    )\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.AudioDeviceNotFoundError","title":"<code>AudioDeviceNotFoundError(device_id)</code>","text":"<p>               Bases: <code>AudioDeviceError</code></p> <p>Requested audio device was not found.</p> <p>Initialize device-not-found error.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device ID that wasn't found</p> required Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(self, device_id: int):\n    \"\"\"\n    Initialize device-not-found error.\n\n    Args:\n        device_id: The device ID that wasn't found\n    \"\"\"\n    user_msg = f\"Audio device {device_id} not found.\"\n    recovery = \"Run 'launchsampler audio list' to see available devices.\"\n\n    super().__init__(\n        user_message=user_msg,\n        device_id=device_id,\n        recoverable=True,\n        recovery_hint=recovery\n    )\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ConfigurationError","title":"<code>ConfigurationError(user_message, technical_message=None, recoverable=False, recovery_hint=None, *args, **kwargs)</code>","text":"<p>               Bases: <code>LaunchSamplerError</code></p> <p>Configuration is invalid or cannot be loaded.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    technical_message: Optional[str] = None,\n    recoverable: bool = False,\n    recovery_hint: Optional[str] = None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Initialize a LaunchSampler error.\n\n    Args:\n        user_message: Message to show to users\n        technical_message: Detailed message for logs (defaults to user_message)\n        recoverable: True if operation can be retried/recovered\n        recovery_hint: Suggestion for how to fix the issue\n    \"\"\"\n    super().__init__(user_message, *args, **kwargs)\n    self.user_message = user_message\n    self.technical_message = technical_message or user_message\n    self.recoverable = recoverable\n    self.recovery_hint = recovery_hint\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ConfigFileInvalidError","title":"<code>ConfigFileInvalidError(file_path, parse_error)</code>","text":"<p>               Bases: <code>ConfigurationError</code></p> <p>Configuration file has invalid JSON or YAML syntax.</p> <p>Initialize config file invalid error.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the invalid config file</p> required <code>parse_error</code> <code>str</code> <p>The parsing error message</p> required Source code in <code>src/launchsampler/exceptions/config.py</code> <pre><code>def __init__(self, file_path: str, parse_error: str):\n    \"\"\"\n    Initialize config file invalid error.\n\n    Args:\n        file_path: Path to the invalid config file\n        parse_error: The parsing error message\n    \"\"\"\n    # Extract helpful info from parse error\n    user_msg = f\"Configuration file has invalid syntax\"\n    recovery = \"Check for common JSON errors:\\n\"\n    recovery += \"  - Trailing commas (remove commas after last item)\\n\"\n    recovery += \"  - Missing quotes around strings\\n\"\n    recovery += \"  - Unclosed braces or brackets\\n\"\n    recovery += f\"  - Edit: {file_path}\"\n\n    # Check for specific common errors\n    if \"trailing comma\" in parse_error.lower():\n        user_msg = \"Configuration file has a trailing comma\"\n        recovery = (\n            f\"Remove the trailing comma from {file_path}\\n\"\n            \"JSON doesn't allow commas after the last item in an object or array\"\n        )\n    elif \"expecting\" in parse_error.lower():\n        user_msg = \"Configuration file has a syntax error\"\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=f\"JSON parse error in {file_path}: {parse_error}\",\n        recoverable=True,\n        recovery_hint=recovery\n    )\n    self.file_path = file_path\n    self.parse_error = parse_error\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ConfigValidationError","title":"<code>ConfigValidationError(field, value, error_msg, file_path=None)</code>","text":"<p>               Bases: <code>ConfigurationError</code></p> <p>Configuration values fail validation.</p> <p>Initialize config validation error.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The configuration field that failed validation</p> required <code>value</code> <code>any</code> <p>The invalid value</p> required <code>error_msg</code> <code>str</code> <p>Why the value is invalid</p> required <code>file_path</code> <code>str</code> <p>Path to the config file (optional)</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/config.py</code> <pre><code>def __init__(self, field: str, value: any, error_msg: str, file_path: str = None):\n    \"\"\"\n    Initialize config validation error.\n\n    Args:\n        field: The configuration field that failed validation\n        value: The invalid value\n        error_msg: Why the value is invalid\n        file_path: Path to the config file (optional)\n    \"\"\"\n    user_msg = f\"Invalid configuration value for '{field}': {error_msg}\"\n\n    recovery = f\"Update the '{field}' value in your configuration\"\n    if file_path:\n        recovery += f\"\\nConfig file: {file_path}\"\n\n    # Add specific recovery hints for common fields\n    if \"audio_device\" in field.lower():\n        recovery += \"\\nRun 'launchsampler audio list' to see valid device IDs\"\n    elif \"buffer\" in field.lower():\n        recovery += \"\\nValid buffer sizes: 128, 256, 512, 1024, 2048\"\n    elif \"midi\" in field.lower():\n        recovery += \"\\nRun 'launchsampler midi list' to see valid MIDI devices\"\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=f\"Config validation failed for {field}={value}: {error_msg}\",\n        recoverable=True,\n        recovery_hint=recovery\n    )\n    self.field = field\n    self.value = value\n    self.file_path = file_path\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorContext","title":"<code>ErrorContext(operation, logger_instance=None, re_raise=True)</code>","text":"<p>Context manager for error handling with automatic logging.</p> <p>Use this for critical sections where you want consistent error handling.</p> Example <pre><code>with ErrorContext(\"initialize audio device\") as ctx:\n    device = AudioDevice()\n    device.start()\n\nif ctx.error:\n    print(f\"Failed: {ctx.error}\")\n</code></pre> <p>Initialize error context.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the operation</p> required <code>logger_instance</code> <code>Optional[Logger]</code> <p>Logger to use (defaults to module logger)</p> <code>None</code> <code>re_raise</code> <code>bool</code> <p>Whether to re-raise exceptions</p> <code>True</code> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __init__(\n    self,\n    operation: str,\n    logger_instance: Optional[logging.Logger] = None,\n    re_raise: bool = True\n):\n    \"\"\"\n    Initialize error context.\n\n    Args:\n        operation: Description of the operation\n        logger_instance: Logger to use (defaults to module logger)\n        re_raise: Whether to re-raise exceptions\n    \"\"\"\n    self.operation = operation\n    self.logger = logger_instance or logger\n    self.re_raise = re_raise\n    self.error: Optional[Exception] = None\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorContext.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context.</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __enter__(self):\n    \"\"\"Enter the context.\"\"\"\n    self.logger.debug(f\"Starting: {self.operation}\")\n    return self\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorContext.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context and handle any exceptions.</p> <p>Returns:</p> Type Description <p>True if exception should be suppressed, False otherwise</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Exit the context and handle any exceptions.\n\n    Returns:\n        True if exception should be suppressed, False otherwise\n    \"\"\"\n    if exc_type is None:\n        self.logger.debug(f\"Completed: {self.operation}\")\n        return False\n\n    self.error = exc_val\n\n    if isinstance(exc_val, LaunchSamplerError):\n        self.logger.error(\n            f\"Failed to {self.operation}: {exc_val.technical_message}\"\n        )\n    else:\n        self.logger.error(\n            f\"Failed to {self.operation}: {exc_val}\",\n            exc_info=True\n        )\n\n    # Return True to suppress exception, False to re-raise\n    return not self.re_raise\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorCollector","title":"<code>ErrorCollector(operation)</code>","text":"<p>Collects multiple errors during batch operations.</p> <p>Allows operations to continue even if some fail, then report all failures at once.</p> <p>Initialize error collector.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the overall operation</p> required Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __init__(self, operation: str):\n    \"\"\"\n    Initialize error collector.\n\n    Args:\n        operation: Description of the overall operation\n    \"\"\"\n    self.operation = operation\n    self.errors: list[tuple[str, Exception]] = []\n    self.success_count = 0\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorCollector.has_errors","title":"<code>has_errors</code>  <code>property</code>","text":"<p>Check if any errors were collected.</p>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorCollector.error_count","title":"<code>error_count</code>  <code>property</code>","text":"<p>Get the number of errors collected.</p>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorCollector.try_operation","title":"<code>try_operation(sub_operation)</code>","text":"<p>Context manager for a single operation within the batch.</p> <p>Parameters:</p> Name Type Description Default <code>sub_operation</code> <code>str</code> <p>Description of this specific operation</p> required <p>Returns:</p> Type Description <p>Context manager that catches and stores errors</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def try_operation(self, sub_operation: str):\n    \"\"\"\n    Context manager for a single operation within the batch.\n\n    Args:\n        sub_operation: Description of this specific operation\n\n    Returns:\n        Context manager that catches and stores errors\n    \"\"\"\n    return self._OperationContext(self, sub_operation)\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.ErrorCollector.get_summary","title":"<code>get_summary()</code>","text":"<p>Get a summary of collected errors.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line summary string</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"\n    Get a summary of collected errors.\n\n    Returns:\n        Multi-line summary string\n    \"\"\"\n    if not self.has_errors:\n        return f\"All operations completed successfully ({self.success_count} total)\"\n\n    summary = f\"Failed {self.error_count} of {self.error_count + self.success_count} operations:\\n\"\n    for sub_op, error in self.errors:\n        if isinstance(error, LaunchSamplerError):\n            summary += f\"  - {sub_op}: {error.user_message}\\n\"\n        else:\n            summary += f\"  - {sub_op}: {error}\\n\"\n\n    return summary.rstrip()\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.handle_errors","title":"<code>handle_errors(*, operation_name, user_notification=None, fallback_value=None, re_raise=True, log_level=logging.ERROR)</code>","text":"<p>Decorator for consistent error handling.</p> <p>This provides a standard pattern for: - Logging errors with context - Showing user notifications - Returning fallback values - Re-raising or swallowing exceptions</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name of the operation for logging (e.g., \"load sample\")</p> required <code>user_notification</code> <code>Optional[Callable[[str], None]]</code> <p>Optional callback to notify user (e.g., self.notify)</p> <code>None</code> <code>fallback_value</code> <code>Optional[T]</code> <p>Value to return if error occurs and re_raise=False</p> <code>None</code> <code>re_raise</code> <code>bool</code> <p>Whether to re-raise the exception after handling</p> <code>True</code> <code>log_level</code> <code>int</code> <p>Logging level for the error (default: ERROR)</p> <code>ERROR</code> Example <pre><code>@handle_errors(\n    operation_name=\"load sample\",\n    user_notification=self.notify,\n    re_raise=False,\n    fallback_value=None\n)\ndef load_sample(self, path: str):\n    # If this raises, it will be logged and user notified\n    return AudioData.from_file(path)\n</code></pre> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def handle_errors(\n    *,\n    operation_name: str,\n    user_notification: Optional[Callable[[str], None]] = None,\n    fallback_value: Optional[T] = None,\n    re_raise: bool = True,\n    log_level: int = logging.ERROR\n) -&gt; Callable:\n    \"\"\"\n    Decorator for consistent error handling.\n\n    This provides a standard pattern for:\n    - Logging errors with context\n    - Showing user notifications\n    - Returning fallback values\n    - Re-raising or swallowing exceptions\n\n    Args:\n        operation_name: Name of the operation for logging (e.g., \"load sample\")\n        user_notification: Optional callback to notify user (e.g., self.notify)\n        fallback_value: Value to return if error occurs and re_raise=False\n        re_raise: Whether to re-raise the exception after handling\n        log_level: Logging level for the error (default: ERROR)\n\n    Example:\n        ```python\n        @handle_errors(\n            operation_name=\"load sample\",\n            user_notification=self.notify,\n            re_raise=False,\n            fallback_value=None\n        )\n        def load_sample(self, path: str):\n            # If this raises, it will be logged and user notified\n            return AudioData.from_file(path)\n        ```\n\n    Returns:\n        Decorated function\n    \"\"\"\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; T:\n            try:\n                return func(*args, **kwargs)\n\n            except LaunchSamplerError as e:\n                # Our custom exceptions have user/technical messages\n                logger.log(log_level, f\"Failed to {operation_name}: {e.technical_message}\")\n\n                if user_notification:\n                    user_notification(e.get_full_message())\n\n                if re_raise:\n                    raise\n                return fallback_value\n\n            except Exception as e:\n                # Unexpected exceptions\n                logger.log(\n                    log_level,\n                    f\"Unexpected error during {operation_name}: {e}\",\n                    exc_info=True\n                )\n\n                if user_notification:\n                    user_notification(f\"Error: {e}\")\n\n                if re_raise:\n                    raise\n                return fallback_value\n\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.wrap_pydantic_error","title":"<code>wrap_pydantic_error(error, file_path)</code>","text":"<p>Convert Pydantic validation errors to LaunchSampler exceptions.</p> <p>This maps validation errors from Pydantic (used for config validation) to our custom exception types with user-friendly messages.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The Pydantic ValidationError</p> required <code>file_path</code> <code>str</code> <p>Path to the config file that failed validation</p> required <p>Returns:</p> Type Description <code>LaunchSamplerError</code> <p>A ConfigurationError with appropriate type and message</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def wrap_pydantic_error(error: Exception, file_path: str) -&gt; LaunchSamplerError:\n    \"\"\"\n    Convert Pydantic validation errors to LaunchSampler exceptions.\n\n    This maps validation errors from Pydantic (used for config validation)\n    to our custom exception types with user-friendly messages.\n\n    Args:\n        error: The Pydantic ValidationError\n        file_path: Path to the config file that failed validation\n\n    Returns:\n        A ConfigurationError with appropriate type and message\n    \"\"\"\n    from pydantic import ValidationError\n\n    error_msg = str(error)\n\n    # Check if it's a JSON parse error (invalid syntax)\n    if \"Invalid JSON\" in error_msg or \"json_invalid\" in error_msg:\n        # Extract the actual parse error from Pydantic's message\n        # Format: \"Invalid JSON: &lt;actual error&gt; [type=json_invalid, ...\"\n        if \"Invalid JSON:\" in error_msg:\n            parse_error = error_msg.split(\"Invalid JSON:\")[1].split(\"[type=\")[0].strip()\n        else:\n            parse_error = error_msg\n\n        return ConfigFileInvalidError(file_path, parse_error)\n\n    # It's a validation error (valid JSON but invalid values)\n    # For Pydantic v2, use the error() method to get structured error info\n    if isinstance(error, ValidationError):\n        errors = error.errors()\n        if errors:\n            # If multiple errors, combine them into a comprehensive message\n            if len(errors) == 1:\n                # Single error - use simple message\n                first_error = errors[0]\n                field = \".\".join(str(loc) for loc in first_error.get('loc', ('unknown',)))\n                reason = first_error.get('msg', 'validation failed')\n                value = first_error.get('input', None)\n\n                return ConfigValidationError(\n                    field=field,\n                    value=value,\n                    error_msg=reason,\n                    file_path=file_path\n                )\n            else:\n                # Multiple errors - show all of them\n                error_lines = []\n                for err in errors:\n                    field = \".\".join(str(loc) for loc in err.get('loc', ('unknown',)))\n                    msg = err.get('msg', 'validation failed')\n                    error_lines.append(f\"  - {field}: {msg}\")\n\n                combined_msg = f\"{len(errors)} validation errors:\\n\" + \"\\n\".join(error_lines)\n\n                return ConfigValidationError(\n                    field=\"multiple fields\",\n                    value=None,\n                    error_msg=combined_msg,\n                    file_path=file_path\n                )\n\n    # Fallback: parse string representation\n    lines = error_msg.split(\"\\n\")\n    field = \"unknown\"\n    reason = error_msg\n\n    for line in lines:\n        if \"Field required\" in line or \"validation error\" in line:\n            # Extract field name from error format\n            parts = line.split()\n            if parts:\n                field = parts[0] if parts else \"unknown\"\n            reason = line\n            break\n\n    return ConfigValidationError(\n        field=field,\n        value=None,\n        error_msg=reason,\n        file_path=file_path\n    )\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.wrap_audio_device_error","title":"<code>wrap_audio_device_error(error, device_id=None)</code>","text":"<p>Convert low-level audio errors to LaunchSampler exceptions.</p> <p>This maps error codes from audio libraries (PortAudio, sounddevice) to our custom exception types with user-friendly messages.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The original exception from the audio library</p> required <code>device_id</code> <code>Optional[int]</code> <p>The device ID involved in the error</p> <code>None</code> <p>Returns:</p> Type Description <code>LaunchSamplerError</code> <p>A LaunchSamplerError with appropriate type and message</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def wrap_audio_device_error(error: Exception, device_id: Optional[int] = None) -&gt; LaunchSamplerError:\n    \"\"\"\n    Convert low-level audio errors to LaunchSampler exceptions.\n\n    This maps error codes from audio libraries (PortAudio, sounddevice)\n    to our custom exception types with user-friendly messages.\n\n    Args:\n        error: The original exception from the audio library\n        device_id: The device ID involved in the error\n\n    Returns:\n        A LaunchSamplerError with appropriate type and message\n    \"\"\"\n    error_msg = str(error)\n\n    # Check for device-in-use error\n    if \"PaErrorCode -9996\" in error_msg or \"Invalid device\" in error_msg:\n        return AudioDeviceInUseError(device_id=device_id, original_error=error_msg)\n\n    # Check for device not found\n    if \"device\" in error_msg.lower() and \"not found\" in error_msg.lower():\n        if device_id is not None:\n            return AudioDeviceNotFoundError(device_id)\n\n    # Generic audio device error\n    return AudioDeviceError(\n        user_message=f\"Audio device error: {error_msg}\",\n        technical_message=f\"Audio device {device_id} error: {error_msg}\",\n        device_id=device_id\n    )\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.format_error_for_display","title":"<code>format_error_for_display(error)</code>","text":"<p>Format an exception for user display.</p> <p>Returns a tuple of (message, recovery_hint).</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The exception to format</p> required <p>Returns:</p> Type Description <code>tuple[str, Optional[str]]</code> <p>Tuple of (user_message, recovery_hint or None)</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def format_error_for_display(error: Exception) -&gt; tuple[str, Optional[str]]:\n    \"\"\"\n    Format an exception for user display.\n\n    Returns a tuple of (message, recovery_hint).\n\n    Args:\n        error: The exception to format\n\n    Returns:\n        Tuple of (user_message, recovery_hint or None)\n    \"\"\"\n    if isinstance(error, LaunchSamplerError):\n        return error.user_message, error.recovery_hint\n\n    # For standard exceptions, create a user-friendly message\n    error_type = type(error).__name__\n    return f\"{error_type}: {error}\", None\n</code></pre>"},{"location":"api/exceptions/#launchsampler.exceptions.collect_errors","title":"<code>collect_errors(operation)</code>","text":"<p>Create an error collector for batch operations.</p> <p>Use this when you want to attempt multiple operations and collect all errors before reporting them.</p> Example <pre><code>collector = collect_errors(\"load samples\")\n\nfor file in files:\n    with collector.try_operation(f\"load {file}\"):\n        load_sample(file)\n\nif collector.has_errors:\n    print(f\"Failed to load {collector.error_count} samples:\")\n    for error in collector.errors:\n        print(f\"  - {error}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the overall operation</p> required <p>Returns:</p> Type Description <code>ErrorCollector</code> <p>ErrorCollector instance</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def collect_errors(operation: str) -&gt; \"ErrorCollector\":\n    \"\"\"\n    Create an error collector for batch operations.\n\n    Use this when you want to attempt multiple operations and collect\n    all errors before reporting them.\n\n    Example:\n        ```python\n        collector = collect_errors(\"load samples\")\n\n        for file in files:\n            with collector.try_operation(f\"load {file}\"):\n                load_sample(file)\n\n        if collector.has_errors:\n            print(f\"Failed to load {collector.error_count} samples:\")\n            for error in collector.errors:\n                print(f\"  - {error}\")\n        ```\n\n    Args:\n        operation: Description of the overall operation\n\n    Returns:\n        ErrorCollector instance\n    \"\"\"\n    return ErrorCollector(operation)\n</code></pre>"},{"location":"api/exceptions/audio/","title":"Audio","text":""},{"location":"api/exceptions/audio/#launchsampler.exceptions.audio","title":"<code>audio</code>","text":"<p>Audio-related exceptions.</p> <p>This module defines exceptions for audio device errors: - AudioDeviceError: Base class for audio device errors - AudioDeviceInUseError: Device is already in use - AudioDeviceNotFoundError: Device was not found</p>"},{"location":"api/exceptions/audio/#launchsampler.exceptions.audio.AudioDeviceError","title":"<code>AudioDeviceError(user_message, device_id=None, **kwargs)</code>","text":"<p>               Bases: <code>LaunchSamplerError</code></p> <p>Audio device initialization or operation failed.</p> <p>Initialize audio device error.</p> <p>Parameters:</p> Name Type Description Default <code>user_message</code> <code>str</code> <p>User-friendly error message</p> required <code>device_id</code> <code>Optional[int]</code> <p>The device ID that failed (if applicable)</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    device_id: Optional[int] = None,\n    **kwargs\n):\n    \"\"\"\n    Initialize audio device error.\n\n    Args:\n        user_message: User-friendly error message\n        device_id: The device ID that failed (if applicable)\n    \"\"\"\n    super().__init__(user_message, **kwargs)\n    self.device_id = device_id\n</code></pre>"},{"location":"api/exceptions/audio/#launchsampler.exceptions.audio.AudioDeviceInUseError","title":"<code>AudioDeviceInUseError(device_id=None, original_error=None)</code>","text":"<p>               Bases: <code>AudioDeviceError</code></p> <p>Audio device is already in use by another application.</p> <p>Initialize device-in-use error.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>Optional[int]</code> <p>The device ID that's in use</p> <code>None</code> <code>original_error</code> <code>Optional[str]</code> <p>The original error message from the audio library</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(self, device_id: Optional[int] = None, original_error: Optional[str] = None):\n    \"\"\"\n    Initialize device-in-use error.\n\n    Args:\n        device_id: The device ID that's in use\n        original_error: The original error message from the audio library\n    \"\"\"\n    user_msg = \"Audio device is already in use by another application.\"\n    tech_msg = user_msg\n    if original_error:\n        tech_msg += f\"\\nOriginal error: {original_error}\"\n\n    recovery = (\n        \"Please close other instances of LaunchSampler or other audio applications. \"\n        \"Run 'launchsampler audio list' to see available devices.\"\n    )\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=tech_msg,\n        device_id=device_id,\n        recoverable=True,\n        recovery_hint=recovery\n    )\n</code></pre>"},{"location":"api/exceptions/audio/#launchsampler.exceptions.audio.AudioDeviceNotFoundError","title":"<code>AudioDeviceNotFoundError(device_id)</code>","text":"<p>               Bases: <code>AudioDeviceError</code></p> <p>Requested audio device was not found.</p> <p>Initialize device-not-found error.</p> <p>Parameters:</p> Name Type Description Default <code>device_id</code> <code>int</code> <p>The device ID that wasn't found</p> required Source code in <code>src/launchsampler/exceptions/audio.py</code> <pre><code>def __init__(self, device_id: int):\n    \"\"\"\n    Initialize device-not-found error.\n\n    Args:\n        device_id: The device ID that wasn't found\n    \"\"\"\n    user_msg = f\"Audio device {device_id} not found.\"\n    recovery = \"Run 'launchsampler audio list' to see available devices.\"\n\n    super().__init__(\n        user_message=user_msg,\n        device_id=device_id,\n        recoverable=True,\n        recovery_hint=recovery\n    )\n</code></pre>"},{"location":"api/exceptions/base/","title":"Base","text":""},{"location":"api/exceptions/base/#launchsampler.exceptions.base","title":"<code>base</code>","text":"<p>Base exception class for LaunchSampler.</p> <p>All custom exceptions inherit from LaunchSamplerError to allow catching all app-specific errors in one place. The base class provides:</p> <ul> <li><code>user_message</code>: Human-friendly message for display to users</li> <li><code>technical_message</code>: Detailed message for logging</li> <li><code>recoverable</code>: Whether the error can be recovered from</li> <li><code>recovery_hint</code>: Optional suggestion for how to fix the issue</li> </ul>"},{"location":"api/exceptions/base/#launchsampler.exceptions.base.LaunchSamplerError","title":"<code>LaunchSamplerError(user_message, technical_message=None, recoverable=False, recovery_hint=None, *args, **kwargs)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all LaunchSampler errors.</p> <p>All custom exceptions inherit from this to allow catching all app-specific errors in one place.</p> <p>Attributes:</p> Name Type Description <code>user_message</code> <p>Human-friendly message for display</p> <code>technical_message</code> <p>Detailed message for logging</p> <code>recoverable</code> <p>Whether the error can be recovered from</p> <code>recovery_hint</code> <p>Optional hint for how to fix the issue</p> <p>Initialize a LaunchSampler error.</p> <p>Parameters:</p> Name Type Description Default <code>user_message</code> <code>str</code> <p>Message to show to users</p> required <code>technical_message</code> <code>Optional[str]</code> <p>Detailed message for logs (defaults to user_message)</p> <code>None</code> <code>recoverable</code> <code>bool</code> <p>True if operation can be retried/recovered</p> <code>False</code> <code>recovery_hint</code> <code>Optional[str]</code> <p>Suggestion for how to fix the issue</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    technical_message: Optional[str] = None,\n    recoverable: bool = False,\n    recovery_hint: Optional[str] = None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Initialize a LaunchSampler error.\n\n    Args:\n        user_message: Message to show to users\n        technical_message: Detailed message for logs (defaults to user_message)\n        recoverable: True if operation can be retried/recovered\n        recovery_hint: Suggestion for how to fix the issue\n    \"\"\"\n    super().__init__(user_message, *args, **kwargs)\n    self.user_message = user_message\n    self.technical_message = technical_message or user_message\n    self.recoverable = recoverable\n    self.recovery_hint = recovery_hint\n</code></pre>"},{"location":"api/exceptions/base/#launchsampler.exceptions.base.LaunchSamplerError.__str__","title":"<code>__str__()</code>","text":"<p>Return user-friendly message.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return user-friendly message.\"\"\"\n    return self.user_message\n</code></pre>"},{"location":"api/exceptions/base/#launchsampler.exceptions.base.LaunchSamplerError.get_full_message","title":"<code>get_full_message()</code>","text":"<p>Get complete error message with recovery hint.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def get_full_message(self) -&gt; str:\n    \"\"\"Get complete error message with recovery hint.\"\"\"\n    msg = self.user_message\n    if self.recovery_hint:\n        msg += f\"\\n\\nSuggestion: {self.recovery_hint}\"\n    return msg\n</code></pre>"},{"location":"api/exceptions/config/","title":"Config","text":""},{"location":"api/exceptions/config/#launchsampler.exceptions.config","title":"<code>config</code>","text":"<p>Configuration-related exceptions.</p> <p>This module defines exceptions for configuration errors: - ConfigurationError: Base class for configuration errors - ConfigFileInvalidError: Config file has invalid syntax - ConfigValidationError: Config values fail validation</p>"},{"location":"api/exceptions/config/#launchsampler.exceptions.config.ConfigurationError","title":"<code>ConfigurationError(user_message, technical_message=None, recoverable=False, recovery_hint=None, *args, **kwargs)</code>","text":"<p>               Bases: <code>LaunchSamplerError</code></p> <p>Configuration is invalid or cannot be loaded.</p> Source code in <code>src/launchsampler/exceptions/base.py</code> <pre><code>def __init__(\n    self,\n    user_message: str,\n    technical_message: Optional[str] = None,\n    recoverable: bool = False,\n    recovery_hint: Optional[str] = None,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Initialize a LaunchSampler error.\n\n    Args:\n        user_message: Message to show to users\n        technical_message: Detailed message for logs (defaults to user_message)\n        recoverable: True if operation can be retried/recovered\n        recovery_hint: Suggestion for how to fix the issue\n    \"\"\"\n    super().__init__(user_message, *args, **kwargs)\n    self.user_message = user_message\n    self.technical_message = technical_message or user_message\n    self.recoverable = recoverable\n    self.recovery_hint = recovery_hint\n</code></pre>"},{"location":"api/exceptions/config/#launchsampler.exceptions.config.ConfigFileInvalidError","title":"<code>ConfigFileInvalidError(file_path, parse_error)</code>","text":"<p>               Bases: <code>ConfigurationError</code></p> <p>Configuration file has invalid JSON or YAML syntax.</p> <p>Initialize config file invalid error.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the invalid config file</p> required <code>parse_error</code> <code>str</code> <p>The parsing error message</p> required Source code in <code>src/launchsampler/exceptions/config.py</code> <pre><code>def __init__(self, file_path: str, parse_error: str):\n    \"\"\"\n    Initialize config file invalid error.\n\n    Args:\n        file_path: Path to the invalid config file\n        parse_error: The parsing error message\n    \"\"\"\n    # Extract helpful info from parse error\n    user_msg = f\"Configuration file has invalid syntax\"\n    recovery = \"Check for common JSON errors:\\n\"\n    recovery += \"  - Trailing commas (remove commas after last item)\\n\"\n    recovery += \"  - Missing quotes around strings\\n\"\n    recovery += \"  - Unclosed braces or brackets\\n\"\n    recovery += f\"  - Edit: {file_path}\"\n\n    # Check for specific common errors\n    if \"trailing comma\" in parse_error.lower():\n        user_msg = \"Configuration file has a trailing comma\"\n        recovery = (\n            f\"Remove the trailing comma from {file_path}\\n\"\n            \"JSON doesn't allow commas after the last item in an object or array\"\n        )\n    elif \"expecting\" in parse_error.lower():\n        user_msg = \"Configuration file has a syntax error\"\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=f\"JSON parse error in {file_path}: {parse_error}\",\n        recoverable=True,\n        recovery_hint=recovery\n    )\n    self.file_path = file_path\n    self.parse_error = parse_error\n</code></pre>"},{"location":"api/exceptions/config/#launchsampler.exceptions.config.ConfigValidationError","title":"<code>ConfigValidationError(field, value, error_msg, file_path=None)</code>","text":"<p>               Bases: <code>ConfigurationError</code></p> <p>Configuration values fail validation.</p> <p>Initialize config validation error.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>The configuration field that failed validation</p> required <code>value</code> <code>any</code> <p>The invalid value</p> required <code>error_msg</code> <code>str</code> <p>Why the value is invalid</p> required <code>file_path</code> <code>str</code> <p>Path to the config file (optional)</p> <code>None</code> Source code in <code>src/launchsampler/exceptions/config.py</code> <pre><code>def __init__(self, field: str, value: any, error_msg: str, file_path: str = None):\n    \"\"\"\n    Initialize config validation error.\n\n    Args:\n        field: The configuration field that failed validation\n        value: The invalid value\n        error_msg: Why the value is invalid\n        file_path: Path to the config file (optional)\n    \"\"\"\n    user_msg = f\"Invalid configuration value for '{field}': {error_msg}\"\n\n    recovery = f\"Update the '{field}' value in your configuration\"\n    if file_path:\n        recovery += f\"\\nConfig file: {file_path}\"\n\n    # Add specific recovery hints for common fields\n    if \"audio_device\" in field.lower():\n        recovery += \"\\nRun 'launchsampler audio list' to see valid device IDs\"\n    elif \"buffer\" in field.lower():\n        recovery += \"\\nValid buffer sizes: 128, 256, 512, 1024, 2048\"\n    elif \"midi\" in field.lower():\n        recovery += \"\\nRun 'launchsampler midi list' to see valid MIDI devices\"\n\n    super().__init__(\n        user_message=user_msg,\n        technical_message=f\"Config validation failed for {field}={value}: {error_msg}\",\n        recoverable=True,\n        recovery_hint=recovery\n    )\n    self.field = field\n    self.value = value\n    self.file_path = file_path\n</code></pre>"},{"location":"api/exceptions/handlers/","title":"Handlers","text":""},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers","title":"<code>handlers</code>","text":"<p>Centralized error handling utilities.</p> <p>This module provides a systematic, layered approach to error handling:</p> <ol> <li>Custom Exceptions - Typed, user-friendly error classes (see base, audio, config modules)</li> <li>Error Context - Preserve technical details for logging, show friendly messages to users</li> <li>Recovery Hints - Tell users what to do when things fail</li> <li>Error Isolation - One failure shouldn't cascade to others</li> </ol>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--quick-reference","title":"Quick Reference","text":""},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--when-to-use-what","title":"When to Use What","text":"Scenario Use This Example Audio device in use <code>AudioDeviceInUseError</code> <code>raise AudioDeviceInUseError(device_id=3)</code> Audio device not found <code>AudioDeviceNotFoundError</code> <code>raise AudioDeviceNotFoundError(device_id=5)</code> Config file syntax error <code>ConfigFileInvalidError</code> <code>raise ConfigFileInvalidError(path, \"trailing comma\")</code> Config value invalid <code>ConfigValidationError</code> <code>raise ConfigValidationError(\"buffer_size\", 99, \"must be power of 2\")</code>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--handling-patterns","title":"Handling Patterns","text":"Pattern Code Show error to user, continue <code>@handle_errors(operation_name=\"load\", user_notification=self.notify, re_raise=False)</code> Log and re-raise <code>@handle_errors(operation_name=\"init\", re_raise=True)</code> Try multiple ops, collect errors <code>collector = collect_errors(\"load samples\"); with collector.try_operation(...): ...</code> Critical section with auto-logging <code>with ErrorContext(\"initialize player\"): ...</code>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--examples","title":"Examples","text":""},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--example-1-converting-low-level-errors","title":"Example 1: Converting Low-Level Errors","text":"<pre><code>from launchsampler.exceptions import wrap_audio_device_error\n\ntry:\n    self._stream = sd.OutputStream(**config)\n    self._stream.start()\nexcept Exception as e:\n    # Automatically converts to appropriate exception type\n    raise wrap_audio_device_error(e, device_id=self.device)\n</code></pre> <p>Benefits: - Error detection logic centralized - Consistent user messages - Recovery hints included automatically</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--example-2-config-validation-with-custom-exceptions","title":"Example 2: Config Validation with Custom Exceptions","text":"<pre><code>from launchsampler.exceptions import wrap_pydantic_error\n\ntry:\n    config = AppConfig.model_validate_json(path.read_text())\nexcept ValidationError as e:\n    # Converts Pydantic error to user-friendly ConfigValidationError\n    raise wrap_pydantic_error(e, str(path)) from e\n</code></pre> <p>Benefits: - Automatic field name extraction - User-friendly error messages - Field-specific recovery hints (audio devices, MIDI, etc.)</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--example-3-batch-operations-loading-multiple-samples","title":"Example 3: Batch Operations (Loading Multiple Samples)","text":"<pre><code>from launchsampler.exceptions import collect_errors\n\ndef load_samples_from_directory(self, directory: Path):\n    '''Load all samples from a directory.'''\n    collector = collect_errors(\"load samples\")\n\n    for file in directory.glob(\"*.wav\"):\n        with collector.try_operation(f\"load {file.name}\"):\n            self.load_sample(file)\n\n    if collector.has_errors:\n        self.notify(collector.get_summary(), severity=\"error\")\n    else:\n        self.notify(f\"Loaded {collector.success_count} samples\")\n</code></pre> <p>Benefits: - Shows ALL failures, not just first one - Continues trying even after failures - Nice summary message</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--example-4-critical-initialization","title":"Example 4: Critical Initialization","text":"<pre><code>from launchsampler.exceptions import ErrorContext\n\ndef initialize(self):\n    with ErrorContext(\"initialize player\", logger_instance=logger):\n        self.player = Player(self.config)\n        self.player.start()\n</code></pre> <p>Benefits: - Automatic logging of start and completion - Exception details preserved</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--best-practices","title":"Best Practices","text":""},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--do","title":"DO","text":"<p>\u2705 Use specific exception types: <pre><code>raise AudioDeviceInUseError(device_id=3)  # Good\n</code></pre></p> <p>\u2705 Provide recovery hints: <pre><code>raise ValidationError(\"volume\", 150, \"must be 0-100. Try: set_volume(75)\")\n</code></pre></p> <p>\u2705 Preserve original errors: <pre><code>except Exception as e:\n    raise AudioDeviceInUseError(device_id=3, original_error=str(e)) from e\n</code></pre></p> <p>\u2705 Log technical details, show user-friendly messages: <pre><code>logger.error(f\"Failed to load {path}: {e.technical_message}\")\nself.notify(e.user_message)\n</code></pre></p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--dont","title":"DON'T","text":"<p>\u274c Use generic exceptions for user-facing errors: <pre><code>raise RuntimeError(\"Something failed\")  # Bad\n</code></pre></p> <p>\u274c Lose error context: <pre><code>except Exception as e:\n    raise RuntimeError(\"Failed\")  # Lost original error!\n</code></pre></p> <p>\u274c Show technical details to users: <pre><code>self.notify(f\"RuntimeError in line 42: {traceback}\")  # TMI!\n</code></pre></p> <p>\u274c Swallow errors silently: <pre><code>except Exception:\n    pass  # Never do this!\n</code></pre></p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers--architecture-the-three-layer-model","title":"Architecture: The Three-Layer Model","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  USER LAYER (CLI/TUI)               \u2502\n\u2502  - Formats error.user_message       \u2502\n\u2502  - Shows error.recovery_hint        \u2502\n\u2502  - Logs to file with --debug        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2191\n                  \u2502 LaunchSamplerError\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  APPLICATION LAYER (Services)       \u2502\n\u2502  - Catches low-level exceptions     \u2502\n\u2502  - Converts to LaunchSamplerError   \u2502\n\u2502  - Adds context and recovery hints  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                  \u2191\n                  \u2502 Exception, OSError, etc.\n                  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  LOW LEVEL (Audio, MIDI, I/O)       \u2502\n\u2502  - Raises standard Python exceptions\u2502\n\u2502  - Library-specific error codes     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key insight: Each layer translates errors to be more useful at the next level up.</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorContext","title":"<code>ErrorContext(operation, logger_instance=None, re_raise=True)</code>","text":"<p>Context manager for error handling with automatic logging.</p> <p>Use this for critical sections where you want consistent error handling.</p> Example <pre><code>with ErrorContext(\"initialize audio device\") as ctx:\n    device = AudioDevice()\n    device.start()\n\nif ctx.error:\n    print(f\"Failed: {ctx.error}\")\n</code></pre> <p>Initialize error context.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the operation</p> required <code>logger_instance</code> <code>Optional[Logger]</code> <p>Logger to use (defaults to module logger)</p> <code>None</code> <code>re_raise</code> <code>bool</code> <p>Whether to re-raise exceptions</p> <code>True</code> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __init__(\n    self,\n    operation: str,\n    logger_instance: Optional[logging.Logger] = None,\n    re_raise: bool = True\n):\n    \"\"\"\n    Initialize error context.\n\n    Args:\n        operation: Description of the operation\n        logger_instance: Logger to use (defaults to module logger)\n        re_raise: Whether to re-raise exceptions\n    \"\"\"\n    self.operation = operation\n    self.logger = logger_instance or logger\n    self.re_raise = re_raise\n    self.error: Optional[Exception] = None\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorContext.__enter__","title":"<code>__enter__()</code>","text":"<p>Enter the context.</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __enter__(self):\n    \"\"\"Enter the context.\"\"\"\n    self.logger.debug(f\"Starting: {self.operation}\")\n    return self\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorContext.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Exit the context and handle any exceptions.</p> <p>Returns:</p> Type Description <p>True if exception should be suppressed, False otherwise</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"\n    Exit the context and handle any exceptions.\n\n    Returns:\n        True if exception should be suppressed, False otherwise\n    \"\"\"\n    if exc_type is None:\n        self.logger.debug(f\"Completed: {self.operation}\")\n        return False\n\n    self.error = exc_val\n\n    if isinstance(exc_val, LaunchSamplerError):\n        self.logger.error(\n            f\"Failed to {self.operation}: {exc_val.technical_message}\"\n        )\n    else:\n        self.logger.error(\n            f\"Failed to {self.operation}: {exc_val}\",\n            exc_info=True\n        )\n\n    # Return True to suppress exception, False to re-raise\n    return not self.re_raise\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorCollector","title":"<code>ErrorCollector(operation)</code>","text":"<p>Collects multiple errors during batch operations.</p> <p>Allows operations to continue even if some fail, then report all failures at once.</p> <p>Initialize error collector.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the overall operation</p> required Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def __init__(self, operation: str):\n    \"\"\"\n    Initialize error collector.\n\n    Args:\n        operation: Description of the overall operation\n    \"\"\"\n    self.operation = operation\n    self.errors: list[tuple[str, Exception]] = []\n    self.success_count = 0\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorCollector.has_errors","title":"<code>has_errors</code>  <code>property</code>","text":"<p>Check if any errors were collected.</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorCollector.error_count","title":"<code>error_count</code>  <code>property</code>","text":"<p>Get the number of errors collected.</p>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorCollector.try_operation","title":"<code>try_operation(sub_operation)</code>","text":"<p>Context manager for a single operation within the batch.</p> <p>Parameters:</p> Name Type Description Default <code>sub_operation</code> <code>str</code> <p>Description of this specific operation</p> required <p>Returns:</p> Type Description <p>Context manager that catches and stores errors</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def try_operation(self, sub_operation: str):\n    \"\"\"\n    Context manager for a single operation within the batch.\n\n    Args:\n        sub_operation: Description of this specific operation\n\n    Returns:\n        Context manager that catches and stores errors\n    \"\"\"\n    return self._OperationContext(self, sub_operation)\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.ErrorCollector.get_summary","title":"<code>get_summary()</code>","text":"<p>Get a summary of collected errors.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line summary string</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"\n    Get a summary of collected errors.\n\n    Returns:\n        Multi-line summary string\n    \"\"\"\n    if not self.has_errors:\n        return f\"All operations completed successfully ({self.success_count} total)\"\n\n    summary = f\"Failed {self.error_count} of {self.error_count + self.success_count} operations:\\n\"\n    for sub_op, error in self.errors:\n        if isinstance(error, LaunchSamplerError):\n            summary += f\"  - {sub_op}: {error.user_message}\\n\"\n        else:\n            summary += f\"  - {sub_op}: {error}\\n\"\n\n    return summary.rstrip()\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.handle_errors","title":"<code>handle_errors(*, operation_name, user_notification=None, fallback_value=None, re_raise=True, log_level=logging.ERROR)</code>","text":"<p>Decorator for consistent error handling.</p> <p>This provides a standard pattern for: - Logging errors with context - Showing user notifications - Returning fallback values - Re-raising or swallowing exceptions</p> <p>Parameters:</p> Name Type Description Default <code>operation_name</code> <code>str</code> <p>Name of the operation for logging (e.g., \"load sample\")</p> required <code>user_notification</code> <code>Optional[Callable[[str], None]]</code> <p>Optional callback to notify user (e.g., self.notify)</p> <code>None</code> <code>fallback_value</code> <code>Optional[T]</code> <p>Value to return if error occurs and re_raise=False</p> <code>None</code> <code>re_raise</code> <code>bool</code> <p>Whether to re-raise the exception after handling</p> <code>True</code> <code>log_level</code> <code>int</code> <p>Logging level for the error (default: ERROR)</p> <code>ERROR</code> Example <pre><code>@handle_errors(\n    operation_name=\"load sample\",\n    user_notification=self.notify,\n    re_raise=False,\n    fallback_value=None\n)\ndef load_sample(self, path: str):\n    # If this raises, it will be logged and user notified\n    return AudioData.from_file(path)\n</code></pre> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def handle_errors(\n    *,\n    operation_name: str,\n    user_notification: Optional[Callable[[str], None]] = None,\n    fallback_value: Optional[T] = None,\n    re_raise: bool = True,\n    log_level: int = logging.ERROR\n) -&gt; Callable:\n    \"\"\"\n    Decorator for consistent error handling.\n\n    This provides a standard pattern for:\n    - Logging errors with context\n    - Showing user notifications\n    - Returning fallback values\n    - Re-raising or swallowing exceptions\n\n    Args:\n        operation_name: Name of the operation for logging (e.g., \"load sample\")\n        user_notification: Optional callback to notify user (e.g., self.notify)\n        fallback_value: Value to return if error occurs and re_raise=False\n        re_raise: Whether to re-raise the exception after handling\n        log_level: Logging level for the error (default: ERROR)\n\n    Example:\n        ```python\n        @handle_errors(\n            operation_name=\"load sample\",\n            user_notification=self.notify,\n            re_raise=False,\n            fallback_value=None\n        )\n        def load_sample(self, path: str):\n            # If this raises, it will be logged and user notified\n            return AudioData.from_file(path)\n        ```\n\n    Returns:\n        Decorated function\n    \"\"\"\n    def decorator(func: Callable[..., T]) -&gt; Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -&gt; T:\n            try:\n                return func(*args, **kwargs)\n\n            except LaunchSamplerError as e:\n                # Our custom exceptions have user/technical messages\n                logger.log(log_level, f\"Failed to {operation_name}: {e.technical_message}\")\n\n                if user_notification:\n                    user_notification(e.get_full_message())\n\n                if re_raise:\n                    raise\n                return fallback_value\n\n            except Exception as e:\n                # Unexpected exceptions\n                logger.log(\n                    log_level,\n                    f\"Unexpected error during {operation_name}: {e}\",\n                    exc_info=True\n                )\n\n                if user_notification:\n                    user_notification(f\"Error: {e}\")\n\n                if re_raise:\n                    raise\n                return fallback_value\n\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.wrap_pydantic_error","title":"<code>wrap_pydantic_error(error, file_path)</code>","text":"<p>Convert Pydantic validation errors to LaunchSampler exceptions.</p> <p>This maps validation errors from Pydantic (used for config validation) to our custom exception types with user-friendly messages.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The Pydantic ValidationError</p> required <code>file_path</code> <code>str</code> <p>Path to the config file that failed validation</p> required <p>Returns:</p> Type Description <code>LaunchSamplerError</code> <p>A ConfigurationError with appropriate type and message</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def wrap_pydantic_error(error: Exception, file_path: str) -&gt; LaunchSamplerError:\n    \"\"\"\n    Convert Pydantic validation errors to LaunchSampler exceptions.\n\n    This maps validation errors from Pydantic (used for config validation)\n    to our custom exception types with user-friendly messages.\n\n    Args:\n        error: The Pydantic ValidationError\n        file_path: Path to the config file that failed validation\n\n    Returns:\n        A ConfigurationError with appropriate type and message\n    \"\"\"\n    from pydantic import ValidationError\n\n    error_msg = str(error)\n\n    # Check if it's a JSON parse error (invalid syntax)\n    if \"Invalid JSON\" in error_msg or \"json_invalid\" in error_msg:\n        # Extract the actual parse error from Pydantic's message\n        # Format: \"Invalid JSON: &lt;actual error&gt; [type=json_invalid, ...\"\n        if \"Invalid JSON:\" in error_msg:\n            parse_error = error_msg.split(\"Invalid JSON:\")[1].split(\"[type=\")[0].strip()\n        else:\n            parse_error = error_msg\n\n        return ConfigFileInvalidError(file_path, parse_error)\n\n    # It's a validation error (valid JSON but invalid values)\n    # For Pydantic v2, use the error() method to get structured error info\n    if isinstance(error, ValidationError):\n        errors = error.errors()\n        if errors:\n            # If multiple errors, combine them into a comprehensive message\n            if len(errors) == 1:\n                # Single error - use simple message\n                first_error = errors[0]\n                field = \".\".join(str(loc) for loc in first_error.get('loc', ('unknown',)))\n                reason = first_error.get('msg', 'validation failed')\n                value = first_error.get('input', None)\n\n                return ConfigValidationError(\n                    field=field,\n                    value=value,\n                    error_msg=reason,\n                    file_path=file_path\n                )\n            else:\n                # Multiple errors - show all of them\n                error_lines = []\n                for err in errors:\n                    field = \".\".join(str(loc) for loc in err.get('loc', ('unknown',)))\n                    msg = err.get('msg', 'validation failed')\n                    error_lines.append(f\"  - {field}: {msg}\")\n\n                combined_msg = f\"{len(errors)} validation errors:\\n\" + \"\\n\".join(error_lines)\n\n                return ConfigValidationError(\n                    field=\"multiple fields\",\n                    value=None,\n                    error_msg=combined_msg,\n                    file_path=file_path\n                )\n\n    # Fallback: parse string representation\n    lines = error_msg.split(\"\\n\")\n    field = \"unknown\"\n    reason = error_msg\n\n    for line in lines:\n        if \"Field required\" in line or \"validation error\" in line:\n            # Extract field name from error format\n            parts = line.split()\n            if parts:\n                field = parts[0] if parts else \"unknown\"\n            reason = line\n            break\n\n    return ConfigValidationError(\n        field=field,\n        value=None,\n        error_msg=reason,\n        file_path=file_path\n    )\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.wrap_audio_device_error","title":"<code>wrap_audio_device_error(error, device_id=None)</code>","text":"<p>Convert low-level audio errors to LaunchSampler exceptions.</p> <p>This maps error codes from audio libraries (PortAudio, sounddevice) to our custom exception types with user-friendly messages.</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The original exception from the audio library</p> required <code>device_id</code> <code>Optional[int]</code> <p>The device ID involved in the error</p> <code>None</code> <p>Returns:</p> Type Description <code>LaunchSamplerError</code> <p>A LaunchSamplerError with appropriate type and message</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def wrap_audio_device_error(error: Exception, device_id: Optional[int] = None) -&gt; LaunchSamplerError:\n    \"\"\"\n    Convert low-level audio errors to LaunchSampler exceptions.\n\n    This maps error codes from audio libraries (PortAudio, sounddevice)\n    to our custom exception types with user-friendly messages.\n\n    Args:\n        error: The original exception from the audio library\n        device_id: The device ID involved in the error\n\n    Returns:\n        A LaunchSamplerError with appropriate type and message\n    \"\"\"\n    error_msg = str(error)\n\n    # Check for device-in-use error\n    if \"PaErrorCode -9996\" in error_msg or \"Invalid device\" in error_msg:\n        return AudioDeviceInUseError(device_id=device_id, original_error=error_msg)\n\n    # Check for device not found\n    if \"device\" in error_msg.lower() and \"not found\" in error_msg.lower():\n        if device_id is not None:\n            return AudioDeviceNotFoundError(device_id)\n\n    # Generic audio device error\n    return AudioDeviceError(\n        user_message=f\"Audio device error: {error_msg}\",\n        technical_message=f\"Audio device {device_id} error: {error_msg}\",\n        device_id=device_id\n    )\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.format_error_for_display","title":"<code>format_error_for_display(error)</code>","text":"<p>Format an exception for user display.</p> <p>Returns a tuple of (message, recovery_hint).</p> <p>Parameters:</p> Name Type Description Default <code>error</code> <code>Exception</code> <p>The exception to format</p> required <p>Returns:</p> Type Description <code>tuple[str, Optional[str]]</code> <p>Tuple of (user_message, recovery_hint or None)</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def format_error_for_display(error: Exception) -&gt; tuple[str, Optional[str]]:\n    \"\"\"\n    Format an exception for user display.\n\n    Returns a tuple of (message, recovery_hint).\n\n    Args:\n        error: The exception to format\n\n    Returns:\n        Tuple of (user_message, recovery_hint or None)\n    \"\"\"\n    if isinstance(error, LaunchSamplerError):\n        return error.user_message, error.recovery_hint\n\n    # For standard exceptions, create a user-friendly message\n    error_type = type(error).__name__\n    return f\"{error_type}: {error}\", None\n</code></pre>"},{"location":"api/exceptions/handlers/#launchsampler.exceptions.handlers.collect_errors","title":"<code>collect_errors(operation)</code>","text":"<p>Create an error collector for batch operations.</p> <p>Use this when you want to attempt multiple operations and collect all errors before reporting them.</p> Example <pre><code>collector = collect_errors(\"load samples\")\n\nfor file in files:\n    with collector.try_operation(f\"load {file}\"):\n        load_sample(file)\n\nif collector.has_errors:\n    print(f\"Failed to load {collector.error_count} samples:\")\n    for error in collector.errors:\n        print(f\"  - {error}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Description of the overall operation</p> required <p>Returns:</p> Type Description <code>ErrorCollector</code> <p>ErrorCollector instance</p> Source code in <code>src/launchsampler/exceptions/handlers.py</code> <pre><code>def collect_errors(operation: str) -&gt; \"ErrorCollector\":\n    \"\"\"\n    Create an error collector for batch operations.\n\n    Use this when you want to attempt multiple operations and collect\n    all errors before reporting them.\n\n    Example:\n        ```python\n        collector = collect_errors(\"load samples\")\n\n        for file in files:\n            with collector.try_operation(f\"load {file}\"):\n                load_sample(file)\n\n        if collector.has_errors:\n            print(f\"Failed to load {collector.error_count} samples:\")\n            for error in collector.errors:\n                print(f\"  - {error}\")\n        ```\n\n    Args:\n        operation: Description of the overall operation\n\n    Returns:\n        ErrorCollector instance\n    \"\"\"\n    return ErrorCollector(operation)\n</code></pre>"},{"location":"api/led_ui/","title":"LED UI","text":"<p>Hardware LED grid user interface support</p> <p>LED UI for Launchpad hardware.</p> Architecture Overview <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Application Layer (TUI/Core)                       \u2502\n\u2502  - Pad state changes, UI updates                    \u2502\n\u2502  - Works with logical pad indices (0-63)            \u2502\n\u2502  - Works with (x, y) coordinates (0-7, 0-7)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Generic Device Abstraction                         \u2502\n\u2502  - Device: input + output layers                    \u2502\n\u2502  - DeviceInput: parse messages \u2192 events             \u2502\n\u2502  - DeviceOutput: state \u2192 hardware messages          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Launchpad Device (Concrete Implementation)         \u2502\n\u2502  \u251c\u2500 LaunchpadModel (detection &amp; metadata)           \u2502\n\u2502  \u251c\u2500 LaunchpadInput (parse MIDI \u2192 pad events)        \u2502\n\u2502  \u2502  \u2514\u2500 NoteMapper (note \u2192 index/coordinates)        \u2502\n\u2502  \u2514\u2500 LaunchpadOutput (LED display control)           \u2502\n\u2502     \u2514\u2500 IndexMapper (index/coordinates \u2192 note)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Launchpad Protocol Layer                           \u2502\n\u2502  \u251c\u2500 SysEx message builder                           \u2502\n\u2502  \u251c\u2500 Color palette                                   \u2502\n\u2502  \u2514\u2500 Lighting modes                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  MIDI Transport (Existing)                          \u2502\n\u2502  - MidiManager (send/receive)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI","title":"<code>LaunchpadLEDUI(orchestrator, poll_interval=5.0)</code>","text":"<p>               Bases: <code>UIAdapter</code></p> <p>LED UI implementation that displays the pad grid on Launchpad hardware.</p> <p>This UI adapter implements the UIAdapter protocol and runs in the background, mirroring the TUI's grid state on the physical Launchpad LEDs.</p> <p>The LED UI: - Runs in background (non-blocking) - Mirrors the 8x8 grid state from the TUI - Shows pad assignments with configured colors - Shows playing pads with pulsing yellow animation - Automatically syncs with all state changes</p> <p>Lifecycle: 1. init: Create controller and service, register as observer 2. initialize(): Start LED controller 3. run(): Non-blocking (returns immediately) 4. shutdown(): Stop controller and clean up</p> <p>Initialize the LED UI.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator orchestrator</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for Launchpad device (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def __init__(self, orchestrator: \"Orchestrator\", poll_interval: float = 5.0):\n    \"\"\"\n    Initialize the LED UI.\n\n    Args:\n        orchestrator: The Orchestrator orchestrator\n        poll_interval: How often to check for Launchpad device (seconds)\n    \"\"\"\n    self.orchestrator = orchestrator\n    self.poll_interval = poll_interval\n\n    # We'll use the orchestrator's LaunchpadController (shared resource)\n    # This avoids MIDI port conflicts\n    self.controller = None  # Will be set in register_with_services()\n\n    # Create LED renderer (stateless) - controller will be set later\n    self.renderer = LEDRenderer(None)\n\n    # Create LED event handler (observer) - pass renderer and shared state machine\n    self.event_handler = LEDEventHandler(self.renderer, orchestrator, orchestrator.state_machine)\n\n    # Register service with orchestrator services\n    self._register_with_services()\n\n    logger.info(\"LaunchpadLEDUI initialized\")\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the LED UI before the orchestrator starts.</p> <p>The LED UI uses the orchestrator's LaunchpadController (shared resource), so there's nothing to initialize here. The controller is created by the orchestrator.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the LED UI before the orchestrator starts.\n\n    The LED UI uses the orchestrator's LaunchpadController (shared resource),\n    so there's nothing to initialize here. The controller is created by the orchestrator.\n    \"\"\"\n    logger.info(\"Initializing LED UI (using orchestrator's LaunchpadController)\")\n    # Nothing to do - we use the orchestrator's controller\n    pass\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register LED event handler with all orchestrator services after they're initialized.</p> <p>Called by orchestrator after services are created.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator instance</p> required Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"Orchestrator\") -&gt; None:\n    \"\"\"\n    Register LED event handler with all orchestrator services after they're initialized.\n\n    Called by orchestrator after services are created.\n\n    Args:\n        orchestrator: The Orchestrator instance\n    \"\"\"\n    # Use orchestrator's MIDI controller (shared resource)\n    if orchestrator.midi_controller:\n        self.controller = orchestrator.midi_controller\n        self.renderer.controller = self.controller\n        logger.info(\"LED UI using orchestrator's LaunchpadController\")\n    else:\n        logger.warning(\"No MIDI controller available - LED UI will not function\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.event_handler)\n\n    # Register for playback state events\n    orchestrator.player.register_state_observer(self.event_handler)\n\n    # Register for MIDI events (connection/disconnection only)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.event_handler)\n\n    logger.info(\"LED event handler registered with all services\")\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.run","title":"<code>run()</code>","text":"<p>Run the LED UI.</p> <p>LED UI is a background UI, so this returns immediately. The Launchpad controller runs in its own polling thread.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the LED UI.\n\n    LED UI is a background UI, so this returns immediately.\n    The Launchpad controller runs in its own polling thread.\n    \"\"\"\n    logger.info(\"LED UI running in background\")\n    # Non-blocking - LED controller runs in background thread\n    pass\n</code></pre>"},{"location":"api/led_ui/#launchsampler.led_ui.LaunchpadLEDUI.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the LED UI and clean up resources.</p> <p>Since we reuse the Player's LaunchpadController, we don't stop it here. We only unregister our observers.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the LED UI and clean up resources.\n\n    Since we reuse the Player's LaunchpadController, we don't stop it here.\n    We only unregister our observers.\n    \"\"\"\n    logger.info(\"Shutting down LED UI\")\n\n    # Unregister observers\n    try:\n        self.orchestrator.unregister_observer(self.event_handler)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.event_handler)\n        if self.orchestrator.player:\n            self.orchestrator.player.unregister_state_observer(self.event_handler)\n        if self.orchestrator.midi_controller:\n            self.orchestrator.midi_controller.unregister_observer(self.event_handler)\n        logger.info(\"LED event handler unregistered from all services\")\n    except Exception as e:\n        logger.error(f\"Error unregistering LED event handler observers: {e}\")\n\n    # Don't stop the controller - we don't own it, the orchestrator does\n    logger.info(\"LED UI shut down\")\n</code></pre>"},{"location":"api/led_ui/app/","title":"App","text":""},{"location":"api/led_ui/app/#launchsampler.led_ui.app","title":"<code>app</code>","text":"<p>LED UI adapter for Launchpad hardware display.</p>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI","title":"<code>LaunchpadLEDUI(orchestrator, poll_interval=5.0)</code>","text":"<p>               Bases: <code>UIAdapter</code></p> <p>LED UI implementation that displays the pad grid on Launchpad hardware.</p> <p>This UI adapter implements the UIAdapter protocol and runs in the background, mirroring the TUI's grid state on the physical Launchpad LEDs.</p> <p>The LED UI: - Runs in background (non-blocking) - Mirrors the 8x8 grid state from the TUI - Shows pad assignments with configured colors - Shows playing pads with pulsing yellow animation - Automatically syncs with all state changes</p> <p>Lifecycle: 1. init: Create controller and service, register as observer 2. initialize(): Start LED controller 3. run(): Non-blocking (returns immediately) 4. shutdown(): Stop controller and clean up</p> <p>Initialize the LED UI.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator orchestrator</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for Launchpad device (seconds)</p> <code>5.0</code> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def __init__(self, orchestrator: \"Orchestrator\", poll_interval: float = 5.0):\n    \"\"\"\n    Initialize the LED UI.\n\n    Args:\n        orchestrator: The Orchestrator orchestrator\n        poll_interval: How often to check for Launchpad device (seconds)\n    \"\"\"\n    self.orchestrator = orchestrator\n    self.poll_interval = poll_interval\n\n    # We'll use the orchestrator's LaunchpadController (shared resource)\n    # This avoids MIDI port conflicts\n    self.controller = None  # Will be set in register_with_services()\n\n    # Create LED renderer (stateless) - controller will be set later\n    self.renderer = LEDRenderer(None)\n\n    # Create LED event handler (observer) - pass renderer and shared state machine\n    self.event_handler = LEDEventHandler(self.renderer, orchestrator, orchestrator.state_machine)\n\n    # Register service with orchestrator services\n    self._register_with_services()\n\n    logger.info(\"LaunchpadLEDUI initialized\")\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the LED UI before the orchestrator starts.</p> <p>The LED UI uses the orchestrator's LaunchpadController (shared resource), so there's nothing to initialize here. The controller is created by the orchestrator.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the LED UI before the orchestrator starts.\n\n    The LED UI uses the orchestrator's LaunchpadController (shared resource),\n    so there's nothing to initialize here. The controller is created by the orchestrator.\n    \"\"\"\n    logger.info(\"Initializing LED UI (using orchestrator's LaunchpadController)\")\n    # Nothing to do - we use the orchestrator's controller\n    pass\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register LED event handler with all orchestrator services after they're initialized.</p> <p>Called by orchestrator after services are created.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator instance</p> required Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"Orchestrator\") -&gt; None:\n    \"\"\"\n    Register LED event handler with all orchestrator services after they're initialized.\n\n    Called by orchestrator after services are created.\n\n    Args:\n        orchestrator: The Orchestrator instance\n    \"\"\"\n    # Use orchestrator's MIDI controller (shared resource)\n    if orchestrator.midi_controller:\n        self.controller = orchestrator.midi_controller\n        self.renderer.controller = self.controller\n        logger.info(\"LED UI using orchestrator's LaunchpadController\")\n    else:\n        logger.warning(\"No MIDI controller available - LED UI will not function\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.event_handler)\n\n    # Register for playback state events\n    orchestrator.player.register_state_observer(self.event_handler)\n\n    # Register for MIDI events (connection/disconnection only)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.event_handler)\n\n    logger.info(\"LED event handler registered with all services\")\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.run","title":"<code>run()</code>","text":"<p>Run the LED UI.</p> <p>LED UI is a background UI, so this returns immediately. The Launchpad controller runs in its own polling thread.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the LED UI.\n\n    LED UI is a background UI, so this returns immediately.\n    The Launchpad controller runs in its own polling thread.\n    \"\"\"\n    logger.info(\"LED UI running in background\")\n    # Non-blocking - LED controller runs in background thread\n    pass\n</code></pre>"},{"location":"api/led_ui/app/#launchsampler.led_ui.app.LaunchpadLEDUI.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the LED UI and clean up resources.</p> <p>Since we reuse the Player's LaunchpadController, we don't stop it here. We only unregister our observers.</p> Source code in <code>src/launchsampler/led_ui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the LED UI and clean up resources.\n\n    Since we reuse the Player's LaunchpadController, we don't stop it here.\n    We only unregister our observers.\n    \"\"\"\n    logger.info(\"Shutting down LED UI\")\n\n    # Unregister observers\n    try:\n        self.orchestrator.unregister_observer(self.event_handler)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.event_handler)\n        if self.orchestrator.player:\n            self.orchestrator.player.unregister_state_observer(self.event_handler)\n        if self.orchestrator.midi_controller:\n            self.orchestrator.midi_controller.unregister_observer(self.event_handler)\n        logger.info(\"LED event handler unregistered from all services\")\n    except Exception as e:\n        logger.error(f\"Error unregistering LED event handler observers: {e}\")\n\n    # Don't stop the controller - we don't own it, the orchestrator does\n    logger.info(\"LED UI shut down\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/","title":"Led Event Handler","text":""},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler","title":"<code>led_event_handler</code>","text":"<p>Event handler for LED UI synchronization with application state.</p>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler","title":"<code>LEDEventHandler(renderer, orchestrator, state_machine)</code>","text":"<p>               Bases: <code>AppObserver</code>, <code>EditObserver</code>, <code>MidiObserver</code>, <code>StateObserver</code></p> <p>Event handler for synchronizing the Launchpad LED grid with application state.</p> <p>This service observes all system events and delegates LED rendering to LEDRenderer. It decouples the application core from LED-specific update logic.</p> <p>Implements multiple observer protocols: - AppObserver: App lifecycle events (SET_MOUNTED, SET_SAVED, etc.) - EditObserver: Editing events (PAD_ASSIGNED, PAD_CLEARED, etc.) - MidiObserver: MIDI controller events (NOTE_ON, NOTE_OFF, etc.) - StateObserver: Playback events (PAD_PLAYING, PAD_STOPPED, etc.)</p> <p>LED Color Scheme (synchronized with TUI via ui_colors module): - Empty pad: Off (black) - Assigned pad: Mode-specific color (red/green/blue/magenta) - Playing pad: Pulsing yellow (overrides mode color)</p> <p>Initialize the LED event handler.</p> <p>Parameters:</p> Name Type Description Default <code>renderer</code> <code>LEDRenderer</code> <p>The LED renderer for hardware updates</p> required <code>orchestrator</code> <p>The Orchestrator orchestrator</p> required <code>state_machine</code> <code>SamplerStateMachine</code> <p>Shared state machine for querying playback state</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def __init__(self, renderer: LEDRenderer, orchestrator, state_machine: SamplerStateMachine):\n    \"\"\"\n    Initialize the LED event handler.\n\n    Args:\n        renderer: The LED renderer for hardware updates\n        orchestrator: The Orchestrator orchestrator\n        state_machine: Shared state machine for querying playback state\n    \"\"\"\n    self.renderer = renderer\n    self.orchestrator = orchestrator\n    self.state_machine = state_machine\n    logger.info(\"LEDEventHandler initialized\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data</p> <code>{}</code> Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_app_event(self, event: AppEvent, **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data\n    \"\"\"\n    try:\n        if event == AppEvent.SET_MOUNTED:\n            self._handle_set_mounted(**kwargs)\n        elif event == AppEvent.SET_SAVED:\n            # No LED action needed on save\n            pass\n        elif event == AppEvent.MODE_CHANGED:\n            # No LED action needed on mode change\n            pass\n        else:\n            logger.warning(f\"LEDEventHandler received unknown app event: {event}\")\n\n    except Exception as e:\n        logger.error(f\"Error handling app event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and update LEDs.</p> <p>This is called when editing operations occur. Automatically synchronizes the LEDs with the new pad states.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events and update LEDs.\n\n    This is called when editing operations occur.\n    Automatically synchronizes the LEDs with the new pad states.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received edit event: {event.value} for pads {pad_indices}\")\n\n    try:\n        # Update LEDs for edited pads\n        for pad_index, pad in zip(pad_indices, pads):\n            self._update_pad_led(pad_index, pad)\n\n    except Exception as e:\n        logger.error(f\"Error handling edit event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>Called from MIDI thread via LaunchpadController.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    Called from MIDI thread via LaunchpadController.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received MIDI event: {event}, pad_index: {pad_index}\")\n\n    # Handle device connection/disconnection events\n    if event == MidiEvent.CONTROLLER_CONNECTED:\n        logger.info(\"Launchpad connected - syncing LED grid\")\n        # Sync all LEDs when device connects\n        self._update_all_leds()\n        # Light up panic button\n        self._set_panic_button_led()\n    elif event == MidiEvent.CONTROLLER_DISCONNECTED:\n        logger.info(\"Launchpad disconnected\")\n</code></pre>"},{"location":"api/led_ui/services/led_event_handler/#launchsampler.led_ui.services.led_event_handler.LEDEventHandler.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>Called from audio thread via callback.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The playback event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63)</p> required Source code in <code>src/launchsampler/led_ui/services/led_event_handler.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    Called from audio thread via callback.\n\n    Args:\n        event: The playback event that occurred\n        pad_index: Index of the pad (0-63)\n    \"\"\"\n    logger.debug(f\"LEDEventHandler received playback event: {event}, pad_index: {pad_index}\")\n\n    try:\n        if event == PlaybackEvent.PAD_PLAYING:\n            # Pad started playing - show pulsing yellow\n            self._set_pad_playing_led(pad_index, True)\n\n        elif event in (PlaybackEvent.PAD_STOPPED, PlaybackEvent.PAD_FINISHED):\n            # Pad stopped or finished - restore normal color\n            self._set_pad_playing_led(pad_index, False)\n\n    except Exception as e:\n        logger.error(f\"Error handling playback event {event}: {e}\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/","title":"Led Renderer","text":""},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer","title":"<code>led_renderer</code>","text":"<p>LED rendering logic for Launchpad hardware.</p>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer","title":"<code>LEDRenderer(controller)</code>","text":"<p>Stateless renderer that translates application state to LED hardware commands.</p> <p>This class contains only rendering logic - no event handling or state management. It queries state from canonical sources (orchestrator, state_machine) and renders the appropriate LED colors.</p> <p>Responsibilities: - Update individual pad LEDs - Update all pad LEDs in bulk - Set playing animations (pulsing) - Set panic button LED</p> <p>Initialize the LED renderer.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <code>Optional[DeviceController]</code> <p>The device controller instance (may be None initially)</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def __init__(self, controller: Optional[DeviceController]):\n    \"\"\"\n    Initialize the LED renderer.\n\n    Args:\n        controller: The device controller instance (may be None initially)\n    \"\"\"\n    self.controller = controller\n    logger.debug(\"LEDRenderer initialized\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.update_all_pads","title":"<code>update_all_pads(all_pads, playing_pads)</code>","text":"<p>Update all 64 pad LEDs to reflect current state.</p> <p>Parameters:</p> Name Type Description Default <code>all_pads</code> <code>list[Pad]</code> <p>List of all 64 pad states from orchestrator</p> required <code>playing_pads</code> <code>set[int]</code> <p>Set of pad indices currently playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def update_all_pads(self, all_pads: list[\"Pad\"], playing_pads: set[int]) -&gt; None:\n    \"\"\"\n    Update all 64 pad LEDs to reflect current state.\n\n    Args:\n        all_pads: List of all 64 pad states from orchestrator\n        playing_pads: Set of pad indices currently playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.warning(\"Cannot update LEDs: Controller not available or not connected\")\n        return\n\n    # Build bulk update list for non-playing pads\n    updates = []\n    for i in range(64):\n        # Check if pad is currently playing\n        if i in playing_pads:\n            # Playing pads get pulsing animation (set individually, not in bulk)\n            continue\n\n        pad = all_pads[i]\n        if pad.is_assigned:\n            # Get color from centralized color scheme\n            color = get_pad_led_color(pad, is_playing=False)\n            updates.append((i, color))\n        else:\n            # Pad is empty, turn off\n            updates.append((i, Color.off()))\n\n    # Send bulk update for non-playing pads\n    if updates:\n        self.controller.set_leds_bulk(updates)\n        logger.info(f\"Updated {len(updates)} non-playing LEDs\")\n\n    # Set playing pads with animation\n    for pad_index in playing_pads:\n        pad = all_pads[pad_index]\n        palette_color = get_pad_led_palette_index(pad, is_playing=True)\n        self.controller.set_pad_pulsing(pad_index, palette_color)\n        logger.debug(f\"Set playing animation for pad {pad_index}\")\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.update_pad","title":"<code>update_pad(pad_index, pad, is_playing)</code>","text":"<p>Update LED for a single pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether this pad is currently playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def update_pad(self, pad_index: int, pad: \"Pad\", is_playing: bool) -&gt; None:\n    \"\"\"\n    Update LED for a single pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        pad: Pad model\n        is_playing: Whether this pad is currently playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot update LED: Controller not available or not connected\")\n        return\n\n    # If pad is playing, don't override the playing animation\n    if is_playing:\n        return\n\n    # Set color from centralized color scheme\n    color = get_pad_led_color(pad, is_playing=False)\n    self.controller.set_pad_color(pad_index, color)\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.set_playing_animation","title":"<code>set_playing_animation(pad_index, pad, is_playing)</code>","text":"<p>Update LED to reflect pad playing state (pulsing animation).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether pad is playing</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def set_playing_animation(self, pad_index: int, pad: \"Pad\", is_playing: bool) -&gt; None:\n    \"\"\"\n    Update LED to reflect pad playing state (pulsing animation).\n\n    Args:\n        pad_index: Index of pad (0-63)\n        pad: Pad model\n        is_playing: Whether pad is playing\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot update LED: Controller not available or not connected\")\n        return\n\n    if is_playing:\n        # Pulse with playing color (centralized from ui_colors)\n        palette_color = get_pad_led_palette_index(pad, is_playing=True)\n        self.controller.set_pad_pulsing(pad_index, palette_color)\n    else:\n        # Restore normal color\n        if pad.is_assigned:\n            self.update_pad(pad_index, pad, is_playing=False)\n        else:\n            self.controller.set_pad_color(pad_index, Color.off())\n</code></pre>"},{"location":"api/led_ui/services/led_renderer/#launchsampler.led_ui.services.led_renderer.LEDRenderer.set_panic_button","title":"<code>set_panic_button(panic_button_cc)</code>","text":"<p>Set the panic button LED to dark red.</p> <p>Parameters:</p> Name Type Description Default <code>panic_button_cc</code> <code>int</code> <p>The CC control number for the panic button</p> required Source code in <code>src/launchsampler/led_ui/services/led_renderer.py</code> <pre><code>def set_panic_button(self, panic_button_cc: int) -&gt; None:\n    \"\"\"\n    Set the panic button LED to dark red.\n\n    Args:\n        panic_button_cc: The CC control number for the panic button\n    \"\"\"\n    if not self.controller or not self.controller.is_connected:\n        logger.debug(\"Cannot set panic button LED: Controller not available or not connected\")\n        return\n\n    if not self.controller._device:\n        logger.debug(\"Cannot set panic button LED: Device not initialized\")\n        return\n\n    # Set the LED to dark red using the RGB color\n    self.controller._device.output.set_control_led(panic_button_cc, PANIC_BUTTON_COLOR.rgb)\n    logger.info(f\"Panic button LED set for CC {panic_button_cc}\")\n</code></pre>"},{"location":"api/midi/","title":"Midi","text":"<p>MIDI input/output management</p> <p>MIDI management - generic MIDI functionality.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager","title":"<code>BaseMidiManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[PortType]</code></p> <p>Base MIDI manager with hot-plug support.</p> <p>Monitors for MIDI devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Subclasses must implement abstract methods for port-specific operations.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if MIDI device is currently connected.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.current_port","title":"<code>current_port</code>  <code>property</code>","text":"<p>Get currently connected port name.</p>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    if self._running:\n        logger.warning(f\"Midi{self._get_port_type_name().capitalize()}Manager is already running\")\n        return\n\n    self._running = True\n    self._monitor_thread = threading.Thread(target=self._monitor_devices, daemon=True)\n    self._monitor_thread.start()\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager started\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    self._on_connection_changed = callback\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._running = False\n\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.close()\n            except Exception as e:\n                logger.error(f\"Error closing MIDI {self._get_port_type_name()} port: {e}\")\n            self._port = None\n\n    if self._monitor_thread and self._monitor_thread.is_alive():\n        self._monitor_thread.join(timeout=1.0)\n\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager stopped\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.BaseMidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiInputManager","title":"<code>MidiInputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseInput]</code></p> <p>Generic MIDI input manager with hot-plug support.</p> <p>Monitors for MIDI input devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Initialize MIDI input manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI input manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    super().__init__(device_filter, poll_interval, port_selector)\n    self._message_callback: Optional[Callable[[mido.Message], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiInputManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._message_callback = callback\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager","title":"<code>MidiManager(device_filter, poll_interval=5.0, input_port_selector=None, output_port_selector=None)</code>","text":"<p>Generic MIDI manager combining input and output functionality.</p> <p>Provides a unified interface for MIDI device management with hot-plug support.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>input_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best input port from candidates.                 If None, selects first matching port.</p> <code>None</code> <code>output_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best output port from candidates.                  If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    input_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None,\n    output_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        input_port_selector: Optional function to select best input port from candidates.\n                            If None, selects first matching port.\n        output_port_selector: Optional function to select best output port from candidates.\n                             If None, selects first matching port.\n    \"\"\"\n    self._input_manager = MidiInputManager(device_filter, poll_interval, input_port_selector)\n    self._output_manager = MidiOutputManager(device_filter, poll_interval, output_port_selector)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if both input and output devices are connected.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.current_input_port","title":"<code>current_input_port</code>  <code>property</code>","text":"<p>Get currently connected input port name.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.current_output_port","title":"<code>current_output_port</code>  <code>property</code>","text":"<p>Get currently connected output port name.</p>"},{"location":"api/midi/#launchsampler.midi.MidiManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._input_manager.on_message(callback)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Callback is executed when device connects or disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Callback is executed when device connects or disconnects.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    # Register same callback for both input and output (fires twice, but that's ok)\n    self._input_manager.on_connection_changed(callback)\n    self._output_manager.on_connection_changed(callback)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    return self._output_manager.send(message)\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    self._input_manager.start()\n    self._output_manager.start()\n    logger.debug(\"MidiManager started\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._input_manager.stop()\n    self._output_manager.stop()\n    logger.debug(\"MidiManager stopped\")\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.list_ports","title":"<code>list_ports()</code>  <code>staticmethod</code>","text":"<p>List all available MIDI ports.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'input' and 'output' lists of port names</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>@staticmethod\ndef list_ports() -&gt; dict:\n    \"\"\"\n    List all available MIDI ports.\n\n    Returns:\n        Dictionary with 'input' and 'output' lists of port names\n    \"\"\"\n    return {\n        'input': mido.get_input_names(),\n        'output': mido.get_output_names()\n    }\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiOutputManager","title":"<code>MidiOutputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseOutput]</code></p> <p>Generic MIDI output manager with hot-plug support.</p> <p>Monitors for MIDI output devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/#launchsampler.midi.MidiOutputManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/output_manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.send(message)\n                return True\n            except Exception as e:\n                logger.error(f\"Error sending MIDI message: {e}\")\n                return False\n        return False\n</code></pre>"},{"location":"api/midi/base_manager/","title":"Base Manager","text":""},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager","title":"<code>base_manager</code>","text":"<p>Base MIDI manager with hot-plug support.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager","title":"<code>BaseMidiManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[PortType]</code></p> <p>Base MIDI manager with hot-plug support.</p> <p>Monitors for MIDI devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Subclasses must implement abstract methods for port-specific operations.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if MIDI device is currently connected.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.current_port","title":"<code>current_port</code>  <code>property</code>","text":"<p>Get currently connected port name.</p>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    if self._running:\n        logger.warning(f\"Midi{self._get_port_type_name().capitalize()}Manager is already running\")\n        return\n\n    self._running = True\n    self._monitor_thread = threading.Thread(target=self._monitor_devices, daemon=True)\n    self._monitor_thread.start()\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager started\")\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    self._on_connection_changed = callback\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._running = False\n\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.close()\n            except Exception as e:\n                logger.error(f\"Error closing MIDI {self._get_port_type_name()} port: {e}\")\n            self._port = None\n\n    if self._monitor_thread and self._monitor_thread.is_alive():\n        self._monitor_thread.join(timeout=1.0)\n\n    logger.debug(f\"Midi{self._get_port_type_name().capitalize()}Manager stopped\")\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/base_manager/#launchsampler.midi.base_manager.BaseMidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/input_manager/","title":"Input Manager","text":""},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager","title":"<code>input_manager</code>","text":"<p>Generic MIDI input manager with hot-plug support.</p>"},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager.MidiInputManager","title":"<code>MidiInputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseInput]</code></p> <p>Generic MIDI input manager with hot-plug support.</p> <p>Monitors for MIDI input devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> <p>Initialize MIDI input manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best port from candidates.           If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI input manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    super().__init__(device_filter, poll_interval, port_selector)\n    self._message_callback: Optional[Callable[[mido.Message], None]] = None\n</code></pre>"},{"location":"api/midi/input_manager/#launchsampler.midi.input_manager.MidiInputManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/input_manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._message_callback = callback\n</code></pre>"},{"location":"api/midi/manager/","title":"Manager","text":""},{"location":"api/midi/manager/#launchsampler.midi.manager","title":"<code>manager</code>","text":"<p>Generic MIDI manager combining input and output.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager","title":"<code>MidiManager(device_filter, poll_interval=5.0, input_port_selector=None, output_port_selector=None)</code>","text":"<p>Generic MIDI manager combining input and output functionality.</p> <p>Provides a unified interface for MIDI device management with hot-plug support.</p> <p>Initialize MIDI manager.</p> <p>Parameters:</p> Name Type Description Default <code>device_filter</code> <code>Callable[[str], bool]</code> <p>Function that returns True if port name matches desired device</p> required <code>poll_interval</code> <code>float</code> <p>How often to check for device changes (seconds)</p> <code>5.0</code> <code>input_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best input port from candidates.                 If None, selects first matching port.</p> <code>None</code> <code>output_port_selector</code> <code>Optional[Callable[[list[str]], Optional[str]]]</code> <p>Optional function to select best output port from candidates.                  If None, selects first matching port.</p> <code>None</code> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    input_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None,\n    output_port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        input_port_selector: Optional function to select best input port from candidates.\n                            If None, selects first matching port.\n        output_port_selector: Optional function to select best output port from candidates.\n                             If None, selects first matching port.\n    \"\"\"\n    self._input_manager = MidiInputManager(device_filter, poll_interval, input_port_selector)\n    self._output_manager = MidiOutputManager(device_filter, poll_interval, output_port_selector)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.is_connected","title":"<code>is_connected</code>  <code>property</code>","text":"<p>Check if both input and output devices are connected.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.current_input_port","title":"<code>current_input_port</code>  <code>property</code>","text":"<p>Get currently connected input port name.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.current_output_port","title":"<code>current_output_port</code>  <code>property</code>","text":"<p>Get currently connected output port name.</p>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.on_message","title":"<code>on_message(callback)</code>","text":"<p>Register callback for incoming MIDI messages.</p> <p>Callback is executed in mido's internal I/O thread - keep it fast!</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[Message], None]</code> <p>Function that receives mido.Message</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_message(self, callback: Callable[[mido.Message], None]) -&gt; None:\n    \"\"\"\n    Register callback for incoming MIDI messages.\n\n    Callback is executed in mido's internal I/O thread - keep it fast!\n\n    Args:\n        callback: Function that receives mido.Message\n    \"\"\"\n    self._input_manager.on_message(callback)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.on_connection_changed","title":"<code>on_connection_changed(callback)</code>","text":"<p>Register callback for connection state changes.</p> <p>Callback is executed when device connects or disconnects.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[bool, Optional[str]], None]</code> <p>Function that receives (is_connected: bool, port_name: Optional[str])</p> required Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def on_connection_changed(self, callback: Callable[[bool, Optional[str]], None]) -&gt; None:\n    \"\"\"\n    Register callback for connection state changes.\n\n    Callback is executed when device connects or disconnects.\n\n    Args:\n        callback: Function that receives (is_connected: bool, port_name: Optional[str])\n    \"\"\"\n    # Register same callback for both input and output (fires twice, but that's ok)\n    self._input_manager.on_connection_changed(callback)\n    self._output_manager.on_connection_changed(callback)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    return self._output_manager.send(message)\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.start","title":"<code>start()</code>","text":"<p>Start monitoring for MIDI devices.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def start(self) -&gt; None:\n    \"\"\"Start monitoring for MIDI devices.\"\"\"\n    self._input_manager.start()\n    self._output_manager.start()\n    logger.debug(\"MidiManager started\")\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.stop","title":"<code>stop()</code>","text":"<p>Stop monitoring and close connections.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def stop(self) -&gt; None:\n    \"\"\"Stop monitoring and close connections.\"\"\"\n    self._input_manager.stop()\n    self._output_manager.stop()\n    logger.debug(\"MidiManager stopped\")\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.list_ports","title":"<code>list_ports()</code>  <code>staticmethod</code>","text":"<p>List all available MIDI ports.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with 'input' and 'output' lists of port names</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>@staticmethod\ndef list_ports() -&gt; dict:\n    \"\"\"\n    List all available MIDI ports.\n\n    Returns:\n        Dictionary with 'input' and 'output' lists of port names\n    \"\"\"\n    return {\n        'input': mido.get_input_names(),\n        'output': mido.get_output_names()\n    }\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.__enter__","title":"<code>__enter__()</code>","text":"<p>Context manager entry.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __enter__(self):\n    \"\"\"Context manager entry.\"\"\"\n    self.start()\n    return self\n</code></pre>"},{"location":"api/midi/manager/#launchsampler.midi.manager.MidiManager.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Context manager exit.</p> Source code in <code>src/launchsampler/midi/manager.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Context manager exit.\"\"\"\n    self.stop()\n</code></pre>"},{"location":"api/midi/output_manager/","title":"Output Manager","text":""},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager","title":"<code>output_manager</code>","text":"<p>Generic MIDI output manager with hot-plug support.</p>"},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager.MidiOutputManager","title":"<code>MidiOutputManager(device_filter, poll_interval=5.0, port_selector=None)</code>","text":"<p>               Bases: <code>BaseMidiManager[BaseOutput]</code></p> <p>Generic MIDI output manager with hot-plug support.</p> <p>Monitors for MIDI output devices matching a filter function, automatically connects/reconnects when devices are plugged/unplugged.</p> Source code in <code>src/launchsampler/midi/base_manager.py</code> <pre><code>def __init__(\n    self,\n    device_filter: Callable[[str], bool],\n    poll_interval: float = 5.0,\n    port_selector: Optional[Callable[[list[str]], Optional[str]]] = None\n):\n    \"\"\"\n    Initialize MIDI manager.\n\n    Args:\n        device_filter: Function that returns True if port name matches desired device\n        poll_interval: How often to check for device changes (seconds)\n        port_selector: Optional function to select best port from candidates.\n                      If None, selects first matching port.\n    \"\"\"\n    self._device_filter = device_filter\n    self._poll_interval = poll_interval\n    self._port_selector = port_selector\n    self._running = False\n    self._monitor_thread: Optional[threading.Thread] = None\n    self._port: Optional[PortType] = None\n    self._port_lock = threading.Lock()\n    self._no_device_warned = False\n    self._on_connection_changed: Optional[Callable[[bool, Optional[str]], None]] = None\n</code></pre>"},{"location":"api/midi/output_manager/#launchsampler.midi.output_manager.MidiOutputManager.send","title":"<code>send(message)</code>","text":"<p>Send MIDI message to device.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Message</code> <p>MIDI message to send</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if sent successfully, False if not connected</p> Source code in <code>src/launchsampler/midi/output_manager.py</code> <pre><code>def send(self, message: mido.Message) -&gt; bool:\n    \"\"\"\n    Send MIDI message to device.\n\n    Args:\n        message: MIDI message to send\n\n    Returns:\n        True if sent successfully, False if not connected\n    \"\"\"\n    with self._port_lock:\n        if self._port:\n            try:\n                self._port.send(message)\n                return True\n            except Exception as e:\n                logger.error(f\"Error sending MIDI message: {e}\")\n                return False\n        return False\n</code></pre>"},{"location":"api/model_manager/","title":"Model Manager","text":"<p>Generic model management framework for Pydantic models</p> <p>Generic model management framework for Pydantic models.</p> <p>This package provides a complete framework for managing Pydantic models with:</p> <ul> <li>Stateful service management (ModelManagerService)</li> <li>Persistence (PydanticPersistence)</li> <li>Observer pattern (ModelEvent, ModelObserver, ObserverManager)</li> <li>CLI generation (ModelCLIBuilder)</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--public-api","title":"Public API","text":""},{"location":"api/model_manager/#launchsampler.model_manager--core-service","title":"Core Service","text":"<ul> <li>ModelManagerService: Generic service for managing any Pydantic model</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--persistence","title":"Persistence","text":"<ul> <li>PydanticPersistence: Utility for loading/saving Pydantic models to JSON</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--observer-pattern","title":"Observer Pattern","text":"<ul> <li>ModelEvent: Enum of model lifecycle events</li> <li>ModelObserver: Protocol for observing model changes</li> <li>ObserverManager: Generic observer pattern implementation</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--protocols","title":"Protocols","text":"<ul> <li>PersistenceService: Protocol for persistence service implementations</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--cli-generation-from-model_managercli","title":"CLI Generation (from model_manager.cli)","text":"<ul> <li>ModelCLIBuilder: Auto-generate CLI from Pydantic models</li> <li>TypeMapper: Maps Pydantic types to Click types</li> <li>ValidatorRegistry: Registry for custom field validators</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--design-philosophy","title":"Design Philosophy","text":"<ul> <li>Generic and reusable across any Pydantic model</li> <li>Type-safe with full type hinting</li> <li>Observable with event notifications</li> <li>Thread-safe for concurrent access</li> <li>Composable over inheritance</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager--example-usage","title":"Example Usage","text":""},{"location":"api/model_manager/#launchsampler.model_manager--basic-service-usage","title":"Basic Service Usage","text":"<pre><code>from pathlib import Path\nfrom pydantic import BaseModel\nfrom launchsampler.model_manager import ModelManagerService, ModelEvent\n\n# Define your model\nclass AppConfig(BaseModel):\n    debug: bool = False\n    port: int = 8000\n\n# Create service\nconfig = AppConfig()\nservice = ModelManagerService[AppConfig](\n    AppConfig,\n    config,\n    default_path=Path(\"config.json\")\n)\n\n# Use the service\nservice.set(\"debug\", True)\nservice.save()\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager--cli-generation","title":"CLI Generation","text":"<pre><code>from launchsampler.model_manager.cli import ModelCLIBuilder\n\nbuilder = ModelCLIBuilder(AppConfig, Path(\"config.json\"))\nconfig_group = builder.build_group()\ncli.add_command(config_group)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService","title":"<code>ModelManagerService(model_type, initial_model, default_path=None)</code>","text":"<p>               Bases: <code>Generic[ModelType]</code></p> <p>Generic service for managing Pydantic-based models.</p> <p>This service provides a centralized way to manage any Pydantic model (AppConfig, Set, or other models) with get/set operations, persistence, and event notifications.</p> Design Philosophy <ul> <li>Generic: Works with ANY Pydantic BaseModel subclass</li> <li>Type-safe: Full type hinting and validation via Pydantic</li> <li>Observable: Emits events for all model changes</li> <li>Thread-safe: Protected by locks for concurrent access</li> <li>Single responsibility: Only handles model state management</li> </ul> Event-Driven Architecture <p>All model operations emit ModelEvent notifications to registered observers. This ensures automatic synchronization of dependent components without manual coordination.</p> Threading <p>All public methods are thread-safe. The _lock protects model state during reads/writes. The lock is released before notifying observers to prevent deadlocks (same pattern as other services).</p> Usage Example <pre><code># Create service with AppConfig\nconfig = AppConfig.load_or_default()\nservice = ModelManagerService[AppConfig](AppConfig, config)\n\n# Register observers\nservice.register_observer(my_observer)\n\n# Get values\nauto_save = service.get(\"auto_save\")\n\n# Set values\nservice.set(\"auto_save\", False)\n\n# Save to disk\nservice.save()\n</code></pre> <p>Initialize the model manager service.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[ModelType]</code> <p>The Pydantic model class (e.g., AppConfig, Set)</p> required <code>initial_model</code> <code>ModelType</code> <p>The initial model instance</p> required <code>default_path</code> <code>Optional[Path]</code> <p>Default path for save/load operations (optional)</p> <code>None</code> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def __init__(\n    self,\n    model_type: Type[ModelType],\n    initial_model: ModelType,\n    default_path: Optional[Path] = None\n):\n    \"\"\"\n    Initialize the model manager service.\n\n    Args:\n        model_type: The Pydantic model class (e.g., AppConfig, Set)\n        initial_model: The initial model instance\n        default_path: Default path for save/load operations (optional)\n    \"\"\"\n    self._model_type = model_type\n    self._model = initial_model\n    self._default_path = default_path\n    self._lock = Lock()\n\n    # Event system\n    self._observers = ObserverManager[ModelObserver](\n        lock=self._lock,\n        observer_type_name=\"model\"\n    )\n\n    logger.info(f\"ModelManagerService initialized with {model_type.__name__}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive model change events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Object implementing ModelObserver protocol</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def register_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive model change events.\n\n    Args:\n        observer: Object implementing ModelObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def unregister_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.get","title":"<code>get(key, default=None)</code>","text":"<p>Get a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>default</code> <code>Any</code> <p>Default value if key doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The field value, or default if key doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Example <pre><code>auto_save = service.get(\"auto_save\")\nbuffer_size = service.get(\"default_buffer_size\", 512)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a model field value by key.\n\n    Args:\n        key: Model field name\n        default: Default value if key doesn't exist\n\n    Returns:\n        The field value, or default if key doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Example:\n        ```python\n        auto_save = service.get(\"auto_save\")\n        buffer_size = service.get(\"default_buffer_size\", 512)\n        ```\n    \"\"\"\n    with self._lock:\n        return getattr(self._model, key, default)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.get_all","title":"<code>get_all()</code>","text":"<p>Get all model field values as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of all model field names and values</p> Thread-Safety <p>This method is thread-safe. Returns a snapshot of model state.</p> Example <pre><code>all_fields = service.get_all()\nprint(f\"Sets directory: {all_fields['sets_dir']}\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_all(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get all model field values as a dictionary.\n\n    Returns:\n        Dictionary of all model field names and values\n\n    Thread-Safety:\n        This method is thread-safe. Returns a snapshot of model state.\n\n    Example:\n        ```python\n        all_fields = service.get_all()\n        print(f\"Sets directory: {all_fields['sets_dir']}\")\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_dump()\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.get_model","title":"<code>get_model()</code>","text":"<p>Get a copy of the entire model object.</p> <p>Returns:</p> Type Description <code>ModelType</code> <p>Deep copy of the current model</p> Thread-Safety <p>This method is thread-safe. Returns a deep copy to prevent external mutation.</p> Example <pre><code>model_copy = service.get_model()\n# Safe to modify model_copy without affecting service state\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_model(self) -&gt; ModelType:\n    \"\"\"\n    Get a copy of the entire model object.\n\n    Returns:\n        Deep copy of the current model\n\n    Thread-Safety:\n        This method is thread-safe. Returns a deep copy to prevent\n        external mutation.\n\n    Example:\n        ```python\n        model_copy = service.get_model()\n        # Safe to modify model_copy without affecting service state\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_copy(deep=True)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.set","title":"<code>set(key, value)</code>","text":"<p>Set a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>value</code> <code>Any</code> <p>New value (must be valid for the field type)</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If key doesn't exist in model</p> <code>ValidationError</code> <p>If value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Events <p>Emits MODEL_UPDATED with keys=[key], values={key: value}</p> Example <pre><code>service.set(\"auto_save\", False)\nservice.set(\"default_buffer_size\", 1024)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Set a model field value by key.\n\n    Args:\n        key: Model field name\n        value: New value (must be valid for the field type)\n\n    Raises:\n        AttributeError: If key doesn't exist in model\n        ValidationError: If value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Events:\n        Emits MODEL_UPDATED with keys=[key], values={key: value}\n\n    Example:\n        ```python\n        service.set(\"auto_save\", False)\n        service.set(\"default_buffer_size\", 1024)\n        ```\n    \"\"\"\n    with self._lock:\n        if not hasattr(self._model, key):\n            raise AttributeError(\n                f\"'{self._model_type.__name__}' has no field '{key}'\"\n            )\n\n        # Validate by reconstructing the model (Pydantic 2.x doesn't validate on setattr/model_copy)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict[key] = value\n            self._model = self._model_type.model_validate(current_dict)\n            updated_values = {key: value}\n        except ValidationError as e:\n            logger.error(f\"Validation error setting {key}={value}: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=[key],\n        values=updated_values\n    )\n\n    logger.debug(f\"Model updated: {key}={value}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.update","title":"<code>update(values)</code>","text":"<p>Update multiple model field values at once.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>Dictionary of field names and values to update</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any key doesn't exist in model</p> <code>ValidationError</code> <p>If any value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. All updates are atomic.</p> Events <p>Emits single MODEL_UPDATED event with all changed keys/values</p> Example <pre><code>service.update({\n    \"auto_save\": False,\n    \"default_buffer_size\": 1024,\n    \"midi_poll_interval\": 1.0\n})\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def update(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update multiple model field values at once.\n\n    Args:\n        values: Dictionary of field names and values to update\n\n    Raises:\n        AttributeError: If any key doesn't exist in model\n        ValidationError: If any value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. All updates are atomic.\n\n    Events:\n        Emits single MODEL_UPDATED event with all changed keys/values\n\n    Example:\n        ```python\n        service.update({\n            \"auto_save\": False,\n            \"default_buffer_size\": 1024,\n            \"midi_poll_interval\": 1.0\n        })\n        ```\n    \"\"\"\n    with self._lock:\n        # Validate all keys exist first\n        for key in values:\n            if not hasattr(self._model, key):\n                raise AttributeError(\n                    f\"'{self._model_type.__name__}' has no field '{key}'\"\n                )\n\n        # Apply all updates with validation (atomic - all or nothing)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict.update(values)\n            self._model = self._model_type.model_validate(current_dict)\n        except ValidationError as e:\n            logger.error(f\"Validation error during batch update: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=list(values.keys()),\n        values=values\n    )\n\n    logger.debug(f\"Model batch updated: {list(values.keys())}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.reset","title":"<code>reset()</code>","text":"<p>Reset model to default values.</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_RESET with the new default model</p> Example <pre><code>service.reset()\n# All model field values are now back to defaults\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset model to default values.\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_RESET with the new default model\n\n    Example:\n        ```python\n        service.reset()\n        # All model field values are now back to defaults\n        ```\n    \"\"\"\n    with self._lock:\n        # Create new default instance\n        self._model = self._model_type()\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_RESET,\n        model=self._model.model_copy(deep=True)\n    )\n\n    logger.info(f\"Model reset to defaults: {self._model_type.__name__}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.load","title":"<code>load(path=None)</code>","text":"<p>Load model from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_LOADED with the file path</p> Example <pre><code>service.load(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.load()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def load(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Load model from file.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_LOADED with the file path\n\n    Example:\n        ```python\n        service.load(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.load()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    # Load and validate from file using shared utility\n    new_model = PydanticPersistence.load_json(file_path, self._model_type)\n\n    with self._lock:\n        self._model = new_model\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_LOADED,\n        path=file_path\n    )\n\n    logger.info(f\"Model loaded from {file_path}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.save","title":"<code>save(path=None)</code>","text":"<p>Save model to file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to save model to (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> Thread-Safety <p>This method is thread-safe. Model is read under lock.</p> Events <p>Emits MODEL_SAVED with the file path</p> Example <pre><code>service.save(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.save()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Save model to file.\n\n    Args:\n        path: Path to save model to (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n\n    Thread-Safety:\n        This method is thread-safe. Model is read under lock.\n\n    Events:\n        Emits MODEL_SAVED with the file path\n\n    Example:\n        ```python\n        service.save(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.save()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    file_path = Path(file_path)\n\n    # Get model copy while holding lock\n    with self._lock:\n        model_copy = self._model.model_copy(deep=True)\n\n    # Write to file using shared utility (outside lock - I/O can be slow)\n    PydanticPersistence.save_json(model_copy, file_path)\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_SAVED,\n        path=file_path\n    )\n\n    logger.info(f\"Model saved to {file_path}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelManagerService.reload","title":"<code>reload(path=None)</code>","text":"<p>Reload model from file (convenience method).</p> <p>This is equivalent to calling load() but provides clearer intent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Example <pre><code># Reload from disk (discard in-memory changes)\nservice.reload()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reload(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Reload model from file (convenience method).\n\n    This is equivalent to calling load() but provides clearer intent.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Example:\n        ```python\n        # Reload from disk (discard in-memory changes)\n        service.reload()\n        ```\n    \"\"\"\n    self.load(path)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence","title":"<code>PydanticPersistence</code>","text":"<p>Utility class providing shared Pydantic persistence operations.</p> <p>This class provides stateless utility methods for loading and saving Pydantic models to/from JSON files. All methods are static and can be used without instantiation.</p> Example Usage <pre><code># Load a config\nconfig = PydanticPersistence.load_json(\n    path=Path(\"config.json\"),\n    model_type=AppConfig\n)\n\n# Save a config\nPydanticPersistence.save_json(\n    data=config,\n    path=Path(\"config.json\")\n)\n</code></pre> Thread-Safety <p>All methods are thread-safe as they operate on function parameters and do not access shared mutable state.</p>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence.load_json","title":"<code>load_json(path, model_type)</code>  <code>staticmethod</code>","text":"<p>Load and validate a Pydantic model from a JSON file.</p> <p>This method: 1. Reads the JSON file 2. Validates it against the Pydantic model schema 3. Returns a fully validated model instance</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file to load</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class to validate against</p> required <p>Returns:</p> Type Description <code>T</code> <p>Validated model instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ConfigFileInvalidError</code> <p>If the JSON syntax is invalid</p> <code>ConfigValidationError</code> <p>If the JSON content fails Pydantic validation</p> <code>ConfigurationError</code> <p>For other configuration-related errors</p> Example <pre><code>config = PydanticPersistence.load_json(\n    Path(\"~/.config/app.json\"),\n    AppConfig\n)\n</code></pre> Note <p>Uses centralized error handler to convert Pydantic ValidationError to user-friendly exceptions with recovery hints.</p> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef load_json(path: Path, model_type: Type[T]) -&gt; T:\n    \"\"\"\n    Load and validate a Pydantic model from a JSON file.\n\n    This method:\n    1. Reads the JSON file\n    2. Validates it against the Pydantic model schema\n    3. Returns a fully validated model instance\n\n    Args:\n        path: Path to the JSON file to load\n        model_type: The Pydantic model class to validate against\n\n    Returns:\n        Validated model instance\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ConfigFileInvalidError: If the JSON syntax is invalid\n        ConfigValidationError: If the JSON content fails Pydantic validation\n        ConfigurationError: For other configuration-related errors\n\n    Example:\n        ```python\n        config = PydanticPersistence.load_json(\n            Path(\"~/.config/app.json\"),\n            AppConfig\n        )\n        ```\n\n    Note:\n        Uses centralized error handler to convert Pydantic ValidationError\n        to user-friendly exceptions with recovery hints.\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    try:\n        # Read file content\n        json_content = path.read_text()\n\n        if not json_content or not json_content.strip():\n            from launchsampler.exceptions import ConfigFileInvalidError\n            raise ConfigFileInvalidError(str(path), \"File is empty\")\n\n        # Validate and parse with Pydantic\n        model = model_type.model_validate_json(json_content)\n\n        logger.debug(f\"Loaded {model_type.__name__} from {path}\")\n        return model\n\n    except ValidationError as e:\n        # Convert to user-friendly exception using centralized error handler\n        logger.error(f\"Validation error loading {model_type.__name__} from {path}: {e}\")\n        raise wrap_pydantic_error(e, str(path)) from e\n\n    except ConfigurationError:\n        # Re-raise our custom configuration errors\n        raise\n\n    except Exception as e:\n        # Unexpected errors - wrap in ConfigurationError\n        logger.error(f\"Unexpected error loading {model_type.__name__} from {path}: {e}\")\n        from launchsampler.exceptions import ConfigFileInvalidError\n        raise ConfigFileInvalidError(\n            str(path),\n            f\"Unexpected error: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence.save_json","title":"<code>save_json(data, path, indent=2, create_parents=True, backup=True)</code>  <code>staticmethod</code>","text":"<p>Save a Pydantic model to a JSON file with automatic backup and atomic write.</p> <p>This method implements safety features to prevent data loss: 1. Creates .bak backup of existing file before overwriting 2. Uses atomic write (temp file + rename) to prevent corruption 3. Serializes the Pydantic model to JSON 4. Creates parent directories (if requested)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseModel</code> <p>The Pydantic model instance to save</p> required <code>path</code> <code>Path</code> <p>Path where the file should be saved</p> required <code>indent</code> <code>int</code> <p>JSON indentation level (default: 2 spaces)</p> <code>2</code> <code>create_parents</code> <code>bool</code> <p>Create parent directories if they don't exist (default: True)</p> <code>True</code> <code>backup</code> <code>bool</code> <p>Create .bak backup before overwriting existing file (default: True)</p> <code>True</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the file cannot be written (permission denied, disk full, etc.)</p> <code>ConfigurationError</code> <p>If serialization or save fails</p> Example <pre><code>PydanticPersistence.save_json(\n    data=config,\n    path=Path(\"~/.config/app.json\"),\n    indent=2,\n    backup=True  # Creates app.json.bak before overwriting\n)\n</code></pre> Safety Notes <ul> <li>Backup file (.bak) is created before overwriting (if file exists)</li> <li>Atomic write prevents corruption if write is interrupted</li> <li>Parent directories are created by default</li> <li>JSON is pretty-printed with configurable indentation</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef save_json(\n    data: BaseModel,\n    path: Path,\n    indent: int = 2,\n    create_parents: bool = True,\n    backup: bool = True\n) -&gt; None:\n    \"\"\"\n    Save a Pydantic model to a JSON file with automatic backup and atomic write.\n\n    This method implements safety features to prevent data loss:\n    1. Creates .bak backup of existing file before overwriting\n    2. Uses atomic write (temp file + rename) to prevent corruption\n    3. Serializes the Pydantic model to JSON\n    4. Creates parent directories (if requested)\n\n    Args:\n        data: The Pydantic model instance to save\n        path: Path where the file should be saved\n        indent: JSON indentation level (default: 2 spaces)\n        create_parents: Create parent directories if they don't exist (default: True)\n        backup: Create .bak backup before overwriting existing file (default: True)\n\n    Raises:\n        OSError: If the file cannot be written (permission denied, disk full, etc.)\n        ConfigurationError: If serialization or save fails\n\n    Example:\n        ```python\n        PydanticPersistence.save_json(\n            data=config,\n            path=Path(\"~/.config/app.json\"),\n            indent=2,\n            backup=True  # Creates app.json.bak before overwriting\n        )\n        ```\n\n    Safety Notes:\n        - Backup file (.bak) is created before overwriting (if file exists)\n        - Atomic write prevents corruption if write is interrupted\n        - Parent directories are created by default\n        - JSON is pretty-printed with configurable indentation\n    \"\"\"\n    try:\n        # Create parent directories if requested\n        if create_parents and path.parent:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Create backup if file exists and backup is requested\n        if backup and path.exists():\n            backup_path = path.with_suffix(path.suffix + '.bak')\n            shutil.copy2(path, backup_path)\n            logger.debug(f\"Created backup: {backup_path}\")\n\n        # Serialize to JSON\n        json_content = data.model_dump_json(indent=indent)\n\n        # Atomic write: write to temp file first, then rename\n        temp_path = path.with_suffix(path.suffix + '.tmp')\n        try:\n            temp_path.write_text(json_content, encoding='utf-8')\n            # Atomic rename (overwrites destination on most systems)\n            temp_path.replace(path)\n            logger.debug(f\"Saved {type(data).__name__} to {path}\")\n        finally:\n            # Clean up temp file if it still exists (failed rename)\n            if temp_path.exists():\n                temp_path.unlink()\n\n    except OSError as e:\n        # File system errors (permission, disk full, etc.) - re-raise as-is\n        logger.error(f\"OS error saving {type(data).__name__} to {path}: {e}\")\n        raise\n\n    except Exception as e:\n        # Unexpected errors - wrap in ConfigurationError\n        logger.error(f\"Unexpected error saving {type(data).__name__} to {path}: {e}\")\n        raise ConfigurationError(\n            user_message=f\"Failed to save configuration to {path}\",\n            technical_message=f\"Failed to save {type(data).__name__}: {e}\",\n            recovery_hint=\"Check file permissions and disk space. Backup file (.bak) may be available.\"\n        ) from e\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence.load_json_or_default","title":"<code>load_json_or_default(path, model_type, default_factory=None)</code>  <code>staticmethod</code>","text":"<p>Load a model from JSON, or return a default if the file doesn't exist.</p> <p>This is a convenience method that combines load_json with fallback logic. Useful for configuration files that should be auto-created with defaults.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class</p> required <code>default_factory</code> <code>Optional[Callable]</code> <p>Optional callable that returns a default instance.            If None, calls model_type() to get defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Loaded model instance, or default instance if file doesn't exist</p> <p>Raises:</p> Type Description <code>ConfigFileInvalidError</code> <p>If the file exists but has invalid JSON syntax</p> <code>ConfigValidationError</code> <p>If the file exists but has invalid values</p> <code>ConfigurationError</code> <p>For other configuration-related errors</p> Example <pre><code>config = PydanticPersistence.load_json_or_default(\n    path=Path(\"config.json\"),\n    model_type=AppConfig,\n    default_factory=lambda: AppConfig(debug=True)\n)\n</code></pre> Notes <ul> <li>FileNotFoundError is caught and triggers default creation</li> <li>Other errors (ConfigurationError subclasses) are propagated</li> <li>Does not automatically save the default to disk</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef load_json_or_default(\n    path: Path,\n    model_type: Type[T],\n    default_factory: Optional[Callable] = None\n) -&gt; T:\n    \"\"\"\n    Load a model from JSON, or return a default if the file doesn't exist.\n\n    This is a convenience method that combines load_json with fallback logic.\n    Useful for configuration files that should be auto-created with defaults.\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class\n        default_factory: Optional callable that returns a default instance.\n                       If None, calls model_type() to get defaults.\n\n    Returns:\n        Loaded model instance, or default instance if file doesn't exist\n\n    Raises:\n        ConfigFileInvalidError: If the file exists but has invalid JSON syntax\n        ConfigValidationError: If the file exists but has invalid values\n        ConfigurationError: For other configuration-related errors\n\n    Example:\n        ```python\n        config = PydanticPersistence.load_json_or_default(\n            path=Path(\"config.json\"),\n            model_type=AppConfig,\n            default_factory=lambda: AppConfig(debug=True)\n        )\n        ```\n\n    Notes:\n        - FileNotFoundError is caught and triggers default creation\n        - Other errors (ConfigurationError subclasses) are propagated\n        - Does not automatically save the default to disk\n    \"\"\"\n    try:\n        return PydanticPersistence.load_json(path, model_type)\n    except FileNotFoundError:\n        logger.info(f\"File not found: {path}, creating default {model_type.__name__}\")\n        if default_factory:\n            return default_factory()\n        else:\n            return model_type()\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence.validate_json","title":"<code>validate_json(path, model_type)</code>  <code>staticmethod</code>","text":"<p>Validate a JSON file against a Pydantic model without loading it.</p> <p>This is useful for pre-flight checks or validation tools.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class to validate against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple of (is_valid, error_message)</p> <code>Optional[str]</code> <ul> <li>is_valid: True if file is valid, False otherwise</li> </ul> <code>tuple[bool, Optional[str]]</code> <ul> <li>error_message: None if valid, error description if invalid</li> </ul> Example <pre><code>is_valid, error = PydanticPersistence.validate_json(\n    Path(\"config.json\"),\n    AppConfig\n)\nif not is_valid:\n    print(f\"Invalid config: {error}\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef validate_json(path: Path, model_type: Type[T]) -&gt; tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate a JSON file against a Pydantic model without loading it.\n\n    This is useful for pre-flight checks or validation tools.\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class to validate against\n\n    Returns:\n        Tuple of (is_valid, error_message)\n        - is_valid: True if file is valid, False otherwise\n        - error_message: None if valid, error description if invalid\n\n    Example:\n        ```python\n        is_valid, error = PydanticPersistence.validate_json(\n            Path(\"config.json\"),\n            AppConfig\n        )\n        if not is_valid:\n            print(f\"Invalid config: {error}\")\n        ```\n    \"\"\"\n    try:\n        PydanticPersistence.load_json(path, model_type)\n        return True, None\n    except FileNotFoundError:\n        return False, f\"File not found: {path}\"\n    except ConfigurationError as e:\n        # Use user-friendly message from custom exception\n        return False, e.user_message\n    except Exception as e:\n        return False, f\"Error: {e}\"\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PydanticPersistence.ensure_valid_or_create","title":"<code>ensure_valid_or_create(path, model_type, default_factory=None, auto_save=True)</code>  <code>staticmethod</code>","text":"<p>Ensure a valid JSON file exists, creating a default if needed.</p> <p>This method implements safe default handling: 1. Tries to load the file 2. If file doesn't exist: creates default and saves (if auto_save=True) 3. If file is corrupted: creates default but DOES NOT save over corrupted file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class</p> required <code>default_factory</code> <code>Optional[Callable]</code> <p>Optional callable that returns a default instance</p> <code>None</code> <code>auto_save</code> <code>bool</code> <p>Automatically save default to disk if file is missing (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Valid model instance (loaded or newly created)</p> Example <pre><code>config = PydanticPersistence.ensure_valid_or_create(\n    path=Path(\"config.json\"),\n    model_type=AppConfig,\n    auto_save=True\n)\n# config.json exists with valid data (or defaults are used without overwriting)\n</code></pre> Safety Notes <ul> <li>ONLY auto-saves when file is missing (FileNotFoundError)</li> <li>NEVER overwrites corrupted files (ConfigurationError)</li> <li>Corrupted files are preserved for manual recovery</li> <li>Creates .bak backup before any overwrite (when auto_save=True)</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef ensure_valid_or_create(\n    path: Path,\n    model_type: Type[T],\n    default_factory: Optional[Callable] = None,\n    auto_save: bool = True\n) -&gt; T:\n    \"\"\"\n    Ensure a valid JSON file exists, creating a default if needed.\n\n    This method implements safe default handling:\n    1. Tries to load the file\n    2. If file doesn't exist: creates default and saves (if auto_save=True)\n    3. If file is corrupted: creates default but DOES NOT save over corrupted file\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class\n        default_factory: Optional callable that returns a default instance\n        auto_save: Automatically save default to disk if file is missing (default: True)\n\n    Returns:\n        Valid model instance (loaded or newly created)\n\n    Example:\n        ```python\n        config = PydanticPersistence.ensure_valid_or_create(\n            path=Path(\"config.json\"),\n            model_type=AppConfig,\n            auto_save=True\n        )\n        # config.json exists with valid data (or defaults are used without overwriting)\n        ```\n\n    Safety Notes:\n        - ONLY auto-saves when file is missing (FileNotFoundError)\n        - NEVER overwrites corrupted files (ConfigurationError)\n        - Corrupted files are preserved for manual recovery\n        - Creates .bak backup before any overwrite (when auto_save=True)\n    \"\"\"\n    try:\n        return PydanticPersistence.load_json(path, model_type)\n    except FileNotFoundError:\n        # File doesn't exist - safe to create and save default\n        logger.info(f\"File not found: {path}, creating default {model_type.__name__}\")\n\n        # Create default instance\n        if default_factory:\n            instance = default_factory()\n        else:\n            instance = model_type()\n\n        # Auto-save if requested (no backup needed since file doesn't exist)\n        if auto_save:\n            PydanticPersistence.save_json(instance, path, backup=False)\n            logger.info(f\"Saved default {model_type.__name__} to {path}\")\n\n        return instance\n\n    except ConfigurationError as e:\n        # File exists but is corrupted - DO NOT auto-save over it!\n        logger.error(f\"Failed to load {path}: {e.user_message}\")\n        logger.warning(\n            f\"Using default {model_type.__name__} configuration \"\n            f\"(existing file NOT overwritten - manual recovery may be possible)\"\n        )\n\n        # Return default but preserve corrupted file\n        if default_factory:\n            return default_factory()\n        else:\n            return model_type()\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager","title":"<code>ObserverManager(lock=None, observer_type_name='observer')</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic observer list manager with thread-safe registration and notification.</p> <p>This class provides a reusable implementation of the observer pattern, eliminating code duplication across EditorService, Player, LaunchpadController, SamplerStateMachine, and other classes.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>The observer protocol type (e.g., EditObserver, StateObserver)</p> required Thread Safety <p>All operations are thread-safe. The lock is released before calling observer callbacks to prevent potential deadlocks.</p> Example <pre><code>class MyService:\n    def __init__(self):\n        self._observers = ObserverManager[MyObserver]()\n\n    def register_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.register(observer)\n\n    def unregister_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.unregister(observer)\n\n    def _notify_something_happened(self, data):\n        self._observers.notify('on_something_happened', data)\n</code></pre> <p>Initialize the observer manager.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Optional[Lock]</code> <p>Optional threading lock to use. If None, creates a new lock.</p> <code>None</code> <code>observer_type_name</code> <code>str</code> <p>Name of the observer type for logging (e.g., \"edit\", \"state\")</p> <code>'observer'</code> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __init__(self, lock: Optional[Lock] = None, observer_type_name: str = \"observer\"):\n    \"\"\"\n    Initialize the observer manager.\n\n    Args:\n        lock: Optional threading lock to use. If None, creates a new lock.\n        observer_type_name: Name of the observer type for logging (e.g., \"edit\", \"state\")\n    \"\"\"\n    self._observers: list[T] = []\n    self._lock = lock or Lock()\n    self._observer_type_name = observer_type_name\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.register","title":"<code>register(observer)</code>","text":"<p>Register an observer (idempotent - won't add duplicates).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to register</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def register(self, observer: T) -&gt; None:\n    \"\"\"\n    Register an observer (idempotent - won't add duplicates).\n\n    Args:\n        observer: The observer to register\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer not in self._observers:\n            self._observers.append(observer)\n            logger.info(f\"Registered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.debug(f\"{self._observer_type_name} observer already registered: {observer}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.unregister","title":"<code>unregister(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to unregister</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def unregister(self, observer: T) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer in self._observers:\n            self._observers.remove(observer)\n            logger.debug(f\"Unregistered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.warning(f\"Attempted to unregister unknown {self._observer_type_name} observer: {observer}\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.notify","title":"<code>notify(callback_name, *args, **kwargs)</code>","text":"<p>Notify all observers by calling their callback method.</p> <p>The lock is acquired to copy the observer list, then released before calling callbacks. This prevents deadlocks if observers try to register/ unregister during notification.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call (e.g., 'on_edit_event')</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Error Handling <p>Exceptions in observer callbacks are logged but don't affect other observers.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def notify(self, callback_name: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notify all observers by calling their callback method.\n\n    The lock is acquired to copy the observer list, then released before\n    calling callbacks. This prevents deadlocks if observers try to register/\n    unregister during notification.\n\n    Args:\n        callback_name: Name of the callback method to call (e.g., 'on_edit_event')\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Error Handling:\n        Exceptions in observer callbacks are logged but don't affect other observers.\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = list(self._observers)\n\n    # Call observers without holding lock (prevents deadlocks)\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.notify_with_filter","title":"<code>notify_with_filter(callback_name, filter_fn, *args, **kwargs)</code>","text":"<p>Notify only observers that match the filter predicate.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call</p> required <code>filter_fn</code> <code>Callable[[T], bool]</code> <p>Predicate function that returns True for observers to notify</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Example <pre><code># Only notify observers that implement a specific interface\nself._observers.notify_with_filter(\n    'on_custom_event',\n    lambda obs: hasattr(obs, 'supports_custom_events'),\n    event_data\n)\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def notify_with_filter(\n    self,\n    callback_name: str,\n    filter_fn: Callable[[T], bool],\n    *args: Any,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Notify only observers that match the filter predicate.\n\n    Args:\n        callback_name: Name of the callback method to call\n        filter_fn: Predicate function that returns True for observers to notify\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Example:\n        ```python\n        # Only notify observers that implement a specific interface\n        self._observers.notify_with_filter(\n            'on_custom_event',\n            lambda obs: hasattr(obs, 'supports_custom_events'),\n            event_data\n        )\n        ```\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = [obs for obs in self._observers if filter_fn(obs)]\n\n    # Call filtered observers without holding lock\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.count","title":"<code>count()</code>","text":"<p>Get the number of registered observers.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers.\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.has_observers","title":"<code>has_observers()</code>","text":"<p>Check if any observers are registered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def has_observers(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered.\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.clear","title":"<code>clear()</code>","text":"<p>Remove all registered observers.</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Remove all registered observers.\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        count = len(self._observers)\n        self._observers.clear()\n        if count &gt; 0:\n            logger.info(f\"Cleared {count} {self._observer_type_name} observer(s)\")\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.__contains__","title":"<code>__contains__(observer)</code>","text":"<p>Check if an observer is registered (supports 'in' operator).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to check for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if my_observer in observer_manager:\n    print(\"Observer is registered\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __contains__(self, observer: T) -&gt; bool:\n    \"\"\"\n    Check if an observer is registered (supports 'in' operator).\n\n    Args:\n        observer: The observer to check for\n\n    Returns:\n        True if observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if my_observer in observer_manager:\n            print(\"Observer is registered\")\n        ```\n    \"\"\"\n    with self._lock:\n        return observer in self._observers\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of registered observers (supports len() function).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>print(f\"There are {len(observer_manager)} observers\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers (supports len() function).\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        print(f\"There are {len(observer_manager)} observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ObserverManager.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if any observers are registered (supports bool() and if checks).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if observer_manager:\n    print(\"Has observers\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered (supports bool() and if checks).\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if observer_manager:\n            print(\"Has observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelEvent","title":"<code>ModelEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from model changes (configuration, sets, etc.).</p>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelObserver","title":"<code>ModelObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives model change events.</p> <p>This protocol allows loose coupling between model manager services and components that need to react to model changes.</p>"},{"location":"api/model_manager/#launchsampler.model_manager.ModelObserver.on_model_event","title":"<code>on_model_event(event, **kwargs)</code>","text":"<p>Handle model change events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ModelEvent</code> <p>The type of model event</p> required <code>**kwargs</code> <p>Event-specific data: - For MODEL_UPDATED: 'keys' (list of changed keys), 'values' (dict of new values) - For MODEL_LOADED/MODEL_SAVED: 'path' (Path to model file) - For MODEL_RESET: 'model' (the new default model)</p> <code>{}</code> Threading <p>Called from the thread that initiated the model change. Implementations should be thread-safe and avoid blocking operations.</p> Error Handling <p>Exceptions raised by observers are caught and logged by the ModelManagerService. They do not propagate to the caller, ensuring one failing observer doesn't break others.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def on_model_event(self, event: \"ModelEvent\", **kwargs) -&gt; None:\n    \"\"\"\n    Handle model change events.\n\n    Args:\n        event: The type of model event\n        **kwargs: Event-specific data:\n            - For MODEL_UPDATED: 'keys' (list of changed keys), 'values' (dict of new values)\n            - For MODEL_LOADED/MODEL_SAVED: 'path' (Path to model file)\n            - For MODEL_RESET: 'model' (the new default model)\n\n    Threading:\n        Called from the thread that initiated the model change.\n        Implementations should be thread-safe and avoid blocking operations.\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        ModelManagerService. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PersistenceService","title":"<code>PersistenceService</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[T]</code></p> <p>Protocol for services that persist Pydantic models to/from JSON files.</p> <p>This protocol defines a common interface for services that handle loading and saving Pydantic models, ensuring consistency across ConfigService, SetManagerService, and other persistence services.</p> Type Parameter <p>T: The Pydantic BaseModel type this service persists</p> Design Philosophy <ul> <li>Explicit interface for persistence operations</li> <li>Allows both stateful (ConfigService) and stateless (SetManagerService) implementations</li> <li>Does not prescribe internal state management or caching</li> <li>Enables composition over inheritance</li> </ul> Example Implementations <ul> <li>ConfigService: Stateful service with mutable config and observers</li> <li>SetManagerService: Stateless service that operates on Set objects</li> <li>DeviceRegistry: Read-only service that loads once at init</li> </ul>"},{"location":"api/model_manager/#launchsampler.model_manager.PersistenceService.load","title":"<code>load(path)</code>","text":"<p>Load a Pydantic model from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <p>Returns:</p> Type Description <code>T</code> <p>Loaded and validated model instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValidationError</code> <p>If the file content is invalid</p> <code>ValueError</code> <p>If the file format is incorrect</p> Thread-Safety <p>Implementations should document their thread-safety guarantees.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def load(self, path: Path) -&gt; T:\n    \"\"\"\n    Load a Pydantic model from a JSON file.\n\n    Args:\n        path: Path to the JSON file\n\n    Returns:\n        Loaded and validated model instance\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValidationError: If the file content is invalid\n        ValueError: If the file format is incorrect\n\n    Thread-Safety:\n        Implementations should document their thread-safety guarantees.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/#launchsampler.model_manager.PersistenceService.save","title":"<code>save(data, path)</code>","text":"<p>Save a Pydantic model to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The model instance to save</p> required <code>path</code> <code>Path</code> <p>Path where the file should be saved</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> <code>OSError</code> <p>If file cannot be written</p> Notes <ul> <li>Implementations should create parent directories if needed</li> <li>Implementations may perform transformations before saving   (e.g., SetManagerService resolves relative paths)</li> </ul> Thread-Safety <p>Implementations should document their thread-safety guarantees.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def save(self, data: T, path: Path) -&gt; None:\n    \"\"\"\n    Save a Pydantic model to a JSON file.\n\n    Args:\n        data: The model instance to save\n        path: Path where the file should be saved\n\n    Raises:\n        ValueError: If save operation fails\n        OSError: If file cannot be written\n\n    Notes:\n        - Implementations should create parent directories if needed\n        - Implementations may perform transformations before saving\n          (e.g., SetManagerService resolves relative paths)\n\n    Thread-Safety:\n        Implementations should document their thread-safety guarantees.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/observer/","title":"Observer","text":""},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer","title":"<code>observer</code>","text":"<p>Generic observer pattern manager.</p> <p>This module provides a reusable ObserverManager class that handles thread-safe registration, unregistration, and notification of observers. It eliminates the need to duplicate observer management code across multiple classes.</p>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager","title":"<code>ObserverManager(lock=None, observer_type_name='observer')</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Generic observer list manager with thread-safe registration and notification.</p> <p>This class provides a reusable implementation of the observer pattern, eliminating code duplication across EditorService, Player, LaunchpadController, SamplerStateMachine, and other classes.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>T</code> <p>The observer protocol type (e.g., EditObserver, StateObserver)</p> required Thread Safety <p>All operations are thread-safe. The lock is released before calling observer callbacks to prevent potential deadlocks.</p> Example <pre><code>class MyService:\n    def __init__(self):\n        self._observers = ObserverManager[MyObserver]()\n\n    def register_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.register(observer)\n\n    def unregister_observer(self, observer: MyObserver) -&gt; None:\n        self._observers.unregister(observer)\n\n    def _notify_something_happened(self, data):\n        self._observers.notify('on_something_happened', data)\n</code></pre> <p>Initialize the observer manager.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Optional[Lock]</code> <p>Optional threading lock to use. If None, creates a new lock.</p> <code>None</code> <code>observer_type_name</code> <code>str</code> <p>Name of the observer type for logging (e.g., \"edit\", \"state\")</p> <code>'observer'</code> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __init__(self, lock: Optional[Lock] = None, observer_type_name: str = \"observer\"):\n    \"\"\"\n    Initialize the observer manager.\n\n    Args:\n        lock: Optional threading lock to use. If None, creates a new lock.\n        observer_type_name: Name of the observer type for logging (e.g., \"edit\", \"state\")\n    \"\"\"\n    self._observers: list[T] = []\n    self._lock = lock or Lock()\n    self._observer_type_name = observer_type_name\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.register","title":"<code>register(observer)</code>","text":"<p>Register an observer (idempotent - won't add duplicates).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to register</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def register(self, observer: T) -&gt; None:\n    \"\"\"\n    Register an observer (idempotent - won't add duplicates).\n\n    Args:\n        observer: The observer to register\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer not in self._observers:\n            self._observers.append(observer)\n            logger.info(f\"Registered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.debug(f\"{self._observer_type_name} observer already registered: {observer}\")\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.unregister","title":"<code>unregister(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to unregister</p> required Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def unregister(self, observer: T) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        if observer in self._observers:\n            self._observers.remove(observer)\n            logger.debug(f\"Unregistered {self._observer_type_name} observer: {observer}\")\n        else:\n            logger.warning(f\"Attempted to unregister unknown {self._observer_type_name} observer: {observer}\")\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.notify","title":"<code>notify(callback_name, *args, **kwargs)</code>","text":"<p>Notify all observers by calling their callback method.</p> <p>The lock is acquired to copy the observer list, then released before calling callbacks. This prevents deadlocks if observers try to register/ unregister during notification.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call (e.g., 'on_edit_event')</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Error Handling <p>Exceptions in observer callbacks are logged but don't affect other observers.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def notify(self, callback_name: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Notify all observers by calling their callback method.\n\n    The lock is acquired to copy the observer list, then released before\n    calling callbacks. This prevents deadlocks if observers try to register/\n    unregister during notification.\n\n    Args:\n        callback_name: Name of the callback method to call (e.g., 'on_edit_event')\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Error Handling:\n        Exceptions in observer callbacks are logged but don't affect other observers.\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = list(self._observers)\n\n    # Call observers without holding lock (prevents deadlocks)\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.notify_with_filter","title":"<code>notify_with_filter(callback_name, filter_fn, *args, **kwargs)</code>","text":"<p>Notify only observers that match the filter predicate.</p> <p>Parameters:</p> Name Type Description Default <code>callback_name</code> <code>str</code> <p>Name of the callback method to call</p> required <code>filter_fn</code> <code>Callable[[T], bool]</code> <p>Predicate function that returns True for observers to notify</p> required <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the callback</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the callback</p> <code>{}</code> Thread Safety <p>Safe to call from any thread. Lock is released before callbacks.</p> Example <pre><code># Only notify observers that implement a specific interface\nself._observers.notify_with_filter(\n    'on_custom_event',\n    lambda obs: hasattr(obs, 'supports_custom_events'),\n    event_data\n)\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def notify_with_filter(\n    self,\n    callback_name: str,\n    filter_fn: Callable[[T], bool],\n    *args: Any,\n    **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Notify only observers that match the filter predicate.\n\n    Args:\n        callback_name: Name of the callback method to call\n        filter_fn: Predicate function that returns True for observers to notify\n        *args: Positional arguments to pass to the callback\n        **kwargs: Keyword arguments to pass to the callback\n\n    Thread Safety:\n        Safe to call from any thread. Lock is released before callbacks.\n\n    Example:\n        ```python\n        # Only notify observers that implement a specific interface\n        self._observers.notify_with_filter(\n            'on_custom_event',\n            lambda obs: hasattr(obs, 'supports_custom_events'),\n            event_data\n        )\n        ```\n    \"\"\"\n    # Copy observer list while holding lock\n    with self._lock:\n        observers = [obs for obs in self._observers if filter_fn(obs)]\n\n    # Call filtered observers without holding lock\n    for observer in observers:\n        try:\n            callback = getattr(observer, callback_name)\n            callback(*args, **kwargs)\n        except AttributeError:\n            logger.error(\n                f\"{self._observer_type_name} observer {observer} has no method '{callback_name}'\",\n                exc_info=True\n            )\n        except Exception as e:\n            logger.error(\n                f\"Error notifying {self._observer_type_name} observer {observer} via {callback_name}: {e}\",\n                exc_info=True\n            )\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.count","title":"<code>count()</code>","text":"<p>Get the number of registered observers.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers.\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.has_observers","title":"<code>has_observers()</code>","text":"<p>Check if any observers are registered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def has_observers(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered.\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.clear","title":"<code>clear()</code>","text":"<p>Remove all registered observers.</p> Thread Safety <p>Safe to call from any thread.</p> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Remove all registered observers.\n\n    Thread Safety:\n        Safe to call from any thread.\n    \"\"\"\n    with self._lock:\n        count = len(self._observers)\n        self._observers.clear()\n        if count &gt; 0:\n            logger.info(f\"Cleared {count} {self._observer_type_name} observer(s)\")\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.__contains__","title":"<code>__contains__(observer)</code>","text":"<p>Check if an observer is registered (supports 'in' operator).</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>T</code> <p>The observer to check for</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if my_observer in observer_manager:\n    print(\"Observer is registered\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __contains__(self, observer: T) -&gt; bool:\n    \"\"\"\n    Check if an observer is registered (supports 'in' operator).\n\n    Args:\n        observer: The observer to check for\n\n    Returns:\n        True if observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if my_observer in observer_manager:\n            print(\"Observer is registered\")\n        ```\n    \"\"\"\n    with self._lock:\n        return observer in self._observers\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.__len__","title":"<code>__len__()</code>","text":"<p>Get the number of registered observers (supports len() function).</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of observers currently registered</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>print(f\"There are {len(observer_manager)} observers\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Get the number of registered observers (supports len() function).\n\n    Returns:\n        Number of observers currently registered\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        print(f\"There are {len(observer_manager)} observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers)\n</code></pre>"},{"location":"api/model_manager/observer/#launchsampler.model_manager.observer.ObserverManager.__bool__","title":"<code>__bool__()</code>","text":"<p>Check if any observers are registered (supports bool() and if checks).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if at least one observer is registered, False otherwise</p> Thread Safety <p>Safe to call from any thread.</p> Example <pre><code>if observer_manager:\n    print(\"Has observers\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/observer.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"\n    Check if any observers are registered (supports bool() and if checks).\n\n    Returns:\n        True if at least one observer is registered, False otherwise\n\n    Thread Safety:\n        Safe to call from any thread.\n\n    Example:\n        ```python\n        if observer_manager:\n            print(\"Has observers\")\n        ```\n    \"\"\"\n    with self._lock:\n        return len(self._observers) &gt; 0\n</code></pre>"},{"location":"api/model_manager/persistence/","title":"Persistence","text":""},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence","title":"<code>persistence</code>","text":"<p>Shared utilities for Pydantic model persistence.</p> <p>This module provides reusable functions for loading and saving Pydantic models to/from JSON files. These utilities follow DRY principles and eliminate code duplication across ConfigService, SetManagerService, and other persistence services.</p> Design Philosophy <ul> <li>Stateless utility functions (no internal state)</li> <li>Composition over inheritance</li> <li>Centralized error handling with custom exceptions</li> <li>Thread-safe (no shared mutable state)</li> <li>Works with any Pydantic BaseModel subclass</li> </ul> Error Handling <p>Uses the centralized error handler (utils/error_handler.py) to convert low-level Pydantic/IO errors into user-friendly LaunchSamplerError exceptions with recovery hints and consistent messaging.</p> Safety Features <ul> <li>Automatic .bak backups before overwriting files</li> <li>Atomic writes using temp file + rename</li> <li>Never auto-saves over corrupted files</li> <li>Only auto-saves when file is missing (FileNotFoundError)</li> </ul>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence","title":"<code>PydanticPersistence</code>","text":"<p>Utility class providing shared Pydantic persistence operations.</p> <p>This class provides stateless utility methods for loading and saving Pydantic models to/from JSON files. All methods are static and can be used without instantiation.</p> Example Usage <pre><code># Load a config\nconfig = PydanticPersistence.load_json(\n    path=Path(\"config.json\"),\n    model_type=AppConfig\n)\n\n# Save a config\nPydanticPersistence.save_json(\n    data=config,\n    path=Path(\"config.json\")\n)\n</code></pre> Thread-Safety <p>All methods are thread-safe as they operate on function parameters and do not access shared mutable state.</p>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence.load_json","title":"<code>load_json(path, model_type)</code>  <code>staticmethod</code>","text":"<p>Load and validate a Pydantic model from a JSON file.</p> <p>This method: 1. Reads the JSON file 2. Validates it against the Pydantic model schema 3. Returns a fully validated model instance</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file to load</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class to validate against</p> required <p>Returns:</p> Type Description <code>T</code> <p>Validated model instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ConfigFileInvalidError</code> <p>If the JSON syntax is invalid</p> <code>ConfigValidationError</code> <p>If the JSON content fails Pydantic validation</p> <code>ConfigurationError</code> <p>For other configuration-related errors</p> Example <pre><code>config = PydanticPersistence.load_json(\n    Path(\"~/.config/app.json\"),\n    AppConfig\n)\n</code></pre> Note <p>Uses centralized error handler to convert Pydantic ValidationError to user-friendly exceptions with recovery hints.</p> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef load_json(path: Path, model_type: Type[T]) -&gt; T:\n    \"\"\"\n    Load and validate a Pydantic model from a JSON file.\n\n    This method:\n    1. Reads the JSON file\n    2. Validates it against the Pydantic model schema\n    3. Returns a fully validated model instance\n\n    Args:\n        path: Path to the JSON file to load\n        model_type: The Pydantic model class to validate against\n\n    Returns:\n        Validated model instance\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ConfigFileInvalidError: If the JSON syntax is invalid\n        ConfigValidationError: If the JSON content fails Pydantic validation\n        ConfigurationError: For other configuration-related errors\n\n    Example:\n        ```python\n        config = PydanticPersistence.load_json(\n            Path(\"~/.config/app.json\"),\n            AppConfig\n        )\n        ```\n\n    Note:\n        Uses centralized error handler to convert Pydantic ValidationError\n        to user-friendly exceptions with recovery hints.\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"File not found: {path}\")\n\n    try:\n        # Read file content\n        json_content = path.read_text()\n\n        if not json_content or not json_content.strip():\n            from launchsampler.exceptions import ConfigFileInvalidError\n            raise ConfigFileInvalidError(str(path), \"File is empty\")\n\n        # Validate and parse with Pydantic\n        model = model_type.model_validate_json(json_content)\n\n        logger.debug(f\"Loaded {model_type.__name__} from {path}\")\n        return model\n\n    except ValidationError as e:\n        # Convert to user-friendly exception using centralized error handler\n        logger.error(f\"Validation error loading {model_type.__name__} from {path}: {e}\")\n        raise wrap_pydantic_error(e, str(path)) from e\n\n    except ConfigurationError:\n        # Re-raise our custom configuration errors\n        raise\n\n    except Exception as e:\n        # Unexpected errors - wrap in ConfigurationError\n        logger.error(f\"Unexpected error loading {model_type.__name__} from {path}: {e}\")\n        from launchsampler.exceptions import ConfigFileInvalidError\n        raise ConfigFileInvalidError(\n            str(path),\n            f\"Unexpected error: {e}\"\n        ) from e\n</code></pre>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence.save_json","title":"<code>save_json(data, path, indent=2, create_parents=True, backup=True)</code>  <code>staticmethod</code>","text":"<p>Save a Pydantic model to a JSON file with automatic backup and atomic write.</p> <p>This method implements safety features to prevent data loss: 1. Creates .bak backup of existing file before overwriting 2. Uses atomic write (temp file + rename) to prevent corruption 3. Serializes the Pydantic model to JSON 4. Creates parent directories (if requested)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BaseModel</code> <p>The Pydantic model instance to save</p> required <code>path</code> <code>Path</code> <p>Path where the file should be saved</p> required <code>indent</code> <code>int</code> <p>JSON indentation level (default: 2 spaces)</p> <code>2</code> <code>create_parents</code> <code>bool</code> <p>Create parent directories if they don't exist (default: True)</p> <code>True</code> <code>backup</code> <code>bool</code> <p>Create .bak backup before overwriting existing file (default: True)</p> <code>True</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the file cannot be written (permission denied, disk full, etc.)</p> <code>ConfigurationError</code> <p>If serialization or save fails</p> Example <pre><code>PydanticPersistence.save_json(\n    data=config,\n    path=Path(\"~/.config/app.json\"),\n    indent=2,\n    backup=True  # Creates app.json.bak before overwriting\n)\n</code></pre> Safety Notes <ul> <li>Backup file (.bak) is created before overwriting (if file exists)</li> <li>Atomic write prevents corruption if write is interrupted</li> <li>Parent directories are created by default</li> <li>JSON is pretty-printed with configurable indentation</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef save_json(\n    data: BaseModel,\n    path: Path,\n    indent: int = 2,\n    create_parents: bool = True,\n    backup: bool = True\n) -&gt; None:\n    \"\"\"\n    Save a Pydantic model to a JSON file with automatic backup and atomic write.\n\n    This method implements safety features to prevent data loss:\n    1. Creates .bak backup of existing file before overwriting\n    2. Uses atomic write (temp file + rename) to prevent corruption\n    3. Serializes the Pydantic model to JSON\n    4. Creates parent directories (if requested)\n\n    Args:\n        data: The Pydantic model instance to save\n        path: Path where the file should be saved\n        indent: JSON indentation level (default: 2 spaces)\n        create_parents: Create parent directories if they don't exist (default: True)\n        backup: Create .bak backup before overwriting existing file (default: True)\n\n    Raises:\n        OSError: If the file cannot be written (permission denied, disk full, etc.)\n        ConfigurationError: If serialization or save fails\n\n    Example:\n        ```python\n        PydanticPersistence.save_json(\n            data=config,\n            path=Path(\"~/.config/app.json\"),\n            indent=2,\n            backup=True  # Creates app.json.bak before overwriting\n        )\n        ```\n\n    Safety Notes:\n        - Backup file (.bak) is created before overwriting (if file exists)\n        - Atomic write prevents corruption if write is interrupted\n        - Parent directories are created by default\n        - JSON is pretty-printed with configurable indentation\n    \"\"\"\n    try:\n        # Create parent directories if requested\n        if create_parents and path.parent:\n            path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Create backup if file exists and backup is requested\n        if backup and path.exists():\n            backup_path = path.with_suffix(path.suffix + '.bak')\n            shutil.copy2(path, backup_path)\n            logger.debug(f\"Created backup: {backup_path}\")\n\n        # Serialize to JSON\n        json_content = data.model_dump_json(indent=indent)\n\n        # Atomic write: write to temp file first, then rename\n        temp_path = path.with_suffix(path.suffix + '.tmp')\n        try:\n            temp_path.write_text(json_content, encoding='utf-8')\n            # Atomic rename (overwrites destination on most systems)\n            temp_path.replace(path)\n            logger.debug(f\"Saved {type(data).__name__} to {path}\")\n        finally:\n            # Clean up temp file if it still exists (failed rename)\n            if temp_path.exists():\n                temp_path.unlink()\n\n    except OSError as e:\n        # File system errors (permission, disk full, etc.) - re-raise as-is\n        logger.error(f\"OS error saving {type(data).__name__} to {path}: {e}\")\n        raise\n\n    except Exception as e:\n        # Unexpected errors - wrap in ConfigurationError\n        logger.error(f\"Unexpected error saving {type(data).__name__} to {path}: {e}\")\n        raise ConfigurationError(\n            user_message=f\"Failed to save configuration to {path}\",\n            technical_message=f\"Failed to save {type(data).__name__}: {e}\",\n            recovery_hint=\"Check file permissions and disk space. Backup file (.bak) may be available.\"\n        ) from e\n</code></pre>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence.load_json_or_default","title":"<code>load_json_or_default(path, model_type, default_factory=None)</code>  <code>staticmethod</code>","text":"<p>Load a model from JSON, or return a default if the file doesn't exist.</p> <p>This is a convenience method that combines load_json with fallback logic. Useful for configuration files that should be auto-created with defaults.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class</p> required <code>default_factory</code> <code>Optional[Callable]</code> <p>Optional callable that returns a default instance.            If None, calls model_type() to get defaults.</p> <code>None</code> <p>Returns:</p> Type Description <code>T</code> <p>Loaded model instance, or default instance if file doesn't exist</p> <p>Raises:</p> Type Description <code>ConfigFileInvalidError</code> <p>If the file exists but has invalid JSON syntax</p> <code>ConfigValidationError</code> <p>If the file exists but has invalid values</p> <code>ConfigurationError</code> <p>For other configuration-related errors</p> Example <pre><code>config = PydanticPersistence.load_json_or_default(\n    path=Path(\"config.json\"),\n    model_type=AppConfig,\n    default_factory=lambda: AppConfig(debug=True)\n)\n</code></pre> Notes <ul> <li>FileNotFoundError is caught and triggers default creation</li> <li>Other errors (ConfigurationError subclasses) are propagated</li> <li>Does not automatically save the default to disk</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef load_json_or_default(\n    path: Path,\n    model_type: Type[T],\n    default_factory: Optional[Callable] = None\n) -&gt; T:\n    \"\"\"\n    Load a model from JSON, or return a default if the file doesn't exist.\n\n    This is a convenience method that combines load_json with fallback logic.\n    Useful for configuration files that should be auto-created with defaults.\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class\n        default_factory: Optional callable that returns a default instance.\n                       If None, calls model_type() to get defaults.\n\n    Returns:\n        Loaded model instance, or default instance if file doesn't exist\n\n    Raises:\n        ConfigFileInvalidError: If the file exists but has invalid JSON syntax\n        ConfigValidationError: If the file exists but has invalid values\n        ConfigurationError: For other configuration-related errors\n\n    Example:\n        ```python\n        config = PydanticPersistence.load_json_or_default(\n            path=Path(\"config.json\"),\n            model_type=AppConfig,\n            default_factory=lambda: AppConfig(debug=True)\n        )\n        ```\n\n    Notes:\n        - FileNotFoundError is caught and triggers default creation\n        - Other errors (ConfigurationError subclasses) are propagated\n        - Does not automatically save the default to disk\n    \"\"\"\n    try:\n        return PydanticPersistence.load_json(path, model_type)\n    except FileNotFoundError:\n        logger.info(f\"File not found: {path}, creating default {model_type.__name__}\")\n        if default_factory:\n            return default_factory()\n        else:\n            return model_type()\n</code></pre>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence.validate_json","title":"<code>validate_json(path, model_type)</code>  <code>staticmethod</code>","text":"<p>Validate a JSON file against a Pydantic model without loading it.</p> <p>This is useful for pre-flight checks or validation tools.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class to validate against</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple of (is_valid, error_message)</p> <code>Optional[str]</code> <ul> <li>is_valid: True if file is valid, False otherwise</li> </ul> <code>tuple[bool, Optional[str]]</code> <ul> <li>error_message: None if valid, error description if invalid</li> </ul> Example <pre><code>is_valid, error = PydanticPersistence.validate_json(\n    Path(\"config.json\"),\n    AppConfig\n)\nif not is_valid:\n    print(f\"Invalid config: {error}\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef validate_json(path: Path, model_type: Type[T]) -&gt; tuple[bool, Optional[str]]:\n    \"\"\"\n    Validate a JSON file against a Pydantic model without loading it.\n\n    This is useful for pre-flight checks or validation tools.\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class to validate against\n\n    Returns:\n        Tuple of (is_valid, error_message)\n        - is_valid: True if file is valid, False otherwise\n        - error_message: None if valid, error description if invalid\n\n    Example:\n        ```python\n        is_valid, error = PydanticPersistence.validate_json(\n            Path(\"config.json\"),\n            AppConfig\n        )\n        if not is_valid:\n            print(f\"Invalid config: {error}\")\n        ```\n    \"\"\"\n    try:\n        PydanticPersistence.load_json(path, model_type)\n        return True, None\n    except FileNotFoundError:\n        return False, f\"File not found: {path}\"\n    except ConfigurationError as e:\n        # Use user-friendly message from custom exception\n        return False, e.user_message\n    except Exception as e:\n        return False, f\"Error: {e}\"\n</code></pre>"},{"location":"api/model_manager/persistence/#launchsampler.model_manager.persistence.PydanticPersistence.ensure_valid_or_create","title":"<code>ensure_valid_or_create(path, model_type, default_factory=None, auto_save=True)</code>  <code>staticmethod</code>","text":"<p>Ensure a valid JSON file exists, creating a default if needed.</p> <p>This method implements safe default handling: 1. Tries to load the file 2. If file doesn't exist: creates default and saves (if auto_save=True) 3. If file is corrupted: creates default but DOES NOT save over corrupted file</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <code>model_type</code> <code>Type[T]</code> <p>The Pydantic model class</p> required <code>default_factory</code> <code>Optional[Callable]</code> <p>Optional callable that returns a default instance</p> <code>None</code> <code>auto_save</code> <code>bool</code> <p>Automatically save default to disk if file is missing (default: True)</p> <code>True</code> <p>Returns:</p> Type Description <code>T</code> <p>Valid model instance (loaded or newly created)</p> Example <pre><code>config = PydanticPersistence.ensure_valid_or_create(\n    path=Path(\"config.json\"),\n    model_type=AppConfig,\n    auto_save=True\n)\n# config.json exists with valid data (or defaults are used without overwriting)\n</code></pre> Safety Notes <ul> <li>ONLY auto-saves when file is missing (FileNotFoundError)</li> <li>NEVER overwrites corrupted files (ConfigurationError)</li> <li>Corrupted files are preserved for manual recovery</li> <li>Creates .bak backup before any overwrite (when auto_save=True)</li> </ul> Source code in <code>src/launchsampler/model_manager/persistence.py</code> <pre><code>@staticmethod\ndef ensure_valid_or_create(\n    path: Path,\n    model_type: Type[T],\n    default_factory: Optional[Callable] = None,\n    auto_save: bool = True\n) -&gt; T:\n    \"\"\"\n    Ensure a valid JSON file exists, creating a default if needed.\n\n    This method implements safe default handling:\n    1. Tries to load the file\n    2. If file doesn't exist: creates default and saves (if auto_save=True)\n    3. If file is corrupted: creates default but DOES NOT save over corrupted file\n\n    Args:\n        path: Path to the JSON file\n        model_type: The Pydantic model class\n        default_factory: Optional callable that returns a default instance\n        auto_save: Automatically save default to disk if file is missing (default: True)\n\n    Returns:\n        Valid model instance (loaded or newly created)\n\n    Example:\n        ```python\n        config = PydanticPersistence.ensure_valid_or_create(\n            path=Path(\"config.json\"),\n            model_type=AppConfig,\n            auto_save=True\n        )\n        # config.json exists with valid data (or defaults are used without overwriting)\n        ```\n\n    Safety Notes:\n        - ONLY auto-saves when file is missing (FileNotFoundError)\n        - NEVER overwrites corrupted files (ConfigurationError)\n        - Corrupted files are preserved for manual recovery\n        - Creates .bak backup before any overwrite (when auto_save=True)\n    \"\"\"\n    try:\n        return PydanticPersistence.load_json(path, model_type)\n    except FileNotFoundError:\n        # File doesn't exist - safe to create and save default\n        logger.info(f\"File not found: {path}, creating default {model_type.__name__}\")\n\n        # Create default instance\n        if default_factory:\n            instance = default_factory()\n        else:\n            instance = model_type()\n\n        # Auto-save if requested (no backup needed since file doesn't exist)\n        if auto_save:\n            PydanticPersistence.save_json(instance, path, backup=False)\n            logger.info(f\"Saved default {model_type.__name__} to {path}\")\n\n        return instance\n\n    except ConfigurationError as e:\n        # File exists but is corrupted - DO NOT auto-save over it!\n        logger.error(f\"Failed to load {path}: {e.user_message}\")\n        logger.warning(\n            f\"Using default {model_type.__name__} configuration \"\n            f\"(existing file NOT overwritten - manual recovery may be possible)\"\n        )\n\n        # Return default but preserve corrupted file\n        if default_factory:\n            return default_factory()\n        else:\n            return model_type()\n</code></pre>"},{"location":"api/model_manager/protocols/","title":"Protocols","text":""},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols","title":"<code>protocols</code>","text":"<p>Protocol definitions for model management framework.</p> <p>This module defines the core protocols and events for the model management system: - ModelEvent: Events from model lifecycle (load, save, update, reset) - ModelObserver: Observer protocol for model change notifications - PersistenceService: Protocol for persistence service implementations</p>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.ModelEvent","title":"<code>ModelEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from model changes (configuration, sets, etc.).</p>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.ModelObserver","title":"<code>ModelObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives model change events.</p> <p>This protocol allows loose coupling between model manager services and components that need to react to model changes.</p>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.ModelObserver.on_model_event","title":"<code>on_model_event(event, **kwargs)</code>","text":"<p>Handle model change events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>ModelEvent</code> <p>The type of model event</p> required <code>**kwargs</code> <p>Event-specific data: - For MODEL_UPDATED: 'keys' (list of changed keys), 'values' (dict of new values) - For MODEL_LOADED/MODEL_SAVED: 'path' (Path to model file) - For MODEL_RESET: 'model' (the new default model)</p> <code>{}</code> Threading <p>Called from the thread that initiated the model change. Implementations should be thread-safe and avoid blocking operations.</p> Error Handling <p>Exceptions raised by observers are caught and logged by the ModelManagerService. They do not propagate to the caller, ensuring one failing observer doesn't break others.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def on_model_event(self, event: \"ModelEvent\", **kwargs) -&gt; None:\n    \"\"\"\n    Handle model change events.\n\n    Args:\n        event: The type of model event\n        **kwargs: Event-specific data:\n            - For MODEL_UPDATED: 'keys' (list of changed keys), 'values' (dict of new values)\n            - For MODEL_LOADED/MODEL_SAVED: 'path' (Path to model file)\n            - For MODEL_RESET: 'model' (the new default model)\n\n    Threading:\n        Called from the thread that initiated the model change.\n        Implementations should be thread-safe and avoid blocking operations.\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        ModelManagerService. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.PersistenceService","title":"<code>PersistenceService</code>","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[T]</code></p> <p>Protocol for services that persist Pydantic models to/from JSON files.</p> <p>This protocol defines a common interface for services that handle loading and saving Pydantic models, ensuring consistency across ConfigService, SetManagerService, and other persistence services.</p> Type Parameter <p>T: The Pydantic BaseModel type this service persists</p> Design Philosophy <ul> <li>Explicit interface for persistence operations</li> <li>Allows both stateful (ConfigService) and stateless (SetManagerService) implementations</li> <li>Does not prescribe internal state management or caching</li> <li>Enables composition over inheritance</li> </ul> Example Implementations <ul> <li>ConfigService: Stateful service with mutable config and observers</li> <li>SetManagerService: Stateless service that operates on Set objects</li> <li>DeviceRegistry: Read-only service that loads once at init</li> </ul>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.PersistenceService.load","title":"<code>load(path)</code>","text":"<p>Load a Pydantic model from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file</p> required <p>Returns:</p> Type Description <code>T</code> <p>Loaded and validated model instance</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValidationError</code> <p>If the file content is invalid</p> <code>ValueError</code> <p>If the file format is incorrect</p> Thread-Safety <p>Implementations should document their thread-safety guarantees.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def load(self, path: Path) -&gt; T:\n    \"\"\"\n    Load a Pydantic model from a JSON file.\n\n    Args:\n        path: Path to the JSON file\n\n    Returns:\n        Loaded and validated model instance\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValidationError: If the file content is invalid\n        ValueError: If the file format is incorrect\n\n    Thread-Safety:\n        Implementations should document their thread-safety guarantees.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/protocols/#launchsampler.model_manager.protocols.PersistenceService.save","title":"<code>save(data, path)</code>","text":"<p>Save a Pydantic model to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>T</code> <p>The model instance to save</p> required <code>path</code> <code>Path</code> <p>Path where the file should be saved</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> <code>OSError</code> <p>If file cannot be written</p> Notes <ul> <li>Implementations should create parent directories if needed</li> <li>Implementations may perform transformations before saving   (e.g., SetManagerService resolves relative paths)</li> </ul> Thread-Safety <p>Implementations should document their thread-safety guarantees.</p> Source code in <code>src/launchsampler/model_manager/protocols.py</code> <pre><code>def save(self, data: T, path: Path) -&gt; None:\n    \"\"\"\n    Save a Pydantic model to a JSON file.\n\n    Args:\n        data: The model instance to save\n        path: Path where the file should be saved\n\n    Raises:\n        ValueError: If save operation fails\n        OSError: If file cannot be written\n\n    Notes:\n        - Implementations should create parent directories if needed\n        - Implementations may perform transformations before saving\n          (e.g., SetManagerService resolves relative paths)\n\n    Thread-Safety:\n        Implementations should document their thread-safety guarantees.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/model_manager/service/","title":"Service","text":""},{"location":"api/model_manager/service/#launchsampler.model_manager.service","title":"<code>service</code>","text":"<p>Model manager service for managing Pydantic models (config, sets, etc.).</p>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService","title":"<code>ModelManagerService(model_type, initial_model, default_path=None)</code>","text":"<p>               Bases: <code>Generic[ModelType]</code></p> <p>Generic service for managing Pydantic-based models.</p> <p>This service provides a centralized way to manage any Pydantic model (AppConfig, Set, or other models) with get/set operations, persistence, and event notifications.</p> Design Philosophy <ul> <li>Generic: Works with ANY Pydantic BaseModel subclass</li> <li>Type-safe: Full type hinting and validation via Pydantic</li> <li>Observable: Emits events for all model changes</li> <li>Thread-safe: Protected by locks for concurrent access</li> <li>Single responsibility: Only handles model state management</li> </ul> Event-Driven Architecture <p>All model operations emit ModelEvent notifications to registered observers. This ensures automatic synchronization of dependent components without manual coordination.</p> Threading <p>All public methods are thread-safe. The _lock protects model state during reads/writes. The lock is released before notifying observers to prevent deadlocks (same pattern as other services).</p> Usage Example <pre><code># Create service with AppConfig\nconfig = AppConfig.load_or_default()\nservice = ModelManagerService[AppConfig](AppConfig, config)\n\n# Register observers\nservice.register_observer(my_observer)\n\n# Get values\nauto_save = service.get(\"auto_save\")\n\n# Set values\nservice.set(\"auto_save\", False)\n\n# Save to disk\nservice.save()\n</code></pre> <p>Initialize the model manager service.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[ModelType]</code> <p>The Pydantic model class (e.g., AppConfig, Set)</p> required <code>initial_model</code> <code>ModelType</code> <p>The initial model instance</p> required <code>default_path</code> <code>Optional[Path]</code> <p>Default path for save/load operations (optional)</p> <code>None</code> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def __init__(\n    self,\n    model_type: Type[ModelType],\n    initial_model: ModelType,\n    default_path: Optional[Path] = None\n):\n    \"\"\"\n    Initialize the model manager service.\n\n    Args:\n        model_type: The Pydantic model class (e.g., AppConfig, Set)\n        initial_model: The initial model instance\n        default_path: Default path for save/load operations (optional)\n    \"\"\"\n    self._model_type = model_type\n    self._model = initial_model\n    self._default_path = default_path\n    self._lock = Lock()\n\n    # Event system\n    self._observers = ObserverManager[ModelObserver](\n        lock=self._lock,\n        observer_type_name=\"model\"\n    )\n\n    logger.info(f\"ModelManagerService initialized with {model_type.__name__}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive model change events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Object implementing ModelObserver protocol</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def register_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive model change events.\n\n    Args:\n        observer: Object implementing ModelObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def unregister_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.get","title":"<code>get(key, default=None)</code>","text":"<p>Get a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>default</code> <code>Any</code> <p>Default value if key doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The field value, or default if key doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Example <pre><code>auto_save = service.get(\"auto_save\")\nbuffer_size = service.get(\"default_buffer_size\", 512)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a model field value by key.\n\n    Args:\n        key: Model field name\n        default: Default value if key doesn't exist\n\n    Returns:\n        The field value, or default if key doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Example:\n        ```python\n        auto_save = service.get(\"auto_save\")\n        buffer_size = service.get(\"default_buffer_size\", 512)\n        ```\n    \"\"\"\n    with self._lock:\n        return getattr(self._model, key, default)\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.get_all","title":"<code>get_all()</code>","text":"<p>Get all model field values as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of all model field names and values</p> Thread-Safety <p>This method is thread-safe. Returns a snapshot of model state.</p> Example <pre><code>all_fields = service.get_all()\nprint(f\"Sets directory: {all_fields['sets_dir']}\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_all(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get all model field values as a dictionary.\n\n    Returns:\n        Dictionary of all model field names and values\n\n    Thread-Safety:\n        This method is thread-safe. Returns a snapshot of model state.\n\n    Example:\n        ```python\n        all_fields = service.get_all()\n        print(f\"Sets directory: {all_fields['sets_dir']}\")\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_dump()\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.get_model","title":"<code>get_model()</code>","text":"<p>Get a copy of the entire model object.</p> <p>Returns:</p> Type Description <code>ModelType</code> <p>Deep copy of the current model</p> Thread-Safety <p>This method is thread-safe. Returns a deep copy to prevent external mutation.</p> Example <pre><code>model_copy = service.get_model()\n# Safe to modify model_copy without affecting service state\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_model(self) -&gt; ModelType:\n    \"\"\"\n    Get a copy of the entire model object.\n\n    Returns:\n        Deep copy of the current model\n\n    Thread-Safety:\n        This method is thread-safe. Returns a deep copy to prevent\n        external mutation.\n\n    Example:\n        ```python\n        model_copy = service.get_model()\n        # Safe to modify model_copy without affecting service state\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_copy(deep=True)\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.set","title":"<code>set(key, value)</code>","text":"<p>Set a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>value</code> <code>Any</code> <p>New value (must be valid for the field type)</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If key doesn't exist in model</p> <code>ValidationError</code> <p>If value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Events <p>Emits MODEL_UPDATED with keys=[key], values={key: value}</p> Example <pre><code>service.set(\"auto_save\", False)\nservice.set(\"default_buffer_size\", 1024)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Set a model field value by key.\n\n    Args:\n        key: Model field name\n        value: New value (must be valid for the field type)\n\n    Raises:\n        AttributeError: If key doesn't exist in model\n        ValidationError: If value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Events:\n        Emits MODEL_UPDATED with keys=[key], values={key: value}\n\n    Example:\n        ```python\n        service.set(\"auto_save\", False)\n        service.set(\"default_buffer_size\", 1024)\n        ```\n    \"\"\"\n    with self._lock:\n        if not hasattr(self._model, key):\n            raise AttributeError(\n                f\"'{self._model_type.__name__}' has no field '{key}'\"\n            )\n\n        # Validate by reconstructing the model (Pydantic 2.x doesn't validate on setattr/model_copy)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict[key] = value\n            self._model = self._model_type.model_validate(current_dict)\n            updated_values = {key: value}\n        except ValidationError as e:\n            logger.error(f\"Validation error setting {key}={value}: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=[key],\n        values=updated_values\n    )\n\n    logger.debug(f\"Model updated: {key}={value}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.update","title":"<code>update(values)</code>","text":"<p>Update multiple model field values at once.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>Dictionary of field names and values to update</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any key doesn't exist in model</p> <code>ValidationError</code> <p>If any value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. All updates are atomic.</p> Events <p>Emits single MODEL_UPDATED event with all changed keys/values</p> Example <pre><code>service.update({\n    \"auto_save\": False,\n    \"default_buffer_size\": 1024,\n    \"midi_poll_interval\": 1.0\n})\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def update(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update multiple model field values at once.\n\n    Args:\n        values: Dictionary of field names and values to update\n\n    Raises:\n        AttributeError: If any key doesn't exist in model\n        ValidationError: If any value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. All updates are atomic.\n\n    Events:\n        Emits single MODEL_UPDATED event with all changed keys/values\n\n    Example:\n        ```python\n        service.update({\n            \"auto_save\": False,\n            \"default_buffer_size\": 1024,\n            \"midi_poll_interval\": 1.0\n        })\n        ```\n    \"\"\"\n    with self._lock:\n        # Validate all keys exist first\n        for key in values:\n            if not hasattr(self._model, key):\n                raise AttributeError(\n                    f\"'{self._model_type.__name__}' has no field '{key}'\"\n                )\n\n        # Apply all updates with validation (atomic - all or nothing)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict.update(values)\n            self._model = self._model_type.model_validate(current_dict)\n        except ValidationError as e:\n            logger.error(f\"Validation error during batch update: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=list(values.keys()),\n        values=values\n    )\n\n    logger.debug(f\"Model batch updated: {list(values.keys())}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.reset","title":"<code>reset()</code>","text":"<p>Reset model to default values.</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_RESET with the new default model</p> Example <pre><code>service.reset()\n# All model field values are now back to defaults\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset model to default values.\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_RESET with the new default model\n\n    Example:\n        ```python\n        service.reset()\n        # All model field values are now back to defaults\n        ```\n    \"\"\"\n    with self._lock:\n        # Create new default instance\n        self._model = self._model_type()\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_RESET,\n        model=self._model.model_copy(deep=True)\n    )\n\n    logger.info(f\"Model reset to defaults: {self._model_type.__name__}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.load","title":"<code>load(path=None)</code>","text":"<p>Load model from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_LOADED with the file path</p> Example <pre><code>service.load(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.load()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def load(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Load model from file.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_LOADED with the file path\n\n    Example:\n        ```python\n        service.load(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.load()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    # Load and validate from file using shared utility\n    new_model = PydanticPersistence.load_json(file_path, self._model_type)\n\n    with self._lock:\n        self._model = new_model\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_LOADED,\n        path=file_path\n    )\n\n    logger.info(f\"Model loaded from {file_path}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.save","title":"<code>save(path=None)</code>","text":"<p>Save model to file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to save model to (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> Thread-Safety <p>This method is thread-safe. Model is read under lock.</p> Events <p>Emits MODEL_SAVED with the file path</p> Example <pre><code>service.save(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.save()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Save model to file.\n\n    Args:\n        path: Path to save model to (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n\n    Thread-Safety:\n        This method is thread-safe. Model is read under lock.\n\n    Events:\n        Emits MODEL_SAVED with the file path\n\n    Example:\n        ```python\n        service.save(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.save()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    file_path = Path(file_path)\n\n    # Get model copy while holding lock\n    with self._lock:\n        model_copy = self._model.model_copy(deep=True)\n\n    # Write to file using shared utility (outside lock - I/O can be slow)\n    PydanticPersistence.save_json(model_copy, file_path)\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_SAVED,\n        path=file_path\n    )\n\n    logger.info(f\"Model saved to {file_path}\")\n</code></pre>"},{"location":"api/model_manager/service/#launchsampler.model_manager.service.ModelManagerService.reload","title":"<code>reload(path=None)</code>","text":"<p>Reload model from file (convenience method).</p> <p>This is equivalent to calling load() but provides clearer intent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Example <pre><code># Reload from disk (discard in-memory changes)\nservice.reload()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reload(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Reload model from file (convenience method).\n\n    This is equivalent to calling load() but provides clearer intent.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Example:\n        ```python\n        # Reload from disk (discard in-memory changes)\n        service.reload()\n        ```\n    \"\"\"\n    self.load(path)\n</code></pre>"},{"location":"api/model_manager/cli/builder/","title":"Builder","text":""},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder","title":"<code>builder</code>","text":"<p>Generic CLI builder for Pydantic models with ModelManagerService.</p> <p>This module provides a reusable framework for auto-generating CLI commands from any Pydantic model. It maps Pydantic field types to Click types, generates help text from field descriptions, and integrates with ModelManagerService for type-safe configuration management.</p> Design Philosophy <ul> <li>Model as source of truth: Types, defaults, descriptions from Pydantic</li> <li>Generic and reusable: Works with any Pydantic BaseModel</li> <li>Customizable: Field-level overrides and validation hooks</li> <li>Auto-updating: Add field to model \u2192 CLI updates automatically</li> </ul> Example Usage <pre><code>from launchsampler.models import AppConfig\nfrom launchsampler.cli.model_cli_builder import ModelCLIBuilder\n\n# Create builder for AppConfig\nbuilder = ModelCLIBuilder(\n    AppConfig,\n    config_path=Path.home() / \".launchsampler\" / \"config.json\",\n    field_overrides={\n        \"default_audio_device\": {\n            \"short\": \"a\",\n            \"help\": \"Audio device ID (use 'launchsampler audio list')\"\n        }\n    }\n)\n\n# Build commands\nconfig = click.Group(name='config')\nconfig.add_command(builder.build_show_command())\nconfig.add_command(builder.build_set_command())\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.TypeMapper","title":"<code>TypeMapper</code>","text":"<p>Maps Pydantic field types to Click parameter types.</p>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.TypeMapper.to_click_type","title":"<code>to_click_type(python_type)</code>  <code>classmethod</code>","text":"<p>Convert a Python type annotation to a Click parameter type.</p> <p>Handles Optional[T], Union types, and basic Python types.</p> <p>Parameters:</p> Name Type Description Default <code>python_type</code> <code>Type</code> <p>Python type annotation from Pydantic field</p> required <p>Returns:</p> Type Description <code>ParamType</code> <p>Corresponding Click parameter type</p> Example <pre><code># Optional[int] \u2192 click.INT\n# str \u2192 click.STRING\n# Path \u2192 click.Path(path_type=Path)\n</code></pre> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>@classmethod\ndef to_click_type(cls, python_type: Type) -&gt; click.ParamType:\n    \"\"\"\n    Convert a Python type annotation to a Click parameter type.\n\n    Handles Optional[T], Union types, and basic Python types.\n\n    Args:\n        python_type: Python type annotation from Pydantic field\n\n    Returns:\n        Corresponding Click parameter type\n\n    Example:\n        ```python\n        # Optional[int] \u2192 click.INT\n        # str \u2192 click.STRING\n        # Path \u2192 click.Path(path_type=Path)\n        ```\n    \"\"\"\n    # Handle Optional[T] (which is Union[T, None])\n    origin = get_origin(python_type)\n    if origin is Union:\n        args = get_args(python_type)\n        # Filter out NoneType to get the actual type\n        non_none_types = [t for t in args if t is not type(None)]\n        if non_none_types:\n            python_type = non_none_types[0]\n\n    # Look up in mappings\n    click_type = cls.MAPPINGS.get(python_type)\n    if click_type:\n        return click_type\n\n    # Default to STRING for unknown types\n    logger.warning(f\"Unknown type {python_type}, defaulting to click.STRING\")\n    return click.STRING\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ValidatorRegistry","title":"<code>ValidatorRegistry</code>","text":"<p>Registry for custom field validators.</p> <p>Validators can provide custom validation logic beyond Pydantic's built-in validation. They return (is_valid, message) tuples where the message is shown to the user.</p> Example <pre><code>@ValidatorRegistry.register(\"default_audio_device\")\ndef validate_audio_device(value: int) -&gt; tuple[bool, Optional[str]]:\n    try:\n        device = AudioDevice.get(value)\n        return True, f\"Using device: {device.name}\"\n    except ValueError:\n        return False, \"Device not found. Run 'launchsampler audio list'\"\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ValidatorRegistry.register","title":"<code>register(field_name)</code>  <code>classmethod</code>","text":"<p>Decorator to register a validator for a field.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the model field to validate</p> required <p>Returns:</p> Type Description <p>Decorator function</p> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>@classmethod\ndef register(cls, field_name: str):\n    \"\"\"\n    Decorator to register a validator for a field.\n\n    Args:\n        field_name: Name of the model field to validate\n\n    Returns:\n        Decorator function\n    \"\"\"\n    def decorator(func: Callable[[Any], tuple[bool, Optional[str]]]):\n        cls._validators[field_name] = func\n        return func\n    return decorator\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ValidatorRegistry.validate","title":"<code>validate(field_name, value)</code>  <code>classmethod</code>","text":"<p>Run validation for a field if a validator is registered.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>Name of the field</p> required <code>value</code> <code>Any</code> <p>Value to validate</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple of (is_valid, message)</p> <code>Optional[str]</code> <ul> <li>is_valid: True if validation passed</li> </ul> <code>tuple[bool, Optional[str]]</code> <ul> <li>message: User-friendly message (error if invalid, info if valid)</li> </ul> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>@classmethod\ndef validate(cls, field_name: str, value: Any) -&gt; tuple[bool, Optional[str]]:\n    \"\"\"\n    Run validation for a field if a validator is registered.\n\n    Args:\n        field_name: Name of the field\n        value: Value to validate\n\n    Returns:\n        Tuple of (is_valid, message)\n        - is_valid: True if validation passed\n        - message: User-friendly message (error if invalid, info if valid)\n    \"\"\"\n    validator = cls._validators.get(field_name)\n    if validator:\n        return validator(value)\n    # No validator registered, accept value\n    return True, None\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ModelCLIBuilder","title":"<code>ModelCLIBuilder(model_type, config_path, field_overrides=None, expose_all=True)</code>","text":"<p>               Bases: <code>Generic[ModelType]</code></p> <p>Generic CLI builder for Pydantic models.</p> <p>This class auto-generates Click commands from a Pydantic model, integrating with ModelManagerService for persistence and validation.</p> Features <ul> <li>Auto-generated options from model fields</li> <li>Type mapping: Pydantic types \u2192 Click types</li> <li>Help text from field descriptions</li> <li>Custom validators via ValidatorRegistry</li> <li>Field-level overrides for customization</li> </ul> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>ModelType</code> <p>The Pydantic BaseModel subclass</p> required Example <pre><code>builder = ModelCLIBuilder(\n    AppConfig,\n    config_path=Path.home() / \".launchsampler\" / \"config.json\",\n    field_overrides={\n        \"buffer_size\": {\"short\": \"b\"}\n    }\n)\n\n# Generate commands\nshow_cmd = builder.build_show_command()\nset_cmd = builder.build_set_command()\n</code></pre> <p>Initialize the CLI builder.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[ModelType]</code> <p>Pydantic model class to build CLI for</p> required <code>config_path</code> <code>Path</code> <p>Default path for model persistence</p> required <code>field_overrides</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Per-field customization options - short: Short flag (e.g., \"a\" for -a) - help: Custom help text - expose: Whether to expose field in CLI (default: True) - type: Custom Click type override</p> <code>None</code> <code>expose_all</code> <code>bool</code> <p>Expose all fields by default (default: True)</p> <code>True</code> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>def __init__(\n    self,\n    model_type: Type[ModelType],\n    config_path: Path,\n    field_overrides: Optional[Dict[str, Dict[str, Any]]] = None,\n    expose_all: bool = True\n):\n    \"\"\"\n    Initialize the CLI builder.\n\n    Args:\n        model_type: Pydantic model class to build CLI for\n        config_path: Default path for model persistence\n        field_overrides: Per-field customization options\n            - short: Short flag (e.g., \"a\" for -a)\n            - help: Custom help text\n            - expose: Whether to expose field in CLI (default: True)\n            - type: Custom Click type override\n        expose_all: Expose all fields by default (default: True)\n    \"\"\"\n    self.model_type = model_type\n    self.config_path = config_path\n    self.field_overrides = field_overrides or {}\n    self.expose_all = expose_all\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ModelCLIBuilder.build_set_command","title":"<code>build_set_command()</code>","text":"<p>Build a 'set' command that updates field values.</p> <p>Returns:</p> Type Description <code>Command</code> <p>Click Command for setting fields</p> Command <pre><code>config set --field-name value [--other-field value ...]\n</code></pre> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>def build_set_command(self) -&gt; click.Command:\n    \"\"\"\n    Build a 'set' command that updates field values.\n\n    Returns:\n        Click Command for setting fields\n\n    Command:\n        ```\n        config set --field-name value [--other-field value ...]\n        ```\n    \"\"\"\n    # Dynamically create options from model fields\n    def make_set_command():\n        @click.command(name='set')\n        def set_cmd(**kwargs):\n            \"\"\"Set one or more model field values.\"\"\"\n            # Filter out None values (fields not provided)\n            updates = {k: v for k, v in kwargs.items() if v is not None}\n\n            if not updates:\n                click.echo(\"Error: No fields specified. Use --help to see available options.\", err=True)\n                return\n\n            try:\n                # Load current model\n                model = self.model_type.load_or_default(self.config_path)\n\n                # Create service\n                service = ModelManagerService[self.model_type](\n                    self.model_type,\n                    model,\n                    default_path=self.config_path\n                )\n\n                # Apply updates with validation\n                for field_name, value in updates.items():\n                    # Run custom validator if registered\n                    is_valid, message = ValidatorRegistry.validate(field_name, value)\n\n                    if not is_valid:\n                        click.echo(f\"Error validating {field_name}: {message}\", err=True)\n                        return\n\n                    # Set value\n                    service.set(field_name, value)\n\n                    # Show validation message if provided\n                    if message:\n                        click.echo(f\"[OK] {field_name}: {message}\")\n                    else:\n                        click.echo(f\"[OK] {field_name} = {value}\")\n\n                # Save\n                service.save()\n                click.echo(f\"\\nConfiguration saved to {self.config_path}\")\n\n            except ConfigurationError as e:\n                click.echo(f\"Error: {e.user_message}\", err=True)\n                if e.recovery_hint:\n                    click.echo(f\"Hint: {e.recovery_hint}\", err=True)\n            except Exception as e:\n                click.echo(f\"Error: {e}\", err=True)\n\n        # Add options dynamically\n        for field_name, field_info in self.model_type.model_fields.items():\n            if self._should_expose(field_name):\n                option = self._field_to_option(field_name, field_info)\n                set_cmd.params.append(option)\n\n        return set_cmd\n\n    return make_set_command()\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ModelCLIBuilder.build_validate_command","title":"<code>build_validate_command()</code>","text":"<p>Build a 'validate' command that checks configuration validity.</p> <p>Returns:</p> Type Description <code>Command</code> <p>Click Command for validating configuration</p> Command <pre><code>config validate                        # Validate all fields\nconfig validate field1 field2          # Validate specific fields\n</code></pre> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>def build_validate_command(self) -&gt; click.Command:\n    \"\"\"\n    Build a 'validate' command that checks configuration validity.\n\n    Returns:\n        Click Command for validating configuration\n\n    Command:\n        ```\n        config validate                        # Validate all fields\n        config validate field1 field2          # Validate specific fields\n        ```\n    \"\"\"\n    @click.command(name='validate')\n    @click.argument('fields', nargs=-1, type=str)\n    def validate(fields: tuple[str, ...]):\n        \"\"\"Validate the model configuration file.\n\n        FIELDS: Optional field names to validate (validates all if not specified)\n        \"\"\"\n        # Use ASCII-safe symbols that work across platforms\n        CHECK = \"[OK]\"\n        CROSS = \"[FAIL]\"\n\n        try:\n            # Try to load - this will validate\n            model = self.model_type.load_or_default(self.config_path)\n\n            if fields:\n                # Validate specific fields\n                click.echo(\"\")\n                has_errors = False\n\n                for field in fields:\n                    if not hasattr(model, field):\n                        click.echo(f\"{CROSS} Field '{field}' does not exist\", err=True)\n                        has_errors = True\n                        continue\n\n                    value = getattr(model, field)\n                    field_info = model.model_fields.get(field)\n                    field_type = field_info.annotation if field_info else \"unknown\"\n\n                    # Format the type name nicely\n                    if hasattr(field_type, '__name__'):\n                        type_name = field_type.__name__\n                    else:\n                        type_name = str(field_type).replace('typing.', '')\n\n                    click.echo(f\"{CHECK} {field:28s} {type_name:15s} = {value}\")\n\n                    if field_info and field_info.description:\n                        click.echo(f\"    {field_info.description}\")\n\n                click.echo(\"\")\n\n                if has_errors:\n                    return 1\n            else:\n                # Validate all fields\n                model_dict = model.model_dump()\n                exposed_fields = [k for k in model_dict.keys() if self._should_expose(k)]\n\n                click.echo(f\"\\n{CHECK} Configuration is valid\")\n                click.echo(f\"  File: {self.config_path}\")\n                click.echo(f\"  Model: {self.model_type.__name__}\")\n                click.echo(f\"  Total fields: {len(model.model_fields)}\")\n                click.echo(f\"  Exposed fields: {len(exposed_fields)}\")\n                click.echo(\"\")\n                click.echo(\"Field Summary:\")\n                click.echo(\"=\" * 70)\n                for key in exposed_fields:\n                    value = model_dict[key]\n                    field_info = model.model_fields.get(key)\n                    field_type = field_info.annotation if field_info else \"unknown\"\n\n                    # Format the type name nicely\n                    if hasattr(field_type, '__name__'):\n                        type_name = field_type.__name__\n                    else:\n                        type_name = str(field_type).replace('typing.', '')\n\n                    click.echo(f\"  {CHECK} {key:28s} {type_name:15s} = {value}\")\n                click.echo(\"\")\n\n        except ConfigurationError as e:\n            if fields:\n                click.echo(f\"\\n{CROSS} Field validation failed\", err=True)\n            else:\n                click.echo(f\"\\n{CROSS} Configuration validation failed\", err=True)\n            click.echo(f\"  Error: {e.user_message}\", err=True)\n            if e.recovery_hint:\n                click.echo(f\"  Hint: {e.recovery_hint}\", err=True)\n            click.echo(\"\")\n            return 1\n\n    return validate\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ModelCLIBuilder.build_reset_command","title":"<code>build_reset_command()</code>","text":"<p>Build a 'reset' command that resets configuration to defaults.</p> <p>Returns:</p> Type Description <code>Command</code> <p>Click Command for resetting configuration</p> Command <pre><code>config reset                  # Reset all fields\nconfig reset field1 field2    # Reset specific fields\n</code></pre> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>def build_reset_command(self) -&gt; click.Command:\n    \"\"\"\n    Build a 'reset' command that resets configuration to defaults.\n\n    Returns:\n        Click Command for resetting configuration\n\n    Command:\n        ```\n        config reset                  # Reset all fields\n        config reset field1 field2    # Reset specific fields\n        ```\n    \"\"\"\n    @click.command(name='reset')\n    @click.argument('fields', nargs=-1, type=str)\n    @click.confirmation_option(\n        prompt='Are you sure you want to reset configuration?'\n    )\n    def reset(fields: tuple[str, ...]):\n        \"\"\"Reset configuration to defaults.\n\n        FIELDS: Optional field names to reset (resets all if not specified)\n        \"\"\"\n        try:\n            if fields:\n                # Reset specific fields\n                model = self.model_type.load_or_default(self.config_path)\n                service = ModelManagerService[self.model_type](\n                    self.model_type,\n                    model,\n                    default_path=self.config_path\n                )\n\n                # Get default model\n                default_model = self.model_type()\n\n                click.echo(\"\")\n                for field in fields:\n                    if not hasattr(model, field):\n                        click.echo(f\"[FAIL] Field '{field}' does not exist\", err=True)\n                        continue\n\n                    default_value = getattr(default_model, field)\n                    service.set(field, default_value)\n                    click.echo(f\"[OK] Reset {field} to default: {default_value}\")\n\n                service.save()\n                click.echo(\"\")\n                click.echo(f\"Configuration saved to {self.config_path}\")\n                click.echo(\"\")\n            else:\n                # Reset all fields\n                default_model = self.model_type()\n                service = ModelManagerService[self.model_type](\n                    self.model_type,\n                    default_model,\n                    default_path=self.config_path\n                )\n                service.save()\n\n                click.echo(\"\")\n                click.echo(f\"[OK] Reset all fields to defaults\")\n                click.echo(f\"Configuration saved to {self.config_path}\")\n                click.echo(\"\")\n\n        except ConfigurationError as e:\n            click.echo(f\"Error: {e.user_message}\", err=True)\n            if e.recovery_hint:\n                click.echo(f\"Hint: {e.recovery_hint}\", err=True)\n\n    return reset\n</code></pre>"},{"location":"api/model_manager/cli/builder/#launchsampler.model_manager.cli.builder.ModelCLIBuilder.build_group","title":"<code>build_group(name='config', help=None)</code>","text":"<p>Build a complete Click group with all commands.</p> <p>When called without a subcommand, displays the current configuration (same as the old behavior where 'config' alone would show values).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the command group</p> <code>'config'</code> <code>help</code> <code>Optional[str]</code> <p>Help text for the group</p> <code>None</code> <p>Returns:</p> Type Description <code>Group</code> <p>Click Group with set/validate/reset commands and default show behavior</p> Example <pre><code>builder = ModelCLIBuilder(AppConfig, ...)\nconfig = builder.build_group()\ncli.add_command(config)\n\n# Usage:\n# config              -&gt; shows all fields\n# config set --field value\n# config validate     -&gt; validates with checkmark output\n# config reset [--field name]\n</code></pre> Source code in <code>src/launchsampler/model_manager/cli/builder.py</code> <pre><code>def build_group(self, name: str = \"config\", help: Optional[str] = None) -&gt; click.Group:\n    \"\"\"\n    Build a complete Click group with all commands.\n\n    When called without a subcommand, displays the current configuration\n    (same as the old behavior where 'config' alone would show values).\n\n    Args:\n        name: Name of the command group\n        help: Help text for the group\n\n    Returns:\n        Click Group with set/validate/reset commands and default show behavior\n\n    Example:\n        ```python\n        builder = ModelCLIBuilder(AppConfig, ...)\n        config = builder.build_group()\n        cli.add_command(config)\n\n        # Usage:\n        # config              -&gt; shows all fields\n        # config set --field value\n        # config validate     -&gt; validates with checkmark output\n        # config reset [--field name]\n        ```\n    \"\"\"\n    if help is None:\n        help = f\"Manage {self.model_type.__name__} configuration\"\n\n    # Create the show logic for the group callback\n    def show_config(**kwargs):\n        \"\"\"Display current configuration when no subcommand is provided.\"\"\"\n        field = kwargs.get('field')\n        try:\n            # Load model\n            model = self.model_type.load_or_default(self.config_path)\n\n            if field:\n                # Show specific field\n                if hasattr(model, field):\n                    value = getattr(model, field)\n                    click.echo(f\"{field}: {value}\")\n                else:\n                    click.echo(f\"Error: Field '{field}' does not exist\", err=True)\n                    return\n            else:\n                # Show all fields\n                model_dict = model.model_dump()\n                click.echo(f\"\\n{self.model_type.__name__} Configuration:\")\n                click.echo(\"=\" * 60)\n                for key, value in model_dict.items():\n                    if self._should_expose(key):\n                        click.echo(f\"  {key}: {value}\")\n                click.echo(\"\")\n\n        except ConfigurationError as e:\n            click.echo(f\"Error: {e.user_message}\", err=True)\n            if e.recovery_hint:\n                click.echo(f\"Hint: {e.recovery_hint}\", err=True)\n\n    # Create a custom group class that shows config by default\n    class DefaultShowGroup(click.Group):\n        def invoke(self, ctx):\n            # Call parent first to handle subcommands\n            result = super().invoke(ctx)\n\n            # If no subcommand was invoked, show the configuration\n            if ctx.invoked_subcommand is None:\n                show_config(**ctx.params)\n\n            return result\n\n    group = DefaultShowGroup(\n        name=name,\n        help=help,\n        invoke_without_command=True,\n        params=[\n            click.Option(\n                ['--field', '-f'],\n                type=str,\n                default=None,\n                help='Show specific field instead of all fields'\n            )\n        ]\n    )\n\n    # Add subcommands (no 'show' - that's the default behavior)\n    group.add_command(self.build_set_command())\n    group.add_command(self.build_validate_command())\n    group.add_command(self.build_reset_command())\n\n    return group\n</code></pre>"},{"location":"api/models/","title":"Models","text":"<p>Pydantic data models for configuration and state</p> <p>Data models for the Launchpad sampler.</p>"},{"location":"api/models/#launchsampler.models.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RGB color for Launchpad LED.</p>"},{"location":"api/models/#launchsampler.models.Color.validate_rgb","title":"<code>validate_rgb(v)</code>  <code>classmethod</code>","text":"<p>Ensure RGB values are in valid range.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@field_validator(\"r\", \"g\", \"b\")\n@classmethod\ndef validate_rgb(cls, v: int) -&gt; int:\n    \"\"\"Ensure RGB values are in valid range.\"\"\"\n    if not 0 &lt;= v &lt;= 127:\n        raise ValueError(\"RGB values must be between 0 and 127\")\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.off","title":"<code>off()</code>  <code>classmethod</code>","text":"<p>Create off (black) color.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@classmethod\ndef off(cls) -&gt; \"Color\":\n    \"\"\"Create off (black) color.\"\"\"\n    return cls(r=0, g=0, b=0)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.to_rgb_tuple","title":"<code>to_rgb_tuple()</code>","text":"<p>Convert to RGB tuple.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_rgb_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert to RGB tuple.\"\"\"\n    return (self.r, self.g, self.b)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert to CSS hex color string (e.g., '#FF00FF').</p> <p>Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range. This method scales the values by 2 for proper CSS display.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex color string in format '#RRGGBB'</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Convert to CSS hex color string (e.g., '#FF00FF').\n\n    Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range.\n    This method scales the values by 2 for proper CSS display.\n\n    Returns:\n        str: Hex color string in format '#RRGGBB'\n    \"\"\"\n    # Scale from 0-127 to 0-255 for CSS compatibility\n    r_scaled = self.r * 2\n    g_scaled = self.g * 2\n    b_scaled = self.b * 2\n    return f\"#{r_scaled:02X}{g_scaled:02X}{b_scaled:02X}\"\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig","title":"<code>AppConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration and settings.</p>"},{"location":"api/models/#launchsampler.models.AppConfig.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@field_serializer(\"sets_dir\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string.\"\"\"\n    return str(path)\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.ensure_directories","title":"<code>ensure_directories()</code>","text":"<p>Create config directories if they don't exist.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def ensure_directories(self) -&gt; None:\n    \"\"\"Create config directories if they don't exist.\"\"\"\n    self.sets_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.load_or_default","title":"<code>load_or_default(path=None)</code>  <code>classmethod</code>","text":"<p>Load config from file or return default.</p> <p>Raises:</p> Type Description <code>ConfigFileInvalidError</code> <p>If config file has invalid JSON syntax</p> <code>ConfigValidationError</code> <p>If config values fail validation</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@classmethod\ndef load_or_default(cls, path: Optional[Path] = None) -&gt; \"AppConfig\":\n    \"\"\"\n    Load config from file or return default.\n\n    Raises:\n        ConfigFileInvalidError: If config file has invalid JSON syntax\n        ConfigValidationError: If config values fail validation\n    \"\"\"\n    from pydantic import ValidationError\n    from launchsampler.exceptions import wrap_pydantic_error\n\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    if path.exists():\n        try:\n            return cls.model_validate_json(path.read_text())\n        except ValidationError as e:\n            # Convert Pydantic error to our custom exception\n            raise wrap_pydantic_error(e, str(path)) from e\n\n    config = cls()\n    config.ensure_directories()\n    return config\n</code></pre>"},{"location":"api/models/#launchsampler.models.AppConfig.save","title":"<code>save(path=None)</code>","text":"<p>Save config to file.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save config to file.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(self.model_dump_json(indent=2))\n</code></pre>"},{"location":"api/models/#launchsampler.models.LaunchpadColor","title":"<code>LaunchpadColor</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Complete Launchpad palette (128 colors) with both RGB and palette index.</p> <p>Each color is a tuple of (Color, palette_index). Based on Launchpad MK2/Pro palette.</p>"},{"location":"api/models/#launchsampler.models.LaunchpadColor.rgb","title":"<code>rgb</code>  <code>property</code>","text":"<p>Get the RGB Color value.</p>"},{"location":"api/models/#launchsampler.models.LaunchpadColor.palette","title":"<code>palette</code>  <code>property</code>","text":"<p>Get the palette index (0-127).</p>"},{"location":"api/models/#launchsampler.models.PlaybackMode","title":"<code>PlaybackMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Audio playback modes.</p>"},{"location":"api/models/#launchsampler.models.Launchpad","title":"<code>Launchpad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the complete 8x8 grid of pads.</p>"},{"location":"api/models/#launchsampler.models.Launchpad.assigned_pads","title":"<code>assigned_pads</code>  <code>property</code>","text":"<p>Get all pads that have samples assigned.</p>"},{"location":"api/models/#launchsampler.models.Launchpad.validate_pad_count","title":"<code>validate_pad_count(v)</code>  <code>classmethod</code>","text":"<p>Ensure exactly 64 pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@field_validator(\"pads\")\n@classmethod\ndef validate_pad_count(cls, v: list[Pad]) -&gt; list[Pad]:\n    \"\"\"Ensure exactly 64 pads.\"\"\"\n    if len(v) != TOTAL_PADS:\n        raise ValueError(f\"Launchpad must have exactly {TOTAL_PADS} pads ({GRID_SIZE}x{GRID_SIZE})\")\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; int:\n    \"\"\"Convert (x, y) coordinates to MIDI note.\"\"\"\n    return y * self.GRID_SIZE + x\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; tuple[int, int]:\n    \"\"\"Convert MIDI note to (x, y) coordinates.\"\"\"\n    y = note // self.GRID_SIZE\n    x = note % self.GRID_SIZE\n    return (x, y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.get_pad","title":"<code>get_pad(x, y)</code>","text":"<p>Get pad at specific coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad(self, x: int, y: int) -&gt; Pad:\n    \"\"\"Get pad at specific coordinates.\"\"\"\n    if not (0 &lt;= x &lt; self.GRID_SIZE and 0 &lt;= y &lt; self.GRID_SIZE):\n        raise ValueError(f\"Invalid coordinates: ({x}, {y}). Must be 0-{self.GRID_SIZE - 1}.\")\n    return self.pads[self.xy_to_note(x, y)]\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.get_pad_by_note","title":"<code>get_pad_by_note(note)</code>","text":"<p>Get pad by MIDI note number (0-63).</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad_by_note(self, note: int) -&gt; Optional[Pad]:\n    \"\"\"Get pad by MIDI note number (0-63).\"\"\"\n    if not 0 &lt;= note &lt; self.TOTAL_PADS:\n        return None\n    x, y = self.note_to_xy(note)\n    return self.get_pad(x, y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all pads.\"\"\"\n    for pad in self.pads:\n        pad.clear()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.create_empty","title":"<code>create_empty()</code>  <code>classmethod</code>","text":"<p>Create a new empty Launchpad.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef create_empty(cls) -&gt; \"Launchpad\":\n    \"\"\"Create a new empty Launchpad.\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Launchpad.from_sample_directory","title":"<code>from_sample_directory(samples_dir, auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create Launchpad configuration by scanning a directory for audio samples.</p> <p>Discovers audio files (WAV, MP3, FLAC) and assigns them to pads. If auto_configure is True, infers playback mode and color from filename.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Launchpad</code> <code>Launchpad</code> <p>Configured Launchpad instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Launchpad\":\n    \"\"\"Create Launchpad configuration by scanning a directory for audio samples.\n\n    Discovers audio files (WAV, MP3, FLAC) and assigns them to pads.\n    If auto_configure is True, infers playback mode and color from filename.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Launchpad: Configured Launchpad instance\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    if not samples_dir.exists():\n        raise ValueError(f\"Samples directory not found: {samples_dir}\")\n\n    # Discover audio files recursively\n    extensions = [\"**/*.wav\", \"**/*.mp3\", \"**/*.flac\", \"**/*.ogg\", \"**/*.aiff\"]\n    sample_files = []\n    for ext in extensions:\n        sample_files.extend(samples_dir.glob(ext))\n\n    if not sample_files:\n        raise ValueError(f\"No audio files found in {samples_dir}\")\n\n    # Sort for consistent ordering\n    sample_files.sort()\n\n    # Create empty launchpad\n    launchpad = cls.create_empty()\n\n    # Assign samples to pads (max 64)\n    for i, sample_file in enumerate(sample_files[:TOTAL_PADS]):\n        sample = Sample.from_file(sample_file)\n        pad = launchpad.pads[i]\n\n        # Assign sample\n        pad.sample = sample\n        pad.volume = default_volume\n\n        # Auto-configure mode and color if requested\n        if auto_configure:\n            pad.mode = cls._infer_playback_mode(sample)\n            pad.color = MODE_COLORS[pad.mode].rgb\n        else:\n            # Use defaults from Pad model\n            pad.mode = PlaybackMode.ONE_SHOT\n            pad.color = MODE_COLORS[pad.mode].rgb\n\n        logger.debug(\n            f\"Pad {i}: {sample.name} ({pad.mode.value}, \"\n            f\"RGB={pad.color.r},{pad.color.g},{pad.color.b})\"\n        )\n\n    logger.info(f\"Loaded {len(sample_files[:TOTAL_PADS])} samples from {samples_dir}\")\n\n    return launchpad\n</code></pre>"},{"location":"api/models/#launchsampler.models.Pad","title":"<code>Pad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single pad in the 8x8 grid.</p>"},{"location":"api/models/#launchsampler.models.Pad.is_assigned","title":"<code>is_assigned</code>  <code>property</code>","text":"<p>Check if pad has a sample assigned.</p>"},{"location":"api/models/#launchsampler.models.Pad.position","title":"<code>position</code>  <code>property</code>","text":"<p>Get (x, y) position as tuple.</p>"},{"location":"api/models/#launchsampler.models.Pad.clear","title":"<code>clear()</code>","text":"<p>Clear the pad (remove sample and turn off LED).</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the pad (remove sample and turn off LED).\"\"\"\n    self.sample = None\n    self.color = Color.off()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Pad.empty","title":"<code>empty(x, y)</code>  <code>classmethod</code>","text":"<p>Create an empty pad at given position.</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>@classmethod\ndef empty(cls, x: int, y: int) -&gt; \"Pad\":\n    \"\"\"Create an empty pad at given position.\"\"\"\n    return cls(x=x, y=y)\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio sample metadata (not the actual audio data).</p>"},{"location":"api/models/#launchsampler.models.Sample.validate_path","title":"<code>validate_path(v)</code>  <code>classmethod</code>","text":"<p>Validate that path is a Path object.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_validator(\"path\")\n@classmethod\ndef validate_path(cls, v: Path) -&gt; Path:\n    \"\"\"Validate that path is a Path object.\"\"\"\n    if not isinstance(v, Path):\n        return Path(v)\n    return v\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_serializer(\"path\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string using forward slashes for portability.\"\"\"\n    return path.as_posix()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Create Sample from file path.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; \"Sample\":\n    \"\"\"Create Sample from file path.\"\"\"\n    return cls(\n        name=path.stem,\n        path=path\n    )\n</code></pre>"},{"location":"api/models/#launchsampler.models.Sample.exists","title":"<code>exists()</code>","text":"<p>Check if the audio file exists.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the audio file exists.\"\"\"\n    return self.path.exists()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set","title":"<code>Set</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A saved configuration of pad assignments.</p> <p>Path Handling: - samples_root: Optional override for where samples are located - If None (default): sample paths are relative to the Set JSON file location - If set: sample paths are relative to samples_root - Absolute paths are preserved as-is</p>"},{"location":"api/models/#launchsampler.models.Set.serialize_datetime","title":"<code>serialize_datetime(dt)</code>","text":"<p>Serialize datetime to ISO format.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"created_at\", \"modified_at\")\ndef serialize_datetime(self, dt: datetime) -&gt; str:\n    \"\"\"Serialize datetime to ISO format.\"\"\"\n    return dt.isoformat()\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.serialize_samples_root","title":"<code>serialize_samples_root(samples_root)</code>","text":"<p>Serialize samples_root Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"samples_root\")\ndef serialize_samples_root(self, samples_root: Optional[Path]) -&gt; Optional[str]:\n    \"\"\"Serialize samples_root Path to string using forward slashes for portability.\"\"\"\n    return samples_root.as_posix() if samples_root else None\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.get_samples_root","title":"<code>get_samples_root(set_file_path)</code>","text":"<p>Get the root directory for resolving relative sample paths.</p> <p>Parameters:</p> Name Type Description Default <code>set_file_path</code> <code>Path</code> <p>Path to the Set JSON file</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Root directory (either explicit samples_root or Set file's directory)</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>def get_samples_root(self, set_file_path: Path) -&gt; Path:\n    \"\"\"Get the root directory for resolving relative sample paths.\n\n    Args:\n        set_file_path: Path to the Set JSON file\n\n    Returns:\n        Path: Root directory (either explicit samples_root or Set file's directory)\n    \"\"\"\n    if self.samples_root:\n        return self.samples_root\n    else:\n        # Default: samples are relative to the Set JSON file's directory\n        return set_file_path.parent\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.from_sample_directory","title":"<code>from_sample_directory(samples_dir, name='untitled', auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create a Set by scanning a directory for audio samples.</p> <p>This is a convenience method that wraps Launchpad.from_sample_directory and creates a Set with samples_root set to the scanned directory.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>name</code> <code>str</code> <p>Name for the set</p> <code>'untitled'</code> <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Set</code> <code>Set</code> <p>New set with samples loaded from directory</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    name: str = \"untitled\",\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Set\":\n    \"\"\"Create a Set by scanning a directory for audio samples.\n\n    This is a convenience method that wraps Launchpad.from_sample_directory\n    and creates a Set with samples_root set to the scanned directory.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        name: Name for the set\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Set: New set with samples loaded from directory\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    launchpad = Launchpad.from_sample_directory(\n        samples_dir=samples_dir,\n        auto_configure=auto_configure,\n        default_volume=default_volume\n    )\n\n    return cls(\n        name=name,\n        launchpad=launchpad,\n        samples_root=samples_dir  # Paths will be relative to this directory\n    )\n</code></pre>"},{"location":"api/models/#launchsampler.models.Set.create_empty","title":"<code>create_empty(name)</code>  <code>classmethod</code>","text":"<p>Create a new empty set.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef create_empty(cls, name: str) -&gt; \"Set\":\n    \"\"\"Create a new empty set.\"\"\"\n    return cls(\n        name=name,\n        launchpad=Launchpad.create_empty()\n    )\n</code></pre>"},{"location":"api/models/color/","title":"Color","text":""},{"location":"api/models/color/#launchsampler.models.color","title":"<code>color</code>","text":"<p>Color model for LED control.</p>"},{"location":"api/models/color/#launchsampler.models.color.Color","title":"<code>Color</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>RGB color for Launchpad LED.</p>"},{"location":"api/models/color/#launchsampler.models.color.Color.validate_rgb","title":"<code>validate_rgb(v)</code>  <code>classmethod</code>","text":"<p>Ensure RGB values are in valid range.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@field_validator(\"r\", \"g\", \"b\")\n@classmethod\ndef validate_rgb(cls, v: int) -&gt; int:\n    \"\"\"Ensure RGB values are in valid range.\"\"\"\n    if not 0 &lt;= v &lt;= 127:\n        raise ValueError(\"RGB values must be between 0 and 127\")\n    return v\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.off","title":"<code>off()</code>  <code>classmethod</code>","text":"<p>Create off (black) color.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>@classmethod\ndef off(cls) -&gt; \"Color\":\n    \"\"\"Create off (black) color.\"\"\"\n    return cls(r=0, g=0, b=0)\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.to_rgb_tuple","title":"<code>to_rgb_tuple()</code>","text":"<p>Convert to RGB tuple.</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_rgb_tuple(self) -&gt; tuple[int, int, int]:\n    \"\"\"Convert to RGB tuple.\"\"\"\n    return (self.r, self.g, self.b)\n</code></pre>"},{"location":"api/models/color/#launchsampler.models.color.Color.to_hex","title":"<code>to_hex()</code>","text":"<p>Convert to CSS hex color string (e.g., '#FF00FF').</p> <p>Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range. This method scales the values by 2 for proper CSS display.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hex color string in format '#RRGGBB'</p> Source code in <code>src/launchsampler/models/color.py</code> <pre><code>def to_hex(self) -&gt; str:\n    \"\"\"Convert to CSS hex color string (e.g., '#FF00FF').\n\n    Note: Launchpad uses 0-127 range, but CSS hex uses 0-255 range.\n    This method scales the values by 2 for proper CSS display.\n\n    Returns:\n        str: Hex color string in format '#RRGGBB'\n    \"\"\"\n    # Scale from 0-127 to 0-255 for CSS compatibility\n    r_scaled = self.r * 2\n    g_scaled = self.g * 2\n    b_scaled = self.b * 2\n    return f\"#{r_scaled:02X}{g_scaled:02X}{b_scaled:02X}\"\n</code></pre>"},{"location":"api/models/config/","title":"Config","text":""},{"location":"api/models/config/#launchsampler.models.config","title":"<code>config</code>","text":"<p>Application configuration model.</p>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig","title":"<code>AppConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Application configuration and settings.</p>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@field_serializer(\"sets_dir\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string.\"\"\"\n    return str(path)\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.ensure_directories","title":"<code>ensure_directories()</code>","text":"<p>Create config directories if they don't exist.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def ensure_directories(self) -&gt; None:\n    \"\"\"Create config directories if they don't exist.\"\"\"\n    self.sets_dir.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.load_or_default","title":"<code>load_or_default(path=None)</code>  <code>classmethod</code>","text":"<p>Load config from file or return default.</p> <p>Raises:</p> Type Description <code>ConfigFileInvalidError</code> <p>If config file has invalid JSON syntax</p> <code>ConfigValidationError</code> <p>If config values fail validation</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>@classmethod\ndef load_or_default(cls, path: Optional[Path] = None) -&gt; \"AppConfig\":\n    \"\"\"\n    Load config from file or return default.\n\n    Raises:\n        ConfigFileInvalidError: If config file has invalid JSON syntax\n        ConfigValidationError: If config values fail validation\n    \"\"\"\n    from pydantic import ValidationError\n    from launchsampler.exceptions import wrap_pydantic_error\n\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    if path.exists():\n        try:\n            return cls.model_validate_json(path.read_text())\n        except ValidationError as e:\n            # Convert Pydantic error to our custom exception\n            raise wrap_pydantic_error(e, str(path)) from e\n\n    config = cls()\n    config.ensure_directories()\n    return config\n</code></pre>"},{"location":"api/models/config/#launchsampler.models.config.AppConfig.save","title":"<code>save(path=None)</code>","text":"<p>Save config to file.</p> Source code in <code>src/launchsampler/models/config.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"Save config to file.\"\"\"\n    if path is None:\n        path = Path.home() / \".launchsampler\" / \"config.json\"\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(self.model_dump_json(indent=2))\n</code></pre>"},{"location":"api/models/enums/","title":"Enums","text":""},{"location":"api/models/enums/#launchsampler.models.enums","title":"<code>enums</code>","text":"<p>Enumerations for the Launchpad sampler.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor","title":"<code>LaunchpadColor</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Complete Launchpad palette (128 colors) with both RGB and palette index.</p> <p>Each color is a tuple of (Color, palette_index). Based on Launchpad MK2/Pro palette.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor.rgb","title":"<code>rgb</code>  <code>property</code>","text":"<p>Get the RGB Color value.</p>"},{"location":"api/models/enums/#launchsampler.models.enums.LaunchpadColor.palette","title":"<code>palette</code>  <code>property</code>","text":"<p>Get the palette index (0-127).</p>"},{"location":"api/models/enums/#launchsampler.models.enums.PlaybackMode","title":"<code>PlaybackMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Audio playback modes.</p>"},{"location":"api/models/launchpad/","title":"Launchpad","text":""},{"location":"api/models/launchpad/#launchsampler.models.launchpad","title":"<code>launchpad</code>","text":"<p>Launchpad model representing the 8x8 grid.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad","title":"<code>Launchpad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the complete 8x8 grid of pads.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.assigned_pads","title":"<code>assigned_pads</code>  <code>property</code>","text":"<p>Get all pads that have samples assigned.</p>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.validate_pad_count","title":"<code>validate_pad_count(v)</code>  <code>classmethod</code>","text":"<p>Ensure exactly 64 pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@field_validator(\"pads\")\n@classmethod\ndef validate_pad_count(cls, v: list[Pad]) -&gt; list[Pad]:\n    \"\"\"Ensure exactly 64 pads.\"\"\"\n    if len(v) != TOTAL_PADS:\n        raise ValueError(f\"Launchpad must have exactly {TOTAL_PADS} pads ({GRID_SIZE}x{GRID_SIZE})\")\n    return v\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.xy_to_note","title":"<code>xy_to_note(x, y)</code>","text":"<p>Convert (x, y) coordinates to MIDI note.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def xy_to_note(self, x: int, y: int) -&gt; int:\n    \"\"\"Convert (x, y) coordinates to MIDI note.\"\"\"\n    return y * self.GRID_SIZE + x\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.note_to_xy","title":"<code>note_to_xy(note)</code>","text":"<p>Convert MIDI note to (x, y) coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def note_to_xy(self, note: int) -&gt; tuple[int, int]:\n    \"\"\"Convert MIDI note to (x, y) coordinates.\"\"\"\n    y = note // self.GRID_SIZE\n    x = note % self.GRID_SIZE\n    return (x, y)\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.get_pad","title":"<code>get_pad(x, y)</code>","text":"<p>Get pad at specific coordinates.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad(self, x: int, y: int) -&gt; Pad:\n    \"\"\"Get pad at specific coordinates.\"\"\"\n    if not (0 &lt;= x &lt; self.GRID_SIZE and 0 &lt;= y &lt; self.GRID_SIZE):\n        raise ValueError(f\"Invalid coordinates: ({x}, {y}). Must be 0-{self.GRID_SIZE - 1}.\")\n    return self.pads[self.xy_to_note(x, y)]\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.get_pad_by_note","title":"<code>get_pad_by_note(note)</code>","text":"<p>Get pad by MIDI note number (0-63).</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def get_pad_by_note(self, note: int) -&gt; Optional[Pad]:\n    \"\"\"Get pad by MIDI note number (0-63).\"\"\"\n    if not 0 &lt;= note &lt; self.TOTAL_PADS:\n        return None\n    x, y = self.note_to_xy(note)\n    return self.get_pad(x, y)\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>def clear_all(self) -&gt; None:\n    \"\"\"Clear all pads.\"\"\"\n    for pad in self.pads:\n        pad.clear()\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.create_empty","title":"<code>create_empty()</code>  <code>classmethod</code>","text":"<p>Create a new empty Launchpad.</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef create_empty(cls) -&gt; \"Launchpad\":\n    \"\"\"Create a new empty Launchpad.\"\"\"\n    return cls()\n</code></pre>"},{"location":"api/models/launchpad/#launchsampler.models.launchpad.Launchpad.from_sample_directory","title":"<code>from_sample_directory(samples_dir, auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create Launchpad configuration by scanning a directory for audio samples.</p> <p>Discovers audio files (WAV, MP3, FLAC) and assigns them to pads. If auto_configure is True, infers playback mode and color from filename.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Launchpad</code> <code>Launchpad</code> <p>Configured Launchpad instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/launchpad.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Launchpad\":\n    \"\"\"Create Launchpad configuration by scanning a directory for audio samples.\n\n    Discovers audio files (WAV, MP3, FLAC) and assigns them to pads.\n    If auto_configure is True, infers playback mode and color from filename.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Launchpad: Configured Launchpad instance\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    if not samples_dir.exists():\n        raise ValueError(f\"Samples directory not found: {samples_dir}\")\n\n    # Discover audio files recursively\n    extensions = [\"**/*.wav\", \"**/*.mp3\", \"**/*.flac\", \"**/*.ogg\", \"**/*.aiff\"]\n    sample_files = []\n    for ext in extensions:\n        sample_files.extend(samples_dir.glob(ext))\n\n    if not sample_files:\n        raise ValueError(f\"No audio files found in {samples_dir}\")\n\n    # Sort for consistent ordering\n    sample_files.sort()\n\n    # Create empty launchpad\n    launchpad = cls.create_empty()\n\n    # Assign samples to pads (max 64)\n    for i, sample_file in enumerate(sample_files[:TOTAL_PADS]):\n        sample = Sample.from_file(sample_file)\n        pad = launchpad.pads[i]\n\n        # Assign sample\n        pad.sample = sample\n        pad.volume = default_volume\n\n        # Auto-configure mode and color if requested\n        if auto_configure:\n            pad.mode = cls._infer_playback_mode(sample)\n            pad.color = MODE_COLORS[pad.mode].rgb\n        else:\n            # Use defaults from Pad model\n            pad.mode = PlaybackMode.ONE_SHOT\n            pad.color = MODE_COLORS[pad.mode].rgb\n\n        logger.debug(\n            f\"Pad {i}: {sample.name} ({pad.mode.value}, \"\n            f\"RGB={pad.color.r},{pad.color.g},{pad.color.b})\"\n        )\n\n    logger.info(f\"Loaded {len(sample_files[:TOTAL_PADS])} samples from {samples_dir}\")\n\n    return launchpad\n</code></pre>"},{"location":"api/models/pad/","title":"Pad","text":""},{"location":"api/models/pad/#launchsampler.models.pad","title":"<code>pad</code>","text":"<p>Pad model representing a single grid cell.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad","title":"<code>Pad</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a single pad in the 8x8 grid.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.is_assigned","title":"<code>is_assigned</code>  <code>property</code>","text":"<p>Check if pad has a sample assigned.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.position","title":"<code>position</code>  <code>property</code>","text":"<p>Get (x, y) position as tuple.</p>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.clear","title":"<code>clear()</code>","text":"<p>Clear the pad (remove sample and turn off LED).</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the pad (remove sample and turn off LED).\"\"\"\n    self.sample = None\n    self.color = Color.off()\n</code></pre>"},{"location":"api/models/pad/#launchsampler.models.pad.Pad.empty","title":"<code>empty(x, y)</code>  <code>classmethod</code>","text":"<p>Create an empty pad at given position.</p> Source code in <code>src/launchsampler/models/pad.py</code> <pre><code>@classmethod\ndef empty(cls, x: int, y: int) -&gt; \"Pad\":\n    \"\"\"Create an empty pad at given position.\"\"\"\n    return cls(x=x, y=y)\n</code></pre>"},{"location":"api/models/sample/","title":"Sample","text":""},{"location":"api/models/sample/#launchsampler.models.sample","title":"<code>sample</code>","text":"<p>Sample model for audio file metadata.</p>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Audio sample metadata (not the actual audio data).</p>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.validate_path","title":"<code>validate_path(v)</code>  <code>classmethod</code>","text":"<p>Validate that path is a Path object.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_validator(\"path\")\n@classmethod\ndef validate_path(cls, v: Path) -&gt; Path:\n    \"\"\"Validate that path is a Path object.\"\"\"\n    if not isinstance(v, Path):\n        return Path(v)\n    return v\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.serialize_path","title":"<code>serialize_path(path)</code>","text":"<p>Serialize Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@field_serializer(\"path\")\ndef serialize_path(self, path: Path) -&gt; str:\n    \"\"\"Serialize Path to string using forward slashes for portability.\"\"\"\n    return path.as_posix()\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Create Sample from file path.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>@classmethod\ndef from_file(cls, path: Path) -&gt; \"Sample\":\n    \"\"\"Create Sample from file path.\"\"\"\n    return cls(\n        name=path.stem,\n        path=path\n    )\n</code></pre>"},{"location":"api/models/sample/#launchsampler.models.sample.Sample.exists","title":"<code>exists()</code>","text":"<p>Check if the audio file exists.</p> Source code in <code>src/launchsampler/models/sample.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the audio file exists.\"\"\"\n    return self.path.exists()\n</code></pre>"},{"location":"api/models/set/","title":"Set","text":""},{"location":"api/models/set/#launchsampler.models.set","title":"<code>set</code>","text":"<p>Set model for pad configurations (data structure only - persistence is in SetManagerService).</p>"},{"location":"api/models/set/#launchsampler.models.set.Set","title":"<code>Set</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A saved configuration of pad assignments.</p> <p>Path Handling: - samples_root: Optional override for where samples are located - If None (default): sample paths are relative to the Set JSON file location - If set: sample paths are relative to samples_root - Absolute paths are preserved as-is</p>"},{"location":"api/models/set/#launchsampler.models.set.Set.serialize_datetime","title":"<code>serialize_datetime(dt)</code>","text":"<p>Serialize datetime to ISO format.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"created_at\", \"modified_at\")\ndef serialize_datetime(self, dt: datetime) -&gt; str:\n    \"\"\"Serialize datetime to ISO format.\"\"\"\n    return dt.isoformat()\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.serialize_samples_root","title":"<code>serialize_samples_root(samples_root)</code>","text":"<p>Serialize samples_root Path to string using forward slashes for portability.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@field_serializer(\"samples_root\")\ndef serialize_samples_root(self, samples_root: Optional[Path]) -&gt; Optional[str]:\n    \"\"\"Serialize samples_root Path to string using forward slashes for portability.\"\"\"\n    return samples_root.as_posix() if samples_root else None\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.get_samples_root","title":"<code>get_samples_root(set_file_path)</code>","text":"<p>Get the root directory for resolving relative sample paths.</p> <p>Parameters:</p> Name Type Description Default <code>set_file_path</code> <code>Path</code> <p>Path to the Set JSON file</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>Root directory (either explicit samples_root or Set file's directory)</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>def get_samples_root(self, set_file_path: Path) -&gt; Path:\n    \"\"\"Get the root directory for resolving relative sample paths.\n\n    Args:\n        set_file_path: Path to the Set JSON file\n\n    Returns:\n        Path: Root directory (either explicit samples_root or Set file's directory)\n    \"\"\"\n    if self.samples_root:\n        return self.samples_root\n    else:\n        # Default: samples are relative to the Set JSON file's directory\n        return set_file_path.parent\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.from_sample_directory","title":"<code>from_sample_directory(samples_dir, name='untitled', auto_configure=True, default_volume=0.1)</code>  <code>classmethod</code>","text":"<p>Create a Set by scanning a directory for audio samples.</p> <p>This is a convenience method that wraps Launchpad.from_sample_directory and creates a Set with samples_root set to the scanned directory.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing audio samples</p> required <code>name</code> <code>str</code> <p>Name for the set</p> <code>'untitled'</code> <code>auto_configure</code> <code>bool</code> <p>Auto-configure mode/color based on filename conventions</p> <code>True</code> <code>default_volume</code> <code>float</code> <p>Default volume for all pads (0.0-1.0)</p> <code>0.1</code> <p>Returns:</p> Name Type Description <code>Set</code> <code>Set</code> <p>New set with samples loaded from directory</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If samples_dir doesn't exist or contains no audio files</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef from_sample_directory(\n    cls,\n    samples_dir: Path,\n    name: str = \"untitled\",\n    auto_configure: bool = True,\n    default_volume: float = 0.1,\n) -&gt; \"Set\":\n    \"\"\"Create a Set by scanning a directory for audio samples.\n\n    This is a convenience method that wraps Launchpad.from_sample_directory\n    and creates a Set with samples_root set to the scanned directory.\n\n    Args:\n        samples_dir: Directory containing audio samples\n        name: Name for the set\n        auto_configure: Auto-configure mode/color based on filename conventions\n        default_volume: Default volume for all pads (0.0-1.0)\n\n    Returns:\n        Set: New set with samples loaded from directory\n\n    Raises:\n        ValueError: If samples_dir doesn't exist or contains no audio files\n    \"\"\"\n    launchpad = Launchpad.from_sample_directory(\n        samples_dir=samples_dir,\n        auto_configure=auto_configure,\n        default_volume=default_volume\n    )\n\n    return cls(\n        name=name,\n        launchpad=launchpad,\n        samples_root=samples_dir  # Paths will be relative to this directory\n    )\n</code></pre>"},{"location":"api/models/set/#launchsampler.models.set.Set.create_empty","title":"<code>create_empty(name)</code>  <code>classmethod</code>","text":"<p>Create a new empty set.</p> Source code in <code>src/launchsampler/models/set.py</code> <pre><code>@classmethod\ndef create_empty(cls, name: str) -&gt; \"Set\":\n    \"\"\"Create a new empty set.\"\"\"\n    return cls(\n        name=name,\n        launchpad=Launchpad.create_empty()\n    )\n</code></pre>"},{"location":"api/orchestration/","title":"Orchestration","text":"<p>Application orchestration and lifecycle management</p> <p>Application orchestration layer.</p> <p>This package contains the top-level application orchestrator that coordinates all services, manages application lifecycle, and coordinates multiple UIs.</p> <p>The orchestrator is responsible for: - Initializing and managing services (Player, Editor, SetManager) - Coordinating multiple UI implementations (TUI, LED, web) - Managing application state and lifecycle - Firing application-level events</p>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator","title":"<code>Orchestrator(config, set_name=None, samples_dir=None, start_mode='edit', headless=False)</code>","text":"<p>Top-level orchestrator for the Launchpad Sampler application.</p> <p>Coordinates: - Core state (Launchpad, Set, mode) - Services (Player, SetManager, Editor) - Multiple UI implementations (TUI, LED, web, etc.) - Application lifecycle (initialize, run, shutdown)</p> <p>The Textual TUI is just one possible UI - you can run headless with just the Launchpad hardware, or add other UIs (web, native) without changing this orchestrator.</p> Architecture <p>Orchestrator (this class) \u251c\u2500\u2500 Core State: launchpad, current_set, mode \u251c\u2500\u2500 Services: config_service, set_manager, player, editor \u2514\u2500\u2500 UIs (observers): textual_ui, led_ui, etc.</p> <p>Initialize the orchestrator.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required <code>set_name</code> <code>Optional[str]</code> <p>Optional set to load on startup</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Optional directory to load samples from</p> <code>None</code> <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'edit'</code> <code>headless</code> <code>bool</code> <p>If True, run without TUI (MIDI/LED only)</p> <code>False</code> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def __init__(\n    self,\n    config: AppConfig,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None,\n    start_mode: str = \"edit\",\n    headless: bool = False\n):\n    \"\"\"\n    Initialize the orchestrator.\n\n    Args:\n        config: Application configuration\n        set_name: Optional set to load on startup\n        samples_dir: Optional directory to load samples from\n        start_mode: Mode to start in (\"edit\" or \"play\")\n        headless: If True, run without TUI (MIDI/LED only)\n    \"\"\"\n    self.config = config\n    self.headless = headless\n\n    # Initial load parameters\n    self._initial_set_name = set_name\n    self._initial_samples_dir = samples_dir\n    self._start_mode = start_mode\n\n    # Core state - owned by orchestrator\n    self._mode: Optional[str] = None\n    self.launchpad: Launchpad = Launchpad.create_empty()\n    self.current_set: Set = Set.create_empty(\"Untitled\")\n\n    # Shared resources - hardware and state\n    self.state_machine = SamplerStateMachine()\n    self.midi_controller: Optional[DeviceController] = None\n\n    # Services (domain logic)\n    self.config_service: Optional[ModelManagerService[AppConfig]] = None\n    self.set_manager: Optional[SetManagerService] = None\n    self.player: Optional[Player] = None\n    self.editor: Optional[EditorService] = None\n\n    # UI repository\n    self._uis: list[UIAdapter] = []\n\n    # Observers (UIs)\n    self._app_observers = ObserverManager[AppObserver](observer_type_name=\"app\")\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Get the current app mode.</p> <p>READ-ONLY: This is a read-only property. To change the mode, use set_mode() which fires AppEvent.MODE_CHANGED for observers.</p>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.register_ui","title":"<code>register_ui(ui)</code>","text":"<p>Register a UI implementation.</p> <p>This should be called BEFORE initialize() to ensure the UI receives all startup events (SET_MOUNTED, MODE_CHANGED, etc.).</p> <p>The UI will be initialized and run as part of the application lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>ui</code> <code>UIAdapter</code> <p>UI implementation to register</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def register_ui(self, ui: UIAdapter) -&gt; None:\n    \"\"\"\n    Register a UI implementation.\n\n    This should be called BEFORE initialize() to ensure the UI receives\n    all startup events (SET_MOUNTED, MODE_CHANGED, etc.).\n\n    The UI will be initialized and run as part of the application lifecycle.\n\n    Args:\n        ui: UI implementation to register\n    \"\"\"\n    if ui not in self._uis:\n        self._uis.append(ui)\n        logger.info(f\"Registered UI: {ui.__class__.__name__}\")\n\n        # If UI is also an observer, register it immediately\n        # This ensures it receives startup events during initialize()\n        if isinstance(ui, AppObserver):\n            self.register_observer(ui)\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the application services and load initial state.</p> <p>This is called by the UI during on_mount (when Textual's event loop is running). At this point, UI observers are already registered and widgets exist.</p> <p>Fires startup events (SET_MOUNTED, MODE_CHANGED) that UIs will handle.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the application services and load initial state.\n\n    This is called by the UI during on_mount (when Textual's event loop is running).\n    At this point, UI observers are already registered and widgets exist.\n\n    Fires startup events (SET_MOUNTED, MODE_CHANGED) that UIs will handle.\n    \"\"\"\n    logger.info(\"Initializing Orchestrator services\")\n\n    # Initialize ModelManagerService for centralized config management\n    config_path = Path.home() / \".launchsampler\" / \"config.json\"\n    self.config_service = ModelManagerService[AppConfig](\n        AppConfig,\n        self.config,\n        default_path=config_path\n    )\n    logger.info(\"ModelManagerService initialized\")\n\n    self.set_manager = SetManagerService(self.config)\n\n    # Create MIDI controller (shared resource)\n    self._start_midi()\n\n    # Inject shared state machine into Player\n    self.player = Player(self.config, state_machine=self.state_machine)\n\n    # Setup Editor and register player as edit observer (for audio sync)\n    self.editor = EditorService(self.config)\n    self.editor.register_observer(self.player)\n\n    # Register Player as MIDI observer (if MIDI available)\n    if self.midi_controller:\n        self.midi_controller.register_observer(self.player)\n\n    # Start player audio (must happen BEFORE loading set)\n    try:\n        self.player.start()\n    except RuntimeError as e:\n        logger.error(f\"Failed to start player: {e}\")\n        if not self.headless:\n            # In headless mode, we can't show notifications\n            # Re-raise with the original error message\n            raise\n\n    # Register UIs with services (editor, MIDI, player callbacks)\n    # This must happen AFTER MIDI controller is created but BEFORE loading set\n    for ui in self._uis:\n        # UIs should expose their observer service for edit events\n        if hasattr(ui, 'register_with_services'):\n            ui.register_with_services(self)\n\n    # Load initial set (SetManagerService handles I/O)\n    # Fires SET_MOUNTED event - UIs are already observing\n    loaded_set, was_auto_created = self.set_manager.load_set(\n        self._initial_set_name,\n        self._initial_samples_dir\n    )\n    self.mount_set(loaded_set)\n\n    # If set was auto-created, notify observers\n    if was_auto_created:\n        self._app_observers.notify(\n            'on_app_event',\n            AppEvent.SET_AUTO_CREATED,\n            set_name=loaded_set.name\n        )\n\n\n\n    # Set initial mode - Fires MODE_CHANGED event\n    self.set_mode(self._start_mode)\n\n    logger.info(\"Orchestrator initialized successfully\")\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.run","title":"<code>run()</code>","text":"<p>Run all registered UIs.</p> <p>Initializes UIs first (sets up observers), then runs them. The orchestrator itself will be initialized by the UI during on_mount (when Textual's event loop is running).</p> <p>For interactive UIs (TUI), this will block until the UI exits. For background UIs (LED), this returns immediately.</p> <p>Note: Currently only supports ONE blocking UI. If you need multiple concurrent UIs, consider running them in separate threads/processes.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run all registered UIs.\n\n    Initializes UIs first (sets up observers), then runs them.\n    The orchestrator itself will be initialized by the UI during on_mount\n    (when Textual's event loop is running).\n\n    For interactive UIs (TUI), this will block until the UI exits.\n    For background UIs (LED), this returns immediately.\n\n    Note: Currently only supports ONE blocking UI. If you need multiple\n    concurrent UIs, consider running them in separate threads/processes.\n    \"\"\"\n    if not self._uis:\n        logger.warning(\"No UIs registered - running headless\")\n        return\n\n    # Initialize UIs first (sets up observers, but doesn't start orchestrator services yet)\n    for ui in self._uis:\n        logger.info(f\"Initializing UI: {ui.__class__.__name__}\")\n        ui.initialize()\n\n    # Run all UIs (TUI will block here)\n    # The TUI will call orchestrator.initialize() once Textual is running (in on_mount)\n    for ui in self._uis:\n        logger.info(f\"Running UI: {ui.__class__.__name__}\")\n        ui.run()\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.shutdown","title":"<code>shutdown()</code>","text":"<p>Cleanup when app closes.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Cleanup when app closes.\"\"\"\n    logger.info(\"Shutting down Orchestrator\")\n\n    # Shutdown UIs\n    for ui in self._uis:\n        logger.info(f\"Shutting down UI: {ui.__class__.__name__}\")\n        try:\n            ui.shutdown()\n        except Exception as e:\n            logger.error(f\"Error shutting down UI {ui.__class__.__name__}: {e}\")\n\n    # Shutdown player\n    if self.player:\n        self.player.stop()\n\n    # Shutdown MIDI controller\n    self._stop_midi()\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer for app-level events.</p> <p>UIs should register themselves as observers to receive updates.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>AppObserver</code> <p>The observer to register</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def register_observer(self, observer: AppObserver) -&gt; None:\n    \"\"\"\n    Register an observer for app-level events.\n\n    UIs should register themselves as observers to receive updates.\n\n    Args:\n        observer: The observer to register\n    \"\"\"\n    self._app_observers.register(observer)\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>AppObserver</code> <p>The observer to unregister</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def unregister_observer(self, observer: AppObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n    \"\"\"\n    self._app_observers.unregister(observer)\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.mount_set","title":"<code>mount_set(loaded_set)</code>","text":"<p>Mount a set into the application.</p> <p>This activates the Set in the running application: - Updates orchestrator state - Syncs with player (audio engine) - Syncs with editor (launchpad reference) - Fires events to notify observers (UIs)</p> <p>Parameters:</p> Name Type Description Default <code>loaded_set</code> <code>Set</code> <p>The Set to mount (already loaded from disk/directory)</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def mount_set(self, loaded_set: Set) -&gt; None:\n    \"\"\"\n    Mount a set into the application.\n\n    This activates the Set in the running application:\n    - Updates orchestrator state\n    - Syncs with player (audio engine)\n    - Syncs with editor (launchpad reference)\n    - Fires events to notify observers (UIs)\n\n    Args:\n        loaded_set: The Set to mount (already loaded from disk/directory)\n    \"\"\"\n    # Update core state\n    self.launchpad = loaded_set.launchpad\n    self.current_set = Set(\n        name=loaded_set.name,\n        launchpad=self.launchpad,\n        samples_root=loaded_set.samples_root,\n        created_at=loaded_set.created_at,\n        modified_at=loaded_set.modified_at\n    )\n\n    # Update editor (launchpad reference sync)\n    if self.editor:\n        logger.info(\"Updating EditorService with new launchpad reference\")\n        self.editor.update_launchpad(self.launchpad)\n    else:\n        logger.warning(\"EditorService not initialized - cannot update launchpad reference\")\n\n    # Update player (audio engine sync)\n    if self.player.is_running:\n        logger.info(\"Loading set into Player\")\n        self.player.load_set(self.current_set)\n    else:\n        logger.warning(\"Player not running - cannot load set\")  \n\n    # Notify observers (UIs will sync)\n    self._notify_observers(AppEvent.SET_MOUNTED)\n\n    logger.info(f\"Mounted set: {self.current_set.name} with {len(self.launchpad.assigned_pads)} samples\")\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.save_set","title":"<code>save_set(path, name=None)</code>","text":"<p>Save the current set.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save to</p> required <code>name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def save_set(self, path: Path, name: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Save the current set.\n\n    Args:\n        path: Path to save to\n        name: Optional new name for the set\n    \"\"\"\n    # Update name if changed\n    if name and self.current_set.name != name:\n        self.current_set = Set(\n            name=name,\n            launchpad=self.launchpad,\n            samples_root=self.current_set.samples_root,\n            created_at=self.current_set.created_at,\n            modified_at=self.current_set.modified_at\n        )\n\n    # Save\n    self.set_manager.save_set(self.current_set, path)\n\n    # Notify observers\n    self._notify_observers(AppEvent.SET_SAVED, path=path, set_name=self.current_set.name)\n\n    logger.info(f\"Saved set to: {path}\")\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.set_mode","title":"<code>set_mode(mode)</code>","text":"<p>Set the app mode (edit or play).</p> <p>This only affects UI state - MIDI and audio continue in both modes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if mode was set successfully</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def set_mode(self, mode: str) -&gt; bool:\n    \"\"\"\n    Set the app mode (edit or play).\n\n    This only affects UI state - MIDI and audio continue in both modes.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n\n    Returns:\n        True if mode was set successfully\n    \"\"\"\n    if mode not in (\"edit\", \"play\"):\n        logger.error(f\"Invalid mode: {mode}\")\n        return False\n\n    if self._mode == mode:\n        return True\n\n    # Update mode\n    self._mode = mode\n\n    # Notify observers (UIs will update)\n    self._notify_observers(AppEvent.MODE_CHANGED, mode=mode)\n\n    logger.info(f\"Switched to {mode} mode\")\n    return True\n</code></pre>"},{"location":"api/orchestration/#launchsampler.orchestration.Orchestrator.get_pad","title":"<code>get_pad(index)</code>","text":"<p>Get a pad by index (read-only access).</p> <p>This is a convenience method for EditorService compatibility. To modify pads, use EditorService methods which fire events.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Pad index (0-63)</p> required <p>Returns:</p> Type Description <p>Pad at the given index</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def get_pad(self, index: int):\n    \"\"\"\n    Get a pad by index (read-only access).\n\n    This is a convenience method for EditorService compatibility.\n    To modify pads, use EditorService methods which fire events.\n\n    Args:\n        index: Pad index (0-63)\n\n    Returns:\n        Pad at the given index\n    \"\"\"\n    return self.launchpad.pads[index]\n</code></pre>"},{"location":"api/orchestration/orchestrator/","title":"Orchestrator","text":""},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator","title":"<code>orchestrator</code>","text":"<p>Application orchestrator for coordinating services and UIs.</p> <p>This module coordinates all services and UIs for the Launchpad Sampler application. The design allows running headless (MIDI-only) or with TUI, and makes it easy to add other UI implementations (web, native GUI, etc.).</p>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator","title":"<code>Orchestrator(config, set_name=None, samples_dir=None, start_mode='edit', headless=False)</code>","text":"<p>Top-level orchestrator for the Launchpad Sampler application.</p> <p>Coordinates: - Core state (Launchpad, Set, mode) - Services (Player, SetManager, Editor) - Multiple UI implementations (TUI, LED, web, etc.) - Application lifecycle (initialize, run, shutdown)</p> <p>The Textual TUI is just one possible UI - you can run headless with just the Launchpad hardware, or add other UIs (web, native) without changing this orchestrator.</p> Architecture <p>Orchestrator (this class) \u251c\u2500\u2500 Core State: launchpad, current_set, mode \u251c\u2500\u2500 Services: config_service, set_manager, player, editor \u2514\u2500\u2500 UIs (observers): textual_ui, led_ui, etc.</p> <p>Initialize the orchestrator.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required <code>set_name</code> <code>Optional[str]</code> <p>Optional set to load on startup</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Optional directory to load samples from</p> <code>None</code> <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'edit'</code> <code>headless</code> <code>bool</code> <p>If True, run without TUI (MIDI/LED only)</p> <code>False</code> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def __init__(\n    self,\n    config: AppConfig,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None,\n    start_mode: str = \"edit\",\n    headless: bool = False\n):\n    \"\"\"\n    Initialize the orchestrator.\n\n    Args:\n        config: Application configuration\n        set_name: Optional set to load on startup\n        samples_dir: Optional directory to load samples from\n        start_mode: Mode to start in (\"edit\" or \"play\")\n        headless: If True, run without TUI (MIDI/LED only)\n    \"\"\"\n    self.config = config\n    self.headless = headless\n\n    # Initial load parameters\n    self._initial_set_name = set_name\n    self._initial_samples_dir = samples_dir\n    self._start_mode = start_mode\n\n    # Core state - owned by orchestrator\n    self._mode: Optional[str] = None\n    self.launchpad: Launchpad = Launchpad.create_empty()\n    self.current_set: Set = Set.create_empty(\"Untitled\")\n\n    # Shared resources - hardware and state\n    self.state_machine = SamplerStateMachine()\n    self.midi_controller: Optional[DeviceController] = None\n\n    # Services (domain logic)\n    self.config_service: Optional[ModelManagerService[AppConfig]] = None\n    self.set_manager: Optional[SetManagerService] = None\n    self.player: Optional[Player] = None\n    self.editor: Optional[EditorService] = None\n\n    # UI repository\n    self._uis: list[UIAdapter] = []\n\n    # Observers (UIs)\n    self._app_observers = ObserverManager[AppObserver](observer_type_name=\"app\")\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.mode","title":"<code>mode</code>  <code>property</code>","text":"<p>Get the current app mode.</p> <p>READ-ONLY: This is a read-only property. To change the mode, use set_mode() which fires AppEvent.MODE_CHANGED for observers.</p>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.register_ui","title":"<code>register_ui(ui)</code>","text":"<p>Register a UI implementation.</p> <p>This should be called BEFORE initialize() to ensure the UI receives all startup events (SET_MOUNTED, MODE_CHANGED, etc.).</p> <p>The UI will be initialized and run as part of the application lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>ui</code> <code>UIAdapter</code> <p>UI implementation to register</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def register_ui(self, ui: UIAdapter) -&gt; None:\n    \"\"\"\n    Register a UI implementation.\n\n    This should be called BEFORE initialize() to ensure the UI receives\n    all startup events (SET_MOUNTED, MODE_CHANGED, etc.).\n\n    The UI will be initialized and run as part of the application lifecycle.\n\n    Args:\n        ui: UI implementation to register\n    \"\"\"\n    if ui not in self._uis:\n        self._uis.append(ui)\n        logger.info(f\"Registered UI: {ui.__class__.__name__}\")\n\n        # If UI is also an observer, register it immediately\n        # This ensures it receives startup events during initialize()\n        if isinstance(ui, AppObserver):\n            self.register_observer(ui)\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the application services and load initial state.</p> <p>This is called by the UI during on_mount (when Textual's event loop is running). At this point, UI observers are already registered and widgets exist.</p> <p>Fires startup events (SET_MOUNTED, MODE_CHANGED) that UIs will handle.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the application services and load initial state.\n\n    This is called by the UI during on_mount (when Textual's event loop is running).\n    At this point, UI observers are already registered and widgets exist.\n\n    Fires startup events (SET_MOUNTED, MODE_CHANGED) that UIs will handle.\n    \"\"\"\n    logger.info(\"Initializing Orchestrator services\")\n\n    # Initialize ModelManagerService for centralized config management\n    config_path = Path.home() / \".launchsampler\" / \"config.json\"\n    self.config_service = ModelManagerService[AppConfig](\n        AppConfig,\n        self.config,\n        default_path=config_path\n    )\n    logger.info(\"ModelManagerService initialized\")\n\n    self.set_manager = SetManagerService(self.config)\n\n    # Create MIDI controller (shared resource)\n    self._start_midi()\n\n    # Inject shared state machine into Player\n    self.player = Player(self.config, state_machine=self.state_machine)\n\n    # Setup Editor and register player as edit observer (for audio sync)\n    self.editor = EditorService(self.config)\n    self.editor.register_observer(self.player)\n\n    # Register Player as MIDI observer (if MIDI available)\n    if self.midi_controller:\n        self.midi_controller.register_observer(self.player)\n\n    # Start player audio (must happen BEFORE loading set)\n    try:\n        self.player.start()\n    except RuntimeError as e:\n        logger.error(f\"Failed to start player: {e}\")\n        if not self.headless:\n            # In headless mode, we can't show notifications\n            # Re-raise with the original error message\n            raise\n\n    # Register UIs with services (editor, MIDI, player callbacks)\n    # This must happen AFTER MIDI controller is created but BEFORE loading set\n    for ui in self._uis:\n        # UIs should expose their observer service for edit events\n        if hasattr(ui, 'register_with_services'):\n            ui.register_with_services(self)\n\n    # Load initial set (SetManagerService handles I/O)\n    # Fires SET_MOUNTED event - UIs are already observing\n    loaded_set, was_auto_created = self.set_manager.load_set(\n        self._initial_set_name,\n        self._initial_samples_dir\n    )\n    self.mount_set(loaded_set)\n\n    # If set was auto-created, notify observers\n    if was_auto_created:\n        self._app_observers.notify(\n            'on_app_event',\n            AppEvent.SET_AUTO_CREATED,\n            set_name=loaded_set.name\n        )\n\n\n\n    # Set initial mode - Fires MODE_CHANGED event\n    self.set_mode(self._start_mode)\n\n    logger.info(\"Orchestrator initialized successfully\")\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.run","title":"<code>run()</code>","text":"<p>Run all registered UIs.</p> <p>Initializes UIs first (sets up observers), then runs them. The orchestrator itself will be initialized by the UI during on_mount (when Textual's event loop is running).</p> <p>For interactive UIs (TUI), this will block until the UI exits. For background UIs (LED), this returns immediately.</p> <p>Note: Currently only supports ONE blocking UI. If you need multiple concurrent UIs, consider running them in separate threads/processes.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run all registered UIs.\n\n    Initializes UIs first (sets up observers), then runs them.\n    The orchestrator itself will be initialized by the UI during on_mount\n    (when Textual's event loop is running).\n\n    For interactive UIs (TUI), this will block until the UI exits.\n    For background UIs (LED), this returns immediately.\n\n    Note: Currently only supports ONE blocking UI. If you need multiple\n    concurrent UIs, consider running them in separate threads/processes.\n    \"\"\"\n    if not self._uis:\n        logger.warning(\"No UIs registered - running headless\")\n        return\n\n    # Initialize UIs first (sets up observers, but doesn't start orchestrator services yet)\n    for ui in self._uis:\n        logger.info(f\"Initializing UI: {ui.__class__.__name__}\")\n        ui.initialize()\n\n    # Run all UIs (TUI will block here)\n    # The TUI will call orchestrator.initialize() once Textual is running (in on_mount)\n    for ui in self._uis:\n        logger.info(f\"Running UI: {ui.__class__.__name__}\")\n        ui.run()\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.shutdown","title":"<code>shutdown()</code>","text":"<p>Cleanup when app closes.</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"Cleanup when app closes.\"\"\"\n    logger.info(\"Shutting down Orchestrator\")\n\n    # Shutdown UIs\n    for ui in self._uis:\n        logger.info(f\"Shutting down UI: {ui.__class__.__name__}\")\n        try:\n            ui.shutdown()\n        except Exception as e:\n            logger.error(f\"Error shutting down UI {ui.__class__.__name__}: {e}\")\n\n    # Shutdown player\n    if self.player:\n        self.player.stop()\n\n    # Shutdown MIDI controller\n    self._stop_midi()\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer for app-level events.</p> <p>UIs should register themselves as observers to receive updates.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>AppObserver</code> <p>The observer to register</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def register_observer(self, observer: AppObserver) -&gt; None:\n    \"\"\"\n    Register an observer for app-level events.\n\n    UIs should register themselves as observers to receive updates.\n\n    Args:\n        observer: The observer to register\n    \"\"\"\n    self._app_observers.register(observer)\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>AppObserver</code> <p>The observer to unregister</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def unregister_observer(self, observer: AppObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: The observer to unregister\n    \"\"\"\n    self._app_observers.unregister(observer)\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.mount_set","title":"<code>mount_set(loaded_set)</code>","text":"<p>Mount a set into the application.</p> <p>This activates the Set in the running application: - Updates orchestrator state - Syncs with player (audio engine) - Syncs with editor (launchpad reference) - Fires events to notify observers (UIs)</p> <p>Parameters:</p> Name Type Description Default <code>loaded_set</code> <code>Set</code> <p>The Set to mount (already loaded from disk/directory)</p> required Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def mount_set(self, loaded_set: Set) -&gt; None:\n    \"\"\"\n    Mount a set into the application.\n\n    This activates the Set in the running application:\n    - Updates orchestrator state\n    - Syncs with player (audio engine)\n    - Syncs with editor (launchpad reference)\n    - Fires events to notify observers (UIs)\n\n    Args:\n        loaded_set: The Set to mount (already loaded from disk/directory)\n    \"\"\"\n    # Update core state\n    self.launchpad = loaded_set.launchpad\n    self.current_set = Set(\n        name=loaded_set.name,\n        launchpad=self.launchpad,\n        samples_root=loaded_set.samples_root,\n        created_at=loaded_set.created_at,\n        modified_at=loaded_set.modified_at\n    )\n\n    # Update editor (launchpad reference sync)\n    if self.editor:\n        logger.info(\"Updating EditorService with new launchpad reference\")\n        self.editor.update_launchpad(self.launchpad)\n    else:\n        logger.warning(\"EditorService not initialized - cannot update launchpad reference\")\n\n    # Update player (audio engine sync)\n    if self.player.is_running:\n        logger.info(\"Loading set into Player\")\n        self.player.load_set(self.current_set)\n    else:\n        logger.warning(\"Player not running - cannot load set\")  \n\n    # Notify observers (UIs will sync)\n    self._notify_observers(AppEvent.SET_MOUNTED)\n\n    logger.info(f\"Mounted set: {self.current_set.name} with {len(self.launchpad.assigned_pads)} samples\")\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.save_set","title":"<code>save_set(path, name=None)</code>","text":"<p>Save the current set.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to save to</p> required <code>name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def save_set(self, path: Path, name: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Save the current set.\n\n    Args:\n        path: Path to save to\n        name: Optional new name for the set\n    \"\"\"\n    # Update name if changed\n    if name and self.current_set.name != name:\n        self.current_set = Set(\n            name=name,\n            launchpad=self.launchpad,\n            samples_root=self.current_set.samples_root,\n            created_at=self.current_set.created_at,\n            modified_at=self.current_set.modified_at\n        )\n\n    # Save\n    self.set_manager.save_set(self.current_set, path)\n\n    # Notify observers\n    self._notify_observers(AppEvent.SET_SAVED, path=path, set_name=self.current_set.name)\n\n    logger.info(f\"Saved set to: {path}\")\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.set_mode","title":"<code>set_mode(mode)</code>","text":"<p>Set the app mode (edit or play).</p> <p>This only affects UI state - MIDI and audio continue in both modes.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if mode was set successfully</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def set_mode(self, mode: str) -&gt; bool:\n    \"\"\"\n    Set the app mode (edit or play).\n\n    This only affects UI state - MIDI and audio continue in both modes.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n\n    Returns:\n        True if mode was set successfully\n    \"\"\"\n    if mode not in (\"edit\", \"play\"):\n        logger.error(f\"Invalid mode: {mode}\")\n        return False\n\n    if self._mode == mode:\n        return True\n\n    # Update mode\n    self._mode = mode\n\n    # Notify observers (UIs will update)\n    self._notify_observers(AppEvent.MODE_CHANGED, mode=mode)\n\n    logger.info(f\"Switched to {mode} mode\")\n    return True\n</code></pre>"},{"location":"api/orchestration/orchestrator/#launchsampler.orchestration.orchestrator.Orchestrator.get_pad","title":"<code>get_pad(index)</code>","text":"<p>Get a pad by index (read-only access).</p> <p>This is a convenience method for EditorService compatibility. To modify pads, use EditorService methods which fire events.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Pad index (0-63)</p> required <p>Returns:</p> Type Description <p>Pad at the given index</p> Source code in <code>src/launchsampler/orchestration/orchestrator.py</code> <pre><code>def get_pad(self, index: int):\n    \"\"\"\n    Get a pad by index (read-only access).\n\n    This is a convenience method for EditorService compatibility.\n    To modify pads, use EditorService methods which fire events.\n\n    Args:\n        index: Pad index (0-63)\n\n    Returns:\n        Pad at the given index\n    \"\"\"\n    return self.launchpad.pads[index]\n</code></pre>"},{"location":"api/protocols/","title":"Protocols","text":"<p>Observer protocols and domain events</p> <p>Protocol definitions for domain-specific observer patterns and interfaces.</p> <p>This package contains protocols and events specific to the launchsampler domain: - Events: MIDI, playback, editing, selection, and application events - Observers: Protocols for components that react to these events</p> <p>For generic model management protocols (ModelEvent, ModelObserver, PersistenceService), see launchsampler.model_manager.protocols.</p>"},{"location":"api/protocols/#launchsampler.protocols.MidiEvent","title":"<code>MidiEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from MIDI controller input.</p>"},{"location":"api/protocols/#launchsampler.protocols.PlaybackEvent","title":"<code>PlaybackEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from audio playback engine.</p>"},{"location":"api/protocols/#launchsampler.protocols.EditEvent","title":"<code>EditEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events that occur during editing operations.</p> <p>These events represent PERSISTENT state changes (saved to disk). For ephemeral UI state (selection), see SelectionEvent.</p>"},{"location":"api/protocols/#launchsampler.protocols.SelectionEvent","title":"<code>SelectionEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events for pad selection changes (ephemeral UI state).</p> <p>Selection is UI-specific state that doesn't persist to disk. Different UIs can have independent selections.</p>"},{"location":"api/protocols/#launchsampler.protocols.AppEvent","title":"<code>AppEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from application lifecycle and state changes.</p>"},{"location":"api/protocols/#launchsampler.protocols.MidiObserver","title":"<code>MidiObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives MIDI controller events.</p> <p>This protocol allows loose coupling between the MIDI controller and components that need to react to MIDI input (e.g., UI feedback).</p>"},{"location":"api/protocols/#launchsampler.protocols.MidiObserver.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI controller events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The type of MIDI event</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Note <p>This is called from the MIDI polling thread, so implementations should be thread-safe and avoid blocking operations.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI controller events.\n\n    Args:\n        event: The type of MIDI event\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n\n    Note:\n        This is called from the MIDI polling thread, so implementations\n        should be thread-safe and avoid blocking operations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#launchsampler.protocols.StateObserver","title":"<code>StateObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives audio playback state change events.</p> <p>This protocol allows loose coupling between the audio engine and UI components. Any object implementing this protocol can observe state changes without tight coupling.</p>"},{"location":"api/protocols/#launchsampler.protocols.StateObserver.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback state changes.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The type of playback event</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad that changed state (0-63)</p> required Note <p>This may be called from the audio thread, so implementations should be thread-safe and avoid blocking operations.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback state changes.\n\n    Args:\n        event: The type of playback event\n        pad_index: Index of the pad that changed state (0-63)\n\n    Note:\n        This may be called from the audio thread, so implementations\n        should be thread-safe and avoid blocking operations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#launchsampler.protocols.EditObserver","title":"<code>EditObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives editing events.</p> <p>This protocol allows loose coupling between the editor service and components that need to react to edits (audio engine, UI, etc.).</p>"},{"location":"api/protocols/#launchsampler.protocols.EditObserver.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices (0-63)</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Threading <p>Called from the UI thread (Textual's main asyncio loop). Audio-related observers (e.g., Player) must ensure their engine methods are thread-safe (typically via locks).</p> Error Handling <p>Exceptions raised by observers are caught and logged by the EditorService. They do not propagate to the caller, ensuring one failing observer doesn't break others. Observers should not rely on exceptions for critical error signaling.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices (0-63)\n        pads: List of affected pad states (post-edit)\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Audio-related observers (e.g., Player) must ensure their\n        engine methods are thread-safe (typically via locks).\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        EditorService. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others. Observers should\n        not rely on exceptions for critical error signaling.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#launchsampler.protocols.SelectionObserver","title":"<code>SelectionObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives selection change events.</p> <p>This protocol separates ephemeral UI state (selection) from persistent data mutations (edits). Selection is UI-specific and doesn't affect audio engine or persistence layers.</p>"},{"location":"api/protocols/#launchsampler.protocols.SelectionObserver.on_selection_event","title":"<code>on_selection_event(event, pad_index)</code>","text":"<p>Handle selection change events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>SelectionEvent</code> <p>The type of selection event</p> required <code>pad_index</code> <code>Optional[int]</code> <p>Index of selected pad (0-63), or None if cleared</p> required Threading <p>Called from the UI thread (Textual's main asyncio loop). Implementations should be lightweight and non-blocking.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_selection_event(\n    self,\n    event: \"SelectionEvent\",\n    pad_index: Optional[int]\n) -&gt; None:\n    \"\"\"\n    Handle selection change events.\n\n    Args:\n        event: The type of selection event\n        pad_index: Index of selected pad (0-63), or None if cleared\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Implementations should be lightweight and non-blocking.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/#launchsampler.protocols.AppObserver","title":"<code>AppObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives application lifecycle events.</p> <p>This protocol allows loose coupling between the application core and UI/service components that need to react to app-level changes.</p>"},{"location":"api/protocols/#launchsampler.protocols.AppObserver.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data (e.g., set_name, mode, etc.)</p> <code>{}</code> Threading <p>Called from the UI thread (Textual's main asyncio loop). Implementations should avoid blocking operations.</p> Error Handling <p>Exceptions raised by observers are caught and logged by the application. They do not propagate to the caller, ensuring one failing observer doesn't break others.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_app_event(self, event: \"AppEvent\", **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data (e.g., set_name, mode, etc.)\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Implementations should avoid blocking operations.\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        application. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/events/","title":"Events","text":""},{"location":"api/protocols/events/#launchsampler.protocols.events","title":"<code>events</code>","text":"<p>Domain events for observer pattern.</p> <p>This module defines events that can occur within the application: - MIDI events: Controller input events - Playback events: Audio playback state changes - Edit events: Persistent data mutations - Selection events: Ephemeral UI state changes - Application events: Lifecycle and state changes</p>"},{"location":"api/protocols/events/#launchsampler.protocols.events.MidiEvent","title":"<code>MidiEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from MIDI controller input.</p>"},{"location":"api/protocols/events/#launchsampler.protocols.events.PlaybackEvent","title":"<code>PlaybackEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from audio playback engine.</p>"},{"location":"api/protocols/events/#launchsampler.protocols.events.EditEvent","title":"<code>EditEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events that occur during editing operations.</p> <p>These events represent PERSISTENT state changes (saved to disk). For ephemeral UI state (selection), see SelectionEvent.</p>"},{"location":"api/protocols/events/#launchsampler.protocols.events.SelectionEvent","title":"<code>SelectionEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events for pad selection changes (ephemeral UI state).</p> <p>Selection is UI-specific state that doesn't persist to disk. Different UIs can have independent selections.</p>"},{"location":"api/protocols/events/#launchsampler.protocols.events.AppEvent","title":"<code>AppEvent</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Events from application lifecycle and state changes.</p>"},{"location":"api/protocols/observers/","title":"Observers","text":""},{"location":"api/protocols/observers/#launchsampler.protocols.observers","title":"<code>observers</code>","text":"<p>Observer protocol definitions for domain-specific events.</p> <p>This module contains observer protocols for the domain: - MIDI observers: React to MIDI controller input - State observers: React to playback state changes - Edit observers: React to editing operations - Selection observers: React to selection changes - App observers: React to application lifecycle events</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.MidiObserver","title":"<code>MidiObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives MIDI controller events.</p> <p>This protocol allows loose coupling between the MIDI controller and components that need to react to MIDI input (e.g., UI feedback).</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.MidiObserver.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI controller events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The type of MIDI event</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Note <p>This is called from the MIDI polling thread, so implementations should be thread-safe and avoid blocking operations.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI controller events.\n\n    Args:\n        event: The type of MIDI event\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n\n    Note:\n        This is called from the MIDI polling thread, so implementations\n        should be thread-safe and avoid blocking operations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.StateObserver","title":"<code>StateObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives audio playback state change events.</p> <p>This protocol allows loose coupling between the audio engine and UI components. Any object implementing this protocol can observe state changes without tight coupling.</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.StateObserver.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback state changes.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The type of playback event</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad that changed state (0-63)</p> required Note <p>This may be called from the audio thread, so implementations should be thread-safe and avoid blocking operations.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback state changes.\n\n    Args:\n        event: The type of playback event\n        pad_index: Index of the pad that changed state (0-63)\n\n    Note:\n        This may be called from the audio thread, so implementations\n        should be thread-safe and avoid blocking operations.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.EditObserver","title":"<code>EditObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives editing events.</p> <p>This protocol allows loose coupling between the editor service and components that need to react to edits (audio engine, UI, etc.).</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.EditObserver.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices (0-63)</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Threading <p>Called from the UI thread (Textual's main asyncio loop). Audio-related observers (e.g., Player) must ensure their engine methods are thread-safe (typically via locks).</p> Error Handling <p>Exceptions raised by observers are caught and logged by the EditorService. They do not propagate to the caller, ensuring one failing observer doesn't break others. Observers should not rely on exceptions for critical error signaling.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices (0-63)\n        pads: List of affected pad states (post-edit)\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Audio-related observers (e.g., Player) must ensure their\n        engine methods are thread-safe (typically via locks).\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        EditorService. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others. Observers should\n        not rely on exceptions for critical error signaling.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.SelectionObserver","title":"<code>SelectionObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives selection change events.</p> <p>This protocol separates ephemeral UI state (selection) from persistent data mutations (edits). Selection is UI-specific and doesn't affect audio engine or persistence layers.</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.SelectionObserver.on_selection_event","title":"<code>on_selection_event(event, pad_index)</code>","text":"<p>Handle selection change events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>SelectionEvent</code> <p>The type of selection event</p> required <code>pad_index</code> <code>Optional[int]</code> <p>Index of selected pad (0-63), or None if cleared</p> required Threading <p>Called from the UI thread (Textual's main asyncio loop). Implementations should be lightweight and non-blocking.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_selection_event(\n    self,\n    event: \"SelectionEvent\",\n    pad_index: Optional[int]\n) -&gt; None:\n    \"\"\"\n    Handle selection change events.\n\n    Args:\n        event: The type of selection event\n        pad_index: Index of selected pad (0-63), or None if cleared\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Implementations should be lightweight and non-blocking.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.AppObserver","title":"<code>AppObserver</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Observer that receives application lifecycle events.</p> <p>This protocol allows loose coupling between the application core and UI/service components that need to react to app-level changes.</p>"},{"location":"api/protocols/observers/#launchsampler.protocols.observers.AppObserver.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data (e.g., set_name, mode, etc.)</p> <code>{}</code> Threading <p>Called from the UI thread (Textual's main asyncio loop). Implementations should avoid blocking operations.</p> Error Handling <p>Exceptions raised by observers are caught and logged by the application. They do not propagate to the caller, ensuring one failing observer doesn't break others.</p> Source code in <code>src/launchsampler/protocols/observers.py</code> <pre><code>def on_app_event(self, event: \"AppEvent\", **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data (e.g., set_name, mode, etc.)\n\n    Threading:\n        Called from the UI thread (Textual's main asyncio loop).\n        Implementations should avoid blocking operations.\n\n    Error Handling:\n        Exceptions raised by observers are caught and logged by the\n        application. They do not propagate to the caller, ensuring\n        one failing observer doesn't break others.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/services/","title":"Services","text":"<p>Business logic services</p> <p>Generic services for LaunchSampler (not TUI-specific).</p>"},{"location":"api/services/#launchsampler.services.EditorService","title":"<code>EditorService(config)</code>","text":"<p>Manages editing operations on a Launchpad configuration.</p> <p>This service encapsulates all business logic for editing pads, managing samples, and saving/loading sets. It operates directly on a Launchpad instance, with no dependency on the full app.</p> Event-Driven Architecture <p>All editing operations emit EditEvent notifications to registered observers. This ensures automatic synchronization of audio engine and UI without manual coordination.</p> Threading <p>All methods are called from the UI thread (Textual's main loop). Observer notifications are also dispatched on the UI thread. The _event_lock protects the observer list during registration, but is released before calling observers to avoid holding locks during potentially slow callbacks.</p> Dependency Injection <p>EditorService receives a Launchpad reference, not the entire app. This eliminates circular dependencies and improves testability.</p> <p>Initialize the editor service.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the editor service.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self._launchpad = None\n    self.config = config\n    self._clipboard: Optional[Pad] = None\n\n    # Event system\n    self._observers = ObserverManager[EditObserver](observer_type_name=\"edit\")\n    logger.info(\"EditorService initialized\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>Get the launchpad being edited.</p>"},{"location":"api/services/#launchsampler.services.EditorService.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get the total number of pads in the launchpad grid.</p>"},{"location":"api/services/#launchsampler.services.EditorService.has_clipboard","title":"<code>has_clipboard</code>  <code>property</code>","text":"<p>Check if clipboard has content.</p>"},{"location":"api/services/#launchsampler.services.EditorService.update_launchpad","title":"<code>update_launchpad(launchpad)</code>","text":"<p>Update the launchpad reference.</p> <p>This should be called when a new set is mounted to ensure the editor is working with the correct launchpad instance.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The new Launchpad instance to edit</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def update_launchpad(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Update the launchpad reference.\n\n    This should be called when a new set is mounted to ensure\n    the editor is working with the correct launchpad instance.\n\n    Args:\n        launchpad: The new Launchpad instance to edit\n    \"\"\"\n    self._launchpad = launchpad\n    logger.debug(\"EditorService launchpad reference updated\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive edit events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Object implementing EditObserver protocol</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def register_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive edit events.\n\n    Args:\n        observer: Object implementing EditObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def unregister_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.get_pad","title":"<code>get_pad(pad_index)</code>","text":"<p>Get a pad by index (read-only).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def get_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Get a pad by index (read-only).\n\n    Args:\n        pad_index: Index of pad to get\n\n    Returns:\n        The Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    return self.launchpad.pads[pad_index]\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.assign_sample","title":"<code>assign_sample(pad_index, sample_path)</code>","text":"<p>Assign a sample to a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to assign to</p> required <code>sample_path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If sample file doesn't exist</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def assign_sample(self, pad_index: int, sample_path: Path) -&gt; Pad:\n    \"\"\"\n    Assign a sample to a pad.\n\n    Args:\n        pad_index: Index of pad to assign to\n        sample_path: Path to audio file\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If sample file doesn't exist\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not sample_path.exists():\n        raise ValueError(f\"Sample file not found: {sample_path}\")\n\n    # Create sample from file\n    sample = Sample.from_file(sample_path)\n\n    # Get pad and assign sample\n    pad = self.launchpad.pads[pad_index]\n    was_empty = not pad.is_assigned\n    pad.sample = sample\n    pad.volume = 0.8  # Default volume\n\n    # Set default color if pad was previously empty\n    if was_empty:\n        pad.color = MODE_COLORS[pad.mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [pad_index], [pad])\n\n    logger.info(f\"Assigned sample '{sample.name}' to pad {pad_index}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_pad","title":"<code>clear_pad(pad_index)</code>","text":"<p>Clear a pad (remove sample).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The new empty Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Clear a pad (remove sample).\n\n    Args:\n        pad_index: Index of pad to clear\n\n    Returns:\n        The new empty Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    # Get current pad position\n    old_pad = self.launchpad.pads[pad_index]\n\n    # Replace with empty pad\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cleared pad {pad_index}\")\n    return new_pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_pad_mode","title":"<code>set_pad_mode(pad_index, mode)</code>","text":"<p>Change the playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; Pad:\n    \"\"\"\n    Change the playback mode for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        mode: New playback mode\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot set mode on empty pad {pad_index}\")\n\n    pad.mode = mode\n    pad.color = MODE_COLORS[mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_MODE_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} mode to {mode.value}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_pad_volume","title":"<code>set_pad_volume(pad_index, volume)</code>","text":"<p>Set the volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If volume is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_volume(self, pad_index: int, volume: float) -&gt; Pad:\n    \"\"\"\n    Set the volume for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        volume: New volume (0.0-1.0)\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If volume is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not 0.0 &lt;= volume &lt;= 1.0:\n        raise ValueError(f\"Volume {volume} out of range (0.0-1.0)\")\n\n    pad = self.launchpad.pads[pad_index]\n    pad.volume = volume\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_VOLUME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} volume to {volume:.0%}\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.set_sample_name","title":"<code>set_sample_name(pad_index, name)</code>","text":"<p>Set the name for a pad's sample.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>name</code> <code>str</code> <p>New sample name</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned or name is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_sample_name(self, pad_index: int, name: str) -&gt; Pad:\n    \"\"\"\n    Set the name for a pad's sample.\n\n    Args:\n        pad_index: Index of pad to modify\n        name: New sample name\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned or name is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not name or not name.strip():\n        raise ValueError(\"Sample name cannot be empty\")\n\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned or not pad.sample:\n        raise ValueError(f\"Cannot set name on empty pad {pad_index}\")\n\n    pad.sample.name = name.strip()\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_NAME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} sample name to '{name}'\")\n    return pad\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.move_pad","title":"<code>move_pad(source_index, target_index, swap=False)</code>","text":"<p>Move a sample from source pad to target pad.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>swap</code> <code>bool</code> <p>If True, swap samples between pads. If False, overwrite target.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Pad, Pad]</code> <p>Tuple of (new source pad, new target pad)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def move_pad(self, source_index: int, target_index: int, swap: bool = False) -&gt; tuple[Pad, Pad]:\n    \"\"\"\n    Move a sample from source pad to target pad.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        swap: If True, swap samples between pads. If False, overwrite target.\n\n    Returns:\n        Tuple of (new source pad, new target pad)\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n    logger.info(f\"Moving sample from pad {source_index} to pad {target_index} (swap={swap})\")\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to move\")\n\n    if swap and target_pad.is_assigned:\n        # Swap samples between pads\n        # Store target pad data\n        target_sample = target_pad.sample\n        target_mode = target_pad.mode\n        target_volume = target_pad.volume\n        target_color = target_pad.color\n\n        # Move source to target\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Move target to source\n        source_pad.sample = target_sample\n        source_pad.mode = target_mode\n        source_pad.volume = target_volume\n        source_pad.color = target_color\n\n        logger.info(f\"Swapped pads {source_index} and {target_index}\")\n    else:\n        # Move/overwrite: copy source to target and clear source\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Clear source pad\n        source_pos = (source_pad.x, source_pad.y)\n        new_source = Pad.empty(source_pos[0], source_pos[1])\n        self.launchpad.pads[source_index] = new_source\n        source_pad = new_source\n\n        logger.info(f\"Moved sample from pad {source_index} to {target_index}\")\n\n    # Notify observers about both affected pads\n    self._notify_observers(\n        EditEvent.PAD_MOVED,\n        [source_index, target_index],\n        [source_pad, target_pad]\n    )\n\n    return (source_pad, target_pad)\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.duplicate_pad","title":"<code>duplicate_pad(source_index, target_index, overwrite=False)</code>","text":"<p>Duplicate a sample from source pad to target pad.</p> <p>Creates a complete deep copy of the source pad, preserving only the target's position. This ensures all properties are duplicated without needing to handle them individually.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty, indices are the same,        or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def duplicate_pad(self, source_index: int, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Duplicate a sample from source pad to target pad.\n\n    Creates a complete deep copy of the source pad, preserving only\n    the target's position. This ensures all properties are duplicated\n    without needing to handle them individually.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty, indices are the same,\n                   or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to copy\")\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with duplicate from pad {source_index} ('{source_pad.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Duplicated sample '{source_pad.sample.name}' from pad {source_index} to pad {target_index}\")\n\n    # Deep copy entire source pad but preserve target position\n    new_target = source_pad.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_DUPLICATED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.copy_pad","title":"<code>copy_pad(pad_index)</code>","text":"<p>Copy a pad to the clipboard buffer.</p> <p>Creates a deep copy of the pad and stores it in an internal buffer for later pasting.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to copy</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def copy_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Copy a pad to the clipboard buffer.\n\n    Creates a deep copy of the pad and stores it in an internal buffer\n    for later pasting.\n\n    Args:\n        pad_index: Index of pad to copy\n\n    Returns:\n        The copied Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot copy empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    logger.info(f\"Copied pad {pad_index} ('{pad.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.paste_pad","title":"<code>paste_pad(target_index, overwrite=False)</code>","text":"<p>Paste the clipboard buffer to a target pad.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of pad to paste to</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If target_index is out of range</p> <code>ValueError</code> <p>If clipboard is empty or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def paste_pad(self, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Paste the clipboard buffer to a target pad.\n\n    Args:\n        target_index: Index of pad to paste to\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If target_index is out of range\n        ValueError: If clipboard is empty or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(target_index, \"Target pad index\")\n\n    if self._clipboard is None:\n        raise ValueError(\"Clipboard is empty. Copy a pad first.\")\n\n    target_pad = self.launchpad.pads[target_index]\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with paste from clipboard ('{self._clipboard.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Pasted sample '{self._clipboard.sample.name}' from clipboard to pad {target_index}\")\n\n    # Deep copy clipboard to target, preserving target position\n    new_target = self._clipboard.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers (treat paste as assignment to target)\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.cut_pad","title":"<code>cut_pad(pad_index)</code>","text":"<p>Cut a pad to the clipboard buffer and clear the source.</p> <p>Atomically copies the pad to clipboard and clears the source pad. This is equivalent to copy_pad() followed by clear_pad().</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to cut</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad (now in clipboard)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def cut_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Cut a pad to the clipboard buffer and clear the source.\n\n    Atomically copies the pad to clipboard and clears the source pad.\n    This is equivalent to copy_pad() followed by clear_pad().\n\n    Args:\n        pad_index: Index of pad to cut\n\n    Returns:\n        The copied Pad (now in clipboard)\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot cut empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    # Clear the source pad\n    old_pad = self.launchpad.pads[pad_index]\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers (source pad is now cleared)\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cut pad {pad_index} ('{self._clipboard.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads in the launchpad.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_all(self) -&gt; int:\n    \"\"\"\n    Clear all pads in the launchpad.\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    \"\"\"\n    cleared_count = 0\n    for i in range(self.grid_size):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared all pads ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/#launchsampler.services.EditorService.clear_range","title":"<code>clear_range(start_index, end_index)</code>","text":"<p>Clear a range of pads.</p> <p>Parameters:</p> Name Type Description Default <code>start_index</code> <code>int</code> <p>First pad index (inclusive)</p> required <code>end_index</code> <code>int</code> <p>Last pad index (inclusive)</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If start_index or end_index is out of range</p> <code>ValueError</code> <p>If start_index &gt; end_index</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_range(self, start_index: int, end_index: int) -&gt; int:\n    \"\"\"\n    Clear a range of pads.\n\n    Args:\n        start_index: First pad index (inclusive)\n        end_index: Last pad index (inclusive)\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    Raises:\n        IndexError: If start_index or end_index is out of range\n        ValueError: If start_index &gt; end_index\n    \"\"\"\n    self._validate_pad_index(start_index, \"Start pad index\")\n    self._validate_pad_index(end_index, \"End pad index\")\n\n    if start_index &gt; end_index:\n        raise ValueError(f\"Start index {start_index} must be &lt;= end index {end_index}\")\n\n    cleared_count = 0\n    for i in range(start_index, end_index + 1):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared pads {start_index}-{end_index} ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService","title":"<code>SetManagerService(config)</code>","text":"<p>Handles set persistence and creation operations.</p> <p>This service is responsible for: - Opening existing sets from files - Creating new sets from sample directories - Saving sets to files - Managing set file paths and naming</p> <p>The service is stateless - it operates on Set objects passed to it and returns new Set objects, without storing any state internally.</p> <p>Initialize the SetManagerService.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the SetManagerService.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self.config = config\n    logger.info(\"SetManagerService initialized\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.open_set","title":"<code>open_set(path)</code>","text":"<p>Open an existing set from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the set file (.json)</p> required <p>Returns:</p> Type Description <code>Set</code> <p>Loaded Set object</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file is invalid or corrupted</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set(self, path: Path) -&gt; Set:\n    \"\"\"\n    Open an existing set from a JSON file.\n\n    Args:\n        path: Path to the set file (.json)\n\n    Returns:\n        Loaded Set object\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is invalid or corrupted\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Set file not found: {path}\")\n\n    try:\n        set_obj = self._load_set_from_file(path)\n        logger.info(f\"Opened set '{set_obj.name}' from {path}\")\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error opening set from {path}: {e}\")\n        raise ValueError(f\"Failed to open set: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.open_set_by_name","title":"<code>open_set_by_name(name)</code>","text":"<p>Open an existing set by name from the configured sets directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the set (without .json extension)</p> required <p>Returns:</p> Type Description <code>Optional[Set]</code> <p>Loaded Set object, or None if not found or error occurred</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set_by_name(self, name: str) -&gt; Optional[Set]:\n    \"\"\"\n    Open an existing set by name from the configured sets directory.\n\n    Args:\n        name: Name of the set (without .json extension)\n\n    Returns:\n        Loaded Set object, or None if not found or error occurred\n    \"\"\"\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    if not set_path.exists():\n        logger.warning(f\"Set file not found: {set_path}\")\n        return None\n\n    try:\n        return self.open_set(set_path)\n    except ValueError as e:\n        logger.error(f\"Error opening set '{name}': {e}\")\n        return None\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.create_from_directory","title":"<code>create_from_directory(samples_dir, name=None)</code>","text":"<p>Create a new set from samples in a directory.</p> <p>Scans the directory for supported audio files and creates a set with samples auto-assigned to pads.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing sample files</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name for the set (defaults to directory name)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>New Set object with samples loaded</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If directory doesn't exist or contains no valid samples</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_from_directory(self, samples_dir: Path, name: Optional[str] = None) -&gt; Set:\n    \"\"\"\n    Create a new set from samples in a directory.\n\n    Scans the directory for supported audio files and creates a set\n    with samples auto-assigned to pads.\n\n    Args:\n        samples_dir: Directory containing sample files\n        name: Optional name for the set (defaults to directory name)\n\n    Returns:\n        New Set object with samples loaded\n\n    Raises:\n        ValueError: If directory doesn't exist or contains no valid samples\n    \"\"\"\n    if not samples_dir.exists() or not samples_dir.is_dir():\n        raise ValueError(f\"Invalid samples directory: {samples_dir}\")\n\n    set_name = name or samples_dir.name\n\n    try:\n        set_obj = Set.from_sample_directory(\n            samples_dir=samples_dir,\n            name=set_name,\n            auto_configure=True\n        )\n        logger.info(\n            f\"Created set '{set_name}' with {len(set_obj.launchpad.assigned_pads)} \"\n            f\"samples from {samples_dir}\"\n        )\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error creating set from {samples_dir}: {e}\")\n        raise ValueError(f\"Failed to create set from directory: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.save_set","title":"<code>save_set(set_obj, path, new_name=None)</code>","text":"<p>Save a set to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>path</code> <code>Path</code> <p>Path where the set should be saved (.json)</p> required <code>new_name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>The saved Set object (with updated name if provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set(\n    self,\n    set_obj: Set,\n    path: Path,\n    new_name: Optional[str] = None\n) -&gt; Set:\n    \"\"\"\n    Save a set to a JSON file.\n\n    Args:\n        set_obj: The Set object to save\n        path: Path where the set should be saved (.json)\n        new_name: Optional new name for the set\n\n    Returns:\n        The saved Set object (with updated name if provided)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    try:\n        # Update name if provided\n        if new_name and set_obj.name != new_name:\n            set_obj = Set(\n                name=new_name,\n                launchpad=set_obj.launchpad,\n                samples_root=set_obj.samples_root,\n                created_at=set_obj.created_at,\n                modified_at=set_obj.modified_at\n            )\n\n        # Save the set (using internal implementation that creates parent directories)\n        saved_set = self._save_set_to_file(set_obj, path)\n\n        logger.info(f\"Saved set '{saved_set.name}' to {path}\")\n        return saved_set\n    except Exception as e:\n        logger.error(f\"Error saving set to {path}: {e}\")\n        raise ValueError(f\"Failed to save set: {e}\") from e\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.save_set_to_library","title":"<code>save_set_to_library(set_obj, filename=None)</code>","text":"<p>Save a set to the configured sets library directory.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional filename (without .json extension).      Defaults to set_obj.name</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Set, Path]</code> <p>Tuple of (saved Set object, path where it was saved)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set_to_library(\n    self,\n    set_obj: Set,\n    filename: Optional[str] = None\n) -&gt; tuple[Set, Path]:\n    \"\"\"\n    Save a set to the configured sets library directory.\n\n    Args:\n        set_obj: The Set object to save\n        filename: Optional filename (without .json extension).\n                 Defaults to set_obj.name\n\n    Returns:\n        Tuple of (saved Set object, path where it was saved)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    name = filename or set_obj.name\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    saved_set = self.save_set(set_obj, set_path)\n    return saved_set, set_path\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.create_empty","title":"<code>create_empty(name='Untitled')</code>","text":"<p>Create a new empty set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new set</p> <code>'Untitled'</code> <p>Returns:</p> Type Description <code>Set</code> <p>New empty Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_empty(self, name: str = \"Untitled\") -&gt; Set:\n    \"\"\"\n    Create a new empty set.\n\n    Args:\n        name: Name for the new set\n\n    Returns:\n        New empty Set object\n    \"\"\"\n    set_obj = Set.create_empty(name)\n    logger.info(f\"Created empty set '{name}'\")\n    return set_obj\n</code></pre>"},{"location":"api/services/#launchsampler.services.SetManagerService.load_set","title":"<code>load_set(set_name=None, samples_dir=None)</code>","text":"<p>Load a set with smart fallback logic.</p> <p>This handles the I/O operation of loading a Set from various sources (disk, directory, or creating empty). The returned Set object can then be mounted into the application.</p> <p>Priority order: 1. Load from samples directory (if provided) 2. Load from saved set file by name 3. Create empty set as fallback</p> <p>Parameters:</p> Name Type Description Default <code>set_name</code> <code>Optional[str]</code> <p>Name of set to load (defaults to \"Untitled\")</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Directory to load samples from (highest priority)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>Tuple of (loaded Set object, was_auto_created flag)</p> <code>bool</code> <p>was_auto_created is True when set file didn't exist and empty set was created</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def load_set(\n    self,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None\n) -&gt; tuple[Set, bool]:\n    \"\"\"\n    Load a set with smart fallback logic.\n\n    This handles the I/O operation of loading a Set from various sources\n    (disk, directory, or creating empty). The returned Set object can then\n    be mounted into the application.\n\n    Priority order:\n    1. Load from samples directory (if provided)\n    2. Load from saved set file by name\n    3. Create empty set as fallback\n\n    Args:\n        set_name: Name of set to load (defaults to \"Untitled\")\n        samples_dir: Directory to load samples from (highest priority)\n\n    Returns:\n        Tuple of (loaded Set object, was_auto_created flag)\n        was_auto_created is True when set file didn't exist and empty set was created\n    \"\"\"\n    name = set_name or \"Untitled\"\n\n    # Priority 1: Load from samples directory\n    if samples_dir:\n        try:\n            loaded_set = self.create_from_directory(samples_dir, name)\n            logger.info(f\"Loaded initial set from samples directory: {samples_dir}\")\n            return loaded_set, False\n        except ValueError as e:\n            logger.error(f\"Failed to load from samples directory: {e}\")\n            # Fall through to next priority\n\n    # Priority 2: Load from saved set file\n    if name and name.lower() != \"untitled\":\n        loaded_set = self.open_set_by_name(name)\n        if loaded_set:\n            logger.info(f\"Loaded initial set from saved file: {name}\")\n            return loaded_set, False\n        else:\n            logger.warning(f\"Set '{name}' not found, creating empty set\")\n            # Fallback: auto-create empty set\n            logger.info(f\"Creating empty set '{name}'\")\n            return self.create_empty(name), True\n\n    # Fallback: empty set (intentional \"Untitled\" case, not auto-created)\n    logger.info(f\"Creating empty set '{name}'\")\n    return self.create_empty(name), False\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService","title":"<code>ModelManagerService(model_type, initial_model, default_path=None)</code>","text":"<p>               Bases: <code>Generic[ModelType]</code></p> <p>Generic service for managing Pydantic-based models.</p> <p>This service provides a centralized way to manage any Pydantic model (AppConfig, Set, or other models) with get/set operations, persistence, and event notifications.</p> Design Philosophy <ul> <li>Generic: Works with ANY Pydantic BaseModel subclass</li> <li>Type-safe: Full type hinting and validation via Pydantic</li> <li>Observable: Emits events for all model changes</li> <li>Thread-safe: Protected by locks for concurrent access</li> <li>Single responsibility: Only handles model state management</li> </ul> Event-Driven Architecture <p>All model operations emit ModelEvent notifications to registered observers. This ensures automatic synchronization of dependent components without manual coordination.</p> Threading <p>All public methods are thread-safe. The _lock protects model state during reads/writes. The lock is released before notifying observers to prevent deadlocks (same pattern as other services).</p> Usage Example <pre><code># Create service with AppConfig\nconfig = AppConfig.load_or_default()\nservice = ModelManagerService[AppConfig](AppConfig, config)\n\n# Register observers\nservice.register_observer(my_observer)\n\n# Get values\nauto_save = service.get(\"auto_save\")\n\n# Set values\nservice.set(\"auto_save\", False)\n\n# Save to disk\nservice.save()\n</code></pre> <p>Initialize the model manager service.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>Type[ModelType]</code> <p>The Pydantic model class (e.g., AppConfig, Set)</p> required <code>initial_model</code> <code>ModelType</code> <p>The initial model instance</p> required <code>default_path</code> <code>Optional[Path]</code> <p>Default path for save/load operations (optional)</p> <code>None</code> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def __init__(\n    self,\n    model_type: Type[ModelType],\n    initial_model: ModelType,\n    default_path: Optional[Path] = None\n):\n    \"\"\"\n    Initialize the model manager service.\n\n    Args:\n        model_type: The Pydantic model class (e.g., AppConfig, Set)\n        initial_model: The initial model instance\n        default_path: Default path for save/load operations (optional)\n    \"\"\"\n    self._model_type = model_type\n    self._model = initial_model\n    self._default_path = default_path\n    self._lock = Lock()\n\n    # Event system\n    self._observers = ObserverManager[ModelObserver](\n        lock=self._lock,\n        observer_type_name=\"model\"\n    )\n\n    logger.info(f\"ModelManagerService initialized with {model_type.__name__}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive model change events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Object implementing ModelObserver protocol</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def register_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive model change events.\n\n    Args:\n        observer: Object implementing ModelObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>ModelObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def unregister_observer(self, observer: ModelObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.get","title":"<code>get(key, default=None)</code>","text":"<p>Get a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>default</code> <code>Any</code> <p>Default value if key doesn't exist</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The field value, or default if key doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Example <pre><code>auto_save = service.get(\"auto_save\")\nbuffer_size = service.get(\"default_buffer_size\", 512)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"\n    Get a model field value by key.\n\n    Args:\n        key: Model field name\n        default: Default value if key doesn't exist\n\n    Returns:\n        The field value, or default if key doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Example:\n        ```python\n        auto_save = service.get(\"auto_save\")\n        buffer_size = service.get(\"default_buffer_size\", 512)\n        ```\n    \"\"\"\n    with self._lock:\n        return getattr(self._model, key, default)\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.get_all","title":"<code>get_all()</code>","text":"<p>Get all model field values as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary of all model field names and values</p> Thread-Safety <p>This method is thread-safe. Returns a snapshot of model state.</p> Example <pre><code>all_fields = service.get_all()\nprint(f\"Sets directory: {all_fields['sets_dir']}\")\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_all(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get all model field values as a dictionary.\n\n    Returns:\n        Dictionary of all model field names and values\n\n    Thread-Safety:\n        This method is thread-safe. Returns a snapshot of model state.\n\n    Example:\n        ```python\n        all_fields = service.get_all()\n        print(f\"Sets directory: {all_fields['sets_dir']}\")\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_dump()\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.get_model","title":"<code>get_model()</code>","text":"<p>Get a copy of the entire model object.</p> <p>Returns:</p> Type Description <code>ModelType</code> <p>Deep copy of the current model</p> Thread-Safety <p>This method is thread-safe. Returns a deep copy to prevent external mutation.</p> Example <pre><code>model_copy = service.get_model()\n# Safe to modify model_copy without affecting service state\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def get_model(self) -&gt; ModelType:\n    \"\"\"\n    Get a copy of the entire model object.\n\n    Returns:\n        Deep copy of the current model\n\n    Thread-Safety:\n        This method is thread-safe. Returns a deep copy to prevent\n        external mutation.\n\n    Example:\n        ```python\n        model_copy = service.get_model()\n        # Safe to modify model_copy without affecting service state\n        ```\n    \"\"\"\n    with self._lock:\n        return self._model.model_copy(deep=True)\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.set","title":"<code>set(key, value)</code>","text":"<p>Set a model field value by key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Model field name</p> required <code>value</code> <code>Any</code> <p>New value (must be valid for the field type)</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If key doesn't exist in model</p> <code>ValidationError</code> <p>If value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. Model state is protected by lock.</p> Events <p>Emits MODEL_UPDATED with keys=[key], values={key: value}</p> Example <pre><code>service.set(\"auto_save\", False)\nservice.set(\"default_buffer_size\", 1024)\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Set a model field value by key.\n\n    Args:\n        key: Model field name\n        value: New value (must be valid for the field type)\n\n    Raises:\n        AttributeError: If key doesn't exist in model\n        ValidationError: If value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. Model state is protected by lock.\n\n    Events:\n        Emits MODEL_UPDATED with keys=[key], values={key: value}\n\n    Example:\n        ```python\n        service.set(\"auto_save\", False)\n        service.set(\"default_buffer_size\", 1024)\n        ```\n    \"\"\"\n    with self._lock:\n        if not hasattr(self._model, key):\n            raise AttributeError(\n                f\"'{self._model_type.__name__}' has no field '{key}'\"\n            )\n\n        # Validate by reconstructing the model (Pydantic 2.x doesn't validate on setattr/model_copy)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict[key] = value\n            self._model = self._model_type.model_validate(current_dict)\n            updated_values = {key: value}\n        except ValidationError as e:\n            logger.error(f\"Validation error setting {key}={value}: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=[key],\n        values=updated_values\n    )\n\n    logger.debug(f\"Model updated: {key}={value}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.update","title":"<code>update(values)</code>","text":"<p>Update multiple model field values at once.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>dict[str, Any]</code> <p>Dictionary of field names and values to update</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If any key doesn't exist in model</p> <code>ValidationError</code> <p>If any value fails Pydantic validation</p> Thread-Safety <p>This method is thread-safe. All updates are atomic.</p> Events <p>Emits single MODEL_UPDATED event with all changed keys/values</p> Example <pre><code>service.update({\n    \"auto_save\": False,\n    \"default_buffer_size\": 1024,\n    \"midi_poll_interval\": 1.0\n})\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def update(self, values: dict[str, Any]) -&gt; None:\n    \"\"\"\n    Update multiple model field values at once.\n\n    Args:\n        values: Dictionary of field names and values to update\n\n    Raises:\n        AttributeError: If any key doesn't exist in model\n        ValidationError: If any value fails Pydantic validation\n\n    Thread-Safety:\n        This method is thread-safe. All updates are atomic.\n\n    Events:\n        Emits single MODEL_UPDATED event with all changed keys/values\n\n    Example:\n        ```python\n        service.update({\n            \"auto_save\": False,\n            \"default_buffer_size\": 1024,\n            \"midi_poll_interval\": 1.0\n        })\n        ```\n    \"\"\"\n    with self._lock:\n        # Validate all keys exist first\n        for key in values:\n            if not hasattr(self._model, key):\n                raise AttributeError(\n                    f\"'{self._model_type.__name__}' has no field '{key}'\"\n                )\n\n        # Apply all updates with validation (atomic - all or nothing)\n        try:\n            current_dict = self._model.model_dump()\n            current_dict.update(values)\n            self._model = self._model_type.model_validate(current_dict)\n        except ValidationError as e:\n            logger.error(f\"Validation error during batch update: {e}\")\n            raise\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_UPDATED,\n        keys=list(values.keys()),\n        values=values\n    )\n\n    logger.debug(f\"Model batch updated: {list(values.keys())}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.reset","title":"<code>reset()</code>","text":"<p>Reset model to default values.</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_RESET with the new default model</p> Example <pre><code>service.reset()\n# All model field values are now back to defaults\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Reset model to default values.\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_RESET with the new default model\n\n    Example:\n        ```python\n        service.reset()\n        # All model field values are now back to defaults\n        ```\n    \"\"\"\n    with self._lock:\n        # Create new default instance\n        self._model = self._model_type()\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_RESET,\n        model=self._model.model_copy(deep=True)\n    )\n\n    logger.info(f\"Model reset to defaults: {self._model_type.__name__}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.load","title":"<code>load(path=None)</code>","text":"<p>Load model from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Thread-Safety <p>This method is thread-safe. Model replacement is atomic.</p> Events <p>Emits MODEL_LOADED with the file path</p> Example <pre><code>service.load(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.load()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def load(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Load model from file.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Thread-Safety:\n        This method is thread-safe. Model replacement is atomic.\n\n    Events:\n        Emits MODEL_LOADED with the file path\n\n    Example:\n        ```python\n        service.load(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.load()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    # Load and validate from file using shared utility\n    new_model = PydanticPersistence.load_json(file_path, self._model_type)\n\n    with self._lock:\n        self._model = new_model\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_LOADED,\n        path=file_path\n    )\n\n    logger.info(f\"Model loaded from {file_path}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.save","title":"<code>save(path=None)</code>","text":"<p>Save model to file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to save model to (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> Thread-Safety <p>This method is thread-safe. Model is read under lock.</p> Events <p>Emits MODEL_SAVED with the file path</p> Example <pre><code>service.save(Path(\"~/.launchsampler/config.json\"))\n# or use default path:\nservice.save()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def save(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Save model to file.\n\n    Args:\n        path: Path to save model to (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n\n    Thread-Safety:\n        This method is thread-safe. Model is read under lock.\n\n    Events:\n        Emits MODEL_SAVED with the file path\n\n    Example:\n        ```python\n        service.save(Path(\"~/.launchsampler/config.json\"))\n        # or use default path:\n        service.save()\n        ```\n    \"\"\"\n    file_path = path or self._default_path\n    if file_path is None:\n        raise ValueError(\"No path specified and no default_path set\")\n\n    file_path = Path(file_path)\n\n    # Get model copy while holding lock\n    with self._lock:\n        model_copy = self._model.model_copy(deep=True)\n\n    # Write to file using shared utility (outside lock - I/O can be slow)\n    PydanticPersistence.save_json(model_copy, file_path)\n\n    # Notify observers (outside lock)\n    self._notify_observers(\n        ModelEvent.MODEL_SAVED,\n        path=file_path\n    )\n\n    logger.info(f\"Model saved to {file_path}\")\n</code></pre>"},{"location":"api/services/#launchsampler.services.ModelManagerService.reload","title":"<code>reload(path=None)</code>","text":"<p>Reload model from file (convenience method).</p> <p>This is equivalent to calling load() but provides clearer intent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[Path]</code> <p>Path to model file (uses default_path if None)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no path specified and no default_path set</p> <code>ValidationError</code> <p>If model file has invalid values</p> <code>FileNotFoundError</code> <p>If model file doesn't exist</p> Example <pre><code># Reload from disk (discard in-memory changes)\nservice.reload()\n</code></pre> Source code in <code>src/launchsampler/model_manager/service.py</code> <pre><code>def reload(self, path: Optional[Path] = None) -&gt; None:\n    \"\"\"\n    Reload model from file (convenience method).\n\n    This is equivalent to calling load() but provides clearer intent.\n\n    Args:\n        path: Path to model file (uses default_path if None)\n\n    Raises:\n        ValueError: If no path specified and no default_path set\n        ValidationError: If model file has invalid values\n        FileNotFoundError: If model file doesn't exist\n\n    Example:\n        ```python\n        # Reload from disk (discard in-memory changes)\n        service.reload()\n        ```\n    \"\"\"\n    self.load(path)\n</code></pre>"},{"location":"api/services/editor_service/","title":"Editor Service","text":""},{"location":"api/services/editor_service/#launchsampler.services.editor_service","title":"<code>editor_service</code>","text":"<p>Editor service for managing Launchpad editing operations.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService","title":"<code>EditorService(config)</code>","text":"<p>Manages editing operations on a Launchpad configuration.</p> <p>This service encapsulates all business logic for editing pads, managing samples, and saving/loading sets. It operates directly on a Launchpad instance, with no dependency on the full app.</p> Event-Driven Architecture <p>All editing operations emit EditEvent notifications to registered observers. This ensures automatic synchronization of audio engine and UI without manual coordination.</p> Threading <p>All methods are called from the UI thread (Textual's main loop). Observer notifications are also dispatched on the UI thread. The _event_lock protects the observer list during registration, but is released before calling observers to avoid holding locks during potentially slow callbacks.</p> Dependency Injection <p>EditorService receives a Launchpad reference, not the entire app. This eliminates circular dependencies and improves testability.</p> <p>Initialize the editor service.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the editor service.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self._launchpad = None\n    self.config = config\n    self._clipboard: Optional[Pad] = None\n\n    # Event system\n    self._observers = ObserverManager[EditObserver](observer_type_name=\"edit\")\n    logger.info(\"EditorService initialized\")\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>Get the launchpad being edited.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.grid_size","title":"<code>grid_size</code>  <code>property</code>","text":"<p>Get the total number of pads in the launchpad grid.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.has_clipboard","title":"<code>has_clipboard</code>  <code>property</code>","text":"<p>Check if clipboard has content.</p>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.update_launchpad","title":"<code>update_launchpad(launchpad)</code>","text":"<p>Update the launchpad reference.</p> <p>This should be called when a new set is mounted to ensure the editor is working with the correct launchpad instance.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The new Launchpad instance to edit</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def update_launchpad(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Update the launchpad reference.\n\n    This should be called when a new set is mounted to ensure\n    the editor is working with the correct launchpad instance.\n\n    Args:\n        launchpad: The new Launchpad instance to edit\n    \"\"\"\n    self._launchpad = launchpad\n    logger.debug(\"EditorService launchpad reference updated\")\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to receive edit events.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Object implementing EditObserver protocol</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def register_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Register an observer to receive edit events.\n\n    Args:\n        observer: Object implementing EditObserver protocol\n    \"\"\"\n    self._observers.register(observer)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.unregister_observer","title":"<code>unregister_observer(observer)</code>","text":"<p>Unregister an observer.</p> <p>Parameters:</p> Name Type Description Default <code>observer</code> <code>EditObserver</code> <p>Previously registered observer</p> required Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def unregister_observer(self, observer: EditObserver) -&gt; None:\n    \"\"\"\n    Unregister an observer.\n\n    Args:\n        observer: Previously registered observer\n    \"\"\"\n    self._observers.unregister(observer)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.get_pad","title":"<code>get_pad(pad_index)</code>","text":"<p>Get a pad by index (read-only).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to get</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def get_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Get a pad by index (read-only).\n\n    Args:\n        pad_index: Index of pad to get\n\n    Returns:\n        The Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    return self.launchpad.pads[pad_index]\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.assign_sample","title":"<code>assign_sample(pad_index, sample_path)</code>","text":"<p>Assign a sample to a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to assign to</p> required <code>sample_path</code> <code>Path</code> <p>Path to audio file</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If sample file doesn't exist</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def assign_sample(self, pad_index: int, sample_path: Path) -&gt; Pad:\n    \"\"\"\n    Assign a sample to a pad.\n\n    Args:\n        pad_index: Index of pad to assign to\n        sample_path: Path to audio file\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If sample file doesn't exist\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not sample_path.exists():\n        raise ValueError(f\"Sample file not found: {sample_path}\")\n\n    # Create sample from file\n    sample = Sample.from_file(sample_path)\n\n    # Get pad and assign sample\n    pad = self.launchpad.pads[pad_index]\n    was_empty = not pad.is_assigned\n    pad.sample = sample\n    pad.volume = 0.8  # Default volume\n\n    # Set default color if pad was previously empty\n    if was_empty:\n        pad.color = MODE_COLORS[pad.mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [pad_index], [pad])\n\n    logger.info(f\"Assigned sample '{sample.name}' to pad {pad_index}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_pad","title":"<code>clear_pad(pad_index)</code>","text":"<p>Clear a pad (remove sample).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The new empty Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Clear a pad (remove sample).\n\n    Args:\n        pad_index: Index of pad to clear\n\n    Returns:\n        The new empty Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    # Get current pad position\n    old_pad = self.launchpad.pads[pad_index]\n\n    # Replace with empty pad\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cleared pad {pad_index}\")\n    return new_pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_pad_mode","title":"<code>set_pad_mode(pad_index, mode)</code>","text":"<p>Change the playback mode for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>mode</code> <code>PlaybackMode</code> <p>New playback mode</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_mode(self, pad_index: int, mode: PlaybackMode) -&gt; Pad:\n    \"\"\"\n    Change the playback mode for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        mode: New playback mode\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot set mode on empty pad {pad_index}\")\n\n    pad.mode = mode\n    pad.color = MODE_COLORS[mode].rgb\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_MODE_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} mode to {mode.value}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_pad_volume","title":"<code>set_pad_volume(pad_index, volume)</code>","text":"<p>Set the volume for a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>volume</code> <code>float</code> <p>New volume (0.0-1.0)</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If volume is out of range</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_pad_volume(self, pad_index: int, volume: float) -&gt; Pad:\n    \"\"\"\n    Set the volume for a pad.\n\n    Args:\n        pad_index: Index of pad to modify\n        volume: New volume (0.0-1.0)\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If volume is out of range\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not 0.0 &lt;= volume &lt;= 1.0:\n        raise ValueError(f\"Volume {volume} out of range (0.0-1.0)\")\n\n    pad = self.launchpad.pads[pad_index]\n    pad.volume = volume\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_VOLUME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} volume to {volume:.0%}\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.set_sample_name","title":"<code>set_sample_name(pad_index, name)</code>","text":"<p>Set the name for a pad's sample.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to modify</p> required <code>name</code> <code>str</code> <p>New sample name</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The modified Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad has no sample assigned or name is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def set_sample_name(self, pad_index: int, name: str) -&gt; Pad:\n    \"\"\"\n    Set the name for a pad's sample.\n\n    Args:\n        pad_index: Index of pad to modify\n        name: New sample name\n\n    Returns:\n        The modified Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad has no sample assigned or name is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    if not name or not name.strip():\n        raise ValueError(\"Sample name cannot be empty\")\n\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned or not pad.sample:\n        raise ValueError(f\"Cannot set name on empty pad {pad_index}\")\n\n    pad.sample.name = name.strip()\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_NAME_CHANGED, [pad_index], [pad])\n\n    logger.info(f\"Set pad {pad_index} sample name to '{name}'\")\n    return pad\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.move_pad","title":"<code>move_pad(source_index, target_index, swap=False)</code>","text":"<p>Move a sample from source pad to target pad.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>swap</code> <code>bool</code> <p>If True, swap samples between pads. If False, overwrite target.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[Pad, Pad]</code> <p>Tuple of (new source pad, new target pad)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def move_pad(self, source_index: int, target_index: int, swap: bool = False) -&gt; tuple[Pad, Pad]:\n    \"\"\"\n    Move a sample from source pad to target pad.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        swap: If True, swap samples between pads. If False, overwrite target.\n\n    Returns:\n        Tuple of (new source pad, new target pad)\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n    logger.info(f\"Moving sample from pad {source_index} to pad {target_index} (swap={swap})\")\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to move\")\n\n    if swap and target_pad.is_assigned:\n        # Swap samples between pads\n        # Store target pad data\n        target_sample = target_pad.sample\n        target_mode = target_pad.mode\n        target_volume = target_pad.volume\n        target_color = target_pad.color\n\n        # Move source to target\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Move target to source\n        source_pad.sample = target_sample\n        source_pad.mode = target_mode\n        source_pad.volume = target_volume\n        source_pad.color = target_color\n\n        logger.info(f\"Swapped pads {source_index} and {target_index}\")\n    else:\n        # Move/overwrite: copy source to target and clear source\n        target_pad.sample = source_pad.sample\n        target_pad.mode = source_pad.mode\n        target_pad.volume = source_pad.volume\n        target_pad.color = source_pad.color\n\n        # Clear source pad\n        source_pos = (source_pad.x, source_pad.y)\n        new_source = Pad.empty(source_pos[0], source_pos[1])\n        self.launchpad.pads[source_index] = new_source\n        source_pad = new_source\n\n        logger.info(f\"Moved sample from pad {source_index} to {target_index}\")\n\n    # Notify observers about both affected pads\n    self._notify_observers(\n        EditEvent.PAD_MOVED,\n        [source_index, target_index],\n        [source_pad, target_pad]\n    )\n\n    return (source_pad, target_pad)\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.duplicate_pad","title":"<code>duplicate_pad(source_index, target_index, overwrite=False)</code>","text":"<p>Duplicate a sample from source pad to target pad.</p> <p>Creates a complete deep copy of the source pad, preserving only the target's position. This ensures all properties are duplicated without needing to handle them individually.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad indices are out of range</p> <code>ValueError</code> <p>If source pad is empty, indices are the same,        or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def duplicate_pad(self, source_index: int, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Duplicate a sample from source pad to target pad.\n\n    Creates a complete deep copy of the source pad, preserving only\n    the target's position. This ensures all properties are duplicated\n    without needing to handle them individually.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If pad indices are out of range\n        ValueError: If source pad is empty, indices are the same,\n                   or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(source_index, \"Source pad index\")\n    self._validate_pad_index(target_index, \"Target pad index\")\n    if source_index == target_index:\n        raise ValueError(\"Source and target pads must be different\")\n\n    source_pad = self.launchpad.pads[source_index]\n    target_pad = self.launchpad.pads[target_index]\n\n    if not source_pad.is_assigned:\n        raise ValueError(f\"Source pad {source_index} has no sample to copy\")\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with duplicate from pad {source_index} ('{source_pad.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Duplicated sample '{source_pad.sample.name}' from pad {source_index} to pad {target_index}\")\n\n    # Deep copy entire source pad but preserve target position\n    new_target = source_pad.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers\n    self._notify_observers(EditEvent.PAD_DUPLICATED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.copy_pad","title":"<code>copy_pad(pad_index)</code>","text":"<p>Copy a pad to the clipboard buffer.</p> <p>Creates a deep copy of the pad and stores it in an internal buffer for later pasting.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to copy</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def copy_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Copy a pad to the clipboard buffer.\n\n    Creates a deep copy of the pad and stores it in an internal buffer\n    for later pasting.\n\n    Args:\n        pad_index: Index of pad to copy\n\n    Returns:\n        The copied Pad\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot copy empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    logger.info(f\"Copied pad {pad_index} ('{pad.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.paste_pad","title":"<code>paste_pad(target_index, overwrite=False)</code>","text":"<p>Paste the clipboard buffer to a target pad.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of pad to paste to</p> required <code>overwrite</code> <code>bool</code> <p>If False (default), raise ValueError if target already has a sample.       If True, replace target pad contents even if occupied.</p> <code>False</code> <p>Returns:</p> Type Description <code>Pad</code> <p>The new target Pad</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If target_index is out of range</p> <code>ValueError</code> <p>If clipboard is empty or target is occupied and overwrite=False</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def paste_pad(self, target_index: int, overwrite: bool = False) -&gt; Pad:\n    \"\"\"\n    Paste the clipboard buffer to a target pad.\n\n    Args:\n        target_index: Index of pad to paste to\n        overwrite: If False (default), raise ValueError if target already has a sample.\n                  If True, replace target pad contents even if occupied.\n\n    Returns:\n        The new target Pad\n\n    Raises:\n        IndexError: If target_index is out of range\n        ValueError: If clipboard is empty or target is occupied and overwrite=False\n    \"\"\"\n    self._validate_pad_index(target_index, \"Target pad index\")\n\n    if self._clipboard is None:\n        raise ValueError(\"Clipboard is empty. Copy a pad first.\")\n\n    target_pad = self.launchpad.pads[target_index]\n\n    # Check if target is occupied and overwrite is disabled\n    if not overwrite and target_pad.is_assigned:\n        raise ValueError(\n            f\"Target pad {target_index} already has sample '{target_pad.sample.name}'\"\n        )\n\n    # Log if we're overwriting an existing sample\n    if target_pad.is_assigned:\n        logger.info(\n            f\"Overwriting pad {target_index} (was '{target_pad.sample.name}') \"\n            f\"with paste from clipboard ('{self._clipboard.sample.name}')\"\n        )\n    else:\n        logger.info(f\"Pasted sample '{self._clipboard.sample.name}' from clipboard to pad {target_index}\")\n\n    # Deep copy clipboard to target, preserving target position\n    new_target = self._clipboard.model_copy(deep=True, update={'x': target_pad.x, 'y': target_pad.y})\n    self.launchpad.pads[target_index] = new_target\n\n    # Notify observers (treat paste as assignment to target)\n    self._notify_observers(EditEvent.PAD_ASSIGNED, [target_index], [new_target])\n\n    return new_target\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.cut_pad","title":"<code>cut_pad(pad_index)</code>","text":"<p>Cut a pad to the clipboard buffer and clear the source.</p> <p>Atomically copies the pad to clipboard and clears the source pad. This is equivalent to copy_pad() followed by clear_pad().</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to cut</p> required <p>Returns:</p> Type Description <code>Pad</code> <p>The copied Pad (now in clipboard)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If pad_index is out of range</p> <code>ValueError</code> <p>If pad is empty</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def cut_pad(self, pad_index: int) -&gt; Pad:\n    \"\"\"\n    Cut a pad to the clipboard buffer and clear the source.\n\n    Atomically copies the pad to clipboard and clears the source pad.\n    This is equivalent to copy_pad() followed by clear_pad().\n\n    Args:\n        pad_index: Index of pad to cut\n\n    Returns:\n        The copied Pad (now in clipboard)\n\n    Raises:\n        IndexError: If pad_index is out of range\n        ValueError: If pad is empty\n    \"\"\"\n    self._validate_pad_index(pad_index)\n    pad = self.launchpad.pads[pad_index]\n\n    if not pad.is_assigned:\n        raise ValueError(f\"Cannot cut empty pad {pad_index}\")\n\n    # Deep copy the pad to clipboard\n    self._clipboard = pad.model_copy(deep=True)\n\n    # Clear the source pad\n    old_pad = self.launchpad.pads[pad_index]\n    new_pad = Pad.empty(old_pad.x, old_pad.y)\n    self.launchpad.pads[pad_index] = new_pad\n\n    # Notify observers (source pad is now cleared)\n    self._notify_observers(EditEvent.PAD_CLEARED, [pad_index], [new_pad])\n\n    logger.info(f\"Cut pad {pad_index} ('{self._clipboard.sample.name}') to clipboard\")\n    return self._clipboard\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_all","title":"<code>clear_all()</code>","text":"<p>Clear all pads in the launchpad.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_all(self) -&gt; int:\n    \"\"\"\n    Clear all pads in the launchpad.\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    \"\"\"\n    cleared_count = 0\n    for i in range(self.grid_size):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared all pads ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/editor_service/#launchsampler.services.editor_service.EditorService.clear_range","title":"<code>clear_range(start_index, end_index)</code>","text":"<p>Clear a range of pads.</p> <p>Parameters:</p> Name Type Description Default <code>start_index</code> <code>int</code> <p>First pad index (inclusive)</p> required <code>end_index</code> <code>int</code> <p>Last pad index (inclusive)</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of pads that were cleared (had samples)</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If start_index or end_index is out of range</p> <code>ValueError</code> <p>If start_index &gt; end_index</p> Source code in <code>src/launchsampler/services/editor_service.py</code> <pre><code>def clear_range(self, start_index: int, end_index: int) -&gt; int:\n    \"\"\"\n    Clear a range of pads.\n\n    Args:\n        start_index: First pad index (inclusive)\n        end_index: Last pad index (inclusive)\n\n    Returns:\n        Number of pads that were cleared (had samples)\n\n    Raises:\n        IndexError: If start_index or end_index is out of range\n        ValueError: If start_index &gt; end_index\n    \"\"\"\n    self._validate_pad_index(start_index, \"Start pad index\")\n    self._validate_pad_index(end_index, \"End pad index\")\n\n    if start_index &gt; end_index:\n        raise ValueError(f\"Start index {start_index} must be &lt;= end index {end_index}\")\n\n    cleared_count = 0\n    for i in range(start_index, end_index + 1):\n        pad = self.launchpad.pads[i]\n        if pad.is_assigned:\n            new_pad = Pad.empty(pad.x, pad.y)\n            self.launchpad.pads[i] = new_pad\n            cleared_count += 1\n\n    logger.info(f\"Cleared pads {start_index}-{end_index} ({cleared_count} pads had samples)\")\n    return cleared_count\n</code></pre>"},{"location":"api/services/set_manager_service/","title":"Set Manager Service","text":""},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service","title":"<code>set_manager_service</code>","text":"<p>Service for managing set persistence and loading.</p>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService","title":"<code>SetManagerService(config)</code>","text":"<p>Handles set persistence and creation operations.</p> <p>This service is responsible for: - Opening existing sets from files - Creating new sets from sample directories - Saving sets to files - Managing set file paths and naming</p> <p>The service is stateless - it operates on Set objects passed to it and returns new Set objects, without storing any state internally.</p> <p>Initialize the SetManagerService.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>AppConfig</code> <p>Application configuration</p> required Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def __init__(self, config: AppConfig):\n    \"\"\"\n    Initialize the SetManagerService.\n\n    Args:\n        config: Application configuration\n    \"\"\"\n    self.config = config\n    logger.info(\"SetManagerService initialized\")\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.open_set","title":"<code>open_set(path)</code>","text":"<p>Open an existing set from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the set file (.json)</p> required <p>Returns:</p> Type Description <code>Set</code> <p>Loaded Set object</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file doesn't exist</p> <code>ValueError</code> <p>If the file is invalid or corrupted</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set(self, path: Path) -&gt; Set:\n    \"\"\"\n    Open an existing set from a JSON file.\n\n    Args:\n        path: Path to the set file (.json)\n\n    Returns:\n        Loaded Set object\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is invalid or corrupted\n    \"\"\"\n    if not path.exists():\n        raise FileNotFoundError(f\"Set file not found: {path}\")\n\n    try:\n        set_obj = self._load_set_from_file(path)\n        logger.info(f\"Opened set '{set_obj.name}' from {path}\")\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error opening set from {path}: {e}\")\n        raise ValueError(f\"Failed to open set: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.open_set_by_name","title":"<code>open_set_by_name(name)</code>","text":"<p>Open an existing set by name from the configured sets directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the set (without .json extension)</p> required <p>Returns:</p> Type Description <code>Optional[Set]</code> <p>Loaded Set object, or None if not found or error occurred</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def open_set_by_name(self, name: str) -&gt; Optional[Set]:\n    \"\"\"\n    Open an existing set by name from the configured sets directory.\n\n    Args:\n        name: Name of the set (without .json extension)\n\n    Returns:\n        Loaded Set object, or None if not found or error occurred\n    \"\"\"\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    if not set_path.exists():\n        logger.warning(f\"Set file not found: {set_path}\")\n        return None\n\n    try:\n        return self.open_set(set_path)\n    except ValueError as e:\n        logger.error(f\"Error opening set '{name}': {e}\")\n        return None\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.create_from_directory","title":"<code>create_from_directory(samples_dir, name=None)</code>","text":"<p>Create a new set from samples in a directory.</p> <p>Scans the directory for supported audio files and creates a set with samples auto-assigned to pads.</p> <p>Parameters:</p> Name Type Description Default <code>samples_dir</code> <code>Path</code> <p>Directory containing sample files</p> required <code>name</code> <code>Optional[str]</code> <p>Optional name for the set (defaults to directory name)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>New Set object with samples loaded</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If directory doesn't exist or contains no valid samples</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_from_directory(self, samples_dir: Path, name: Optional[str] = None) -&gt; Set:\n    \"\"\"\n    Create a new set from samples in a directory.\n\n    Scans the directory for supported audio files and creates a set\n    with samples auto-assigned to pads.\n\n    Args:\n        samples_dir: Directory containing sample files\n        name: Optional name for the set (defaults to directory name)\n\n    Returns:\n        New Set object with samples loaded\n\n    Raises:\n        ValueError: If directory doesn't exist or contains no valid samples\n    \"\"\"\n    if not samples_dir.exists() or not samples_dir.is_dir():\n        raise ValueError(f\"Invalid samples directory: {samples_dir}\")\n\n    set_name = name or samples_dir.name\n\n    try:\n        set_obj = Set.from_sample_directory(\n            samples_dir=samples_dir,\n            name=set_name,\n            auto_configure=True\n        )\n        logger.info(\n            f\"Created set '{set_name}' with {len(set_obj.launchpad.assigned_pads)} \"\n            f\"samples from {samples_dir}\"\n        )\n        return set_obj\n    except Exception as e:\n        logger.error(f\"Error creating set from {samples_dir}: {e}\")\n        raise ValueError(f\"Failed to create set from directory: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.save_set","title":"<code>save_set(set_obj, path, new_name=None)</code>","text":"<p>Save a set to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>path</code> <code>Path</code> <p>Path where the set should be saved (.json)</p> required <code>new_name</code> <code>Optional[str]</code> <p>Optional new name for the set</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>The saved Set object (with updated name if provided)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set(\n    self,\n    set_obj: Set,\n    path: Path,\n    new_name: Optional[str] = None\n) -&gt; Set:\n    \"\"\"\n    Save a set to a JSON file.\n\n    Args:\n        set_obj: The Set object to save\n        path: Path where the set should be saved (.json)\n        new_name: Optional new name for the set\n\n    Returns:\n        The saved Set object (with updated name if provided)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    try:\n        # Update name if provided\n        if new_name and set_obj.name != new_name:\n            set_obj = Set(\n                name=new_name,\n                launchpad=set_obj.launchpad,\n                samples_root=set_obj.samples_root,\n                created_at=set_obj.created_at,\n                modified_at=set_obj.modified_at\n            )\n\n        # Save the set (using internal implementation that creates parent directories)\n        saved_set = self._save_set_to_file(set_obj, path)\n\n        logger.info(f\"Saved set '{saved_set.name}' to {path}\")\n        return saved_set\n    except Exception as e:\n        logger.error(f\"Error saving set to {path}: {e}\")\n        raise ValueError(f\"Failed to save set: {e}\") from e\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.save_set_to_library","title":"<code>save_set_to_library(set_obj, filename=None)</code>","text":"<p>Save a set to the configured sets library directory.</p> <p>Parameters:</p> Name Type Description Default <code>set_obj</code> <code>Set</code> <p>The Set object to save</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional filename (without .json extension).      Defaults to set_obj.name</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Set, Path]</code> <p>Tuple of (saved Set object, path where it was saved)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If save operation fails</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def save_set_to_library(\n    self,\n    set_obj: Set,\n    filename: Optional[str] = None\n) -&gt; tuple[Set, Path]:\n    \"\"\"\n    Save a set to the configured sets library directory.\n\n    Args:\n        set_obj: The Set object to save\n        filename: Optional filename (without .json extension).\n                 Defaults to set_obj.name\n\n    Returns:\n        Tuple of (saved Set object, path where it was saved)\n\n    Raises:\n        ValueError: If save operation fails\n    \"\"\"\n    name = filename or set_obj.name\n    set_path = self.config.sets_dir / f\"{name}.json\"\n\n    saved_set = self.save_set(set_obj, set_path)\n    return saved_set, set_path\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.create_empty","title":"<code>create_empty(name='Untitled')</code>","text":"<p>Create a new empty set.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new set</p> <code>'Untitled'</code> <p>Returns:</p> Type Description <code>Set</code> <p>New empty Set object</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def create_empty(self, name: str = \"Untitled\") -&gt; Set:\n    \"\"\"\n    Create a new empty set.\n\n    Args:\n        name: Name for the new set\n\n    Returns:\n        New empty Set object\n    \"\"\"\n    set_obj = Set.create_empty(name)\n    logger.info(f\"Created empty set '{name}'\")\n    return set_obj\n</code></pre>"},{"location":"api/services/set_manager_service/#launchsampler.services.set_manager_service.SetManagerService.load_set","title":"<code>load_set(set_name=None, samples_dir=None)</code>","text":"<p>Load a set with smart fallback logic.</p> <p>This handles the I/O operation of loading a Set from various sources (disk, directory, or creating empty). The returned Set object can then be mounted into the application.</p> <p>Priority order: 1. Load from samples directory (if provided) 2. Load from saved set file by name 3. Create empty set as fallback</p> <p>Parameters:</p> Name Type Description Default <code>set_name</code> <code>Optional[str]</code> <p>Name of set to load (defaults to \"Untitled\")</p> <code>None</code> <code>samples_dir</code> <code>Optional[Path]</code> <p>Directory to load samples from (highest priority)</p> <code>None</code> <p>Returns:</p> Type Description <code>Set</code> <p>Tuple of (loaded Set object, was_auto_created flag)</p> <code>bool</code> <p>was_auto_created is True when set file didn't exist and empty set was created</p> Source code in <code>src/launchsampler/services/set_manager_service.py</code> <pre><code>def load_set(\n    self,\n    set_name: Optional[str] = None,\n    samples_dir: Optional[Path] = None\n) -&gt; tuple[Set, bool]:\n    \"\"\"\n    Load a set with smart fallback logic.\n\n    This handles the I/O operation of loading a Set from various sources\n    (disk, directory, or creating empty). The returned Set object can then\n    be mounted into the application.\n\n    Priority order:\n    1. Load from samples directory (if provided)\n    2. Load from saved set file by name\n    3. Create empty set as fallback\n\n    Args:\n        set_name: Name of set to load (defaults to \"Untitled\")\n        samples_dir: Directory to load samples from (highest priority)\n\n    Returns:\n        Tuple of (loaded Set object, was_auto_created flag)\n        was_auto_created is True when set file didn't exist and empty set was created\n    \"\"\"\n    name = set_name or \"Untitled\"\n\n    # Priority 1: Load from samples directory\n    if samples_dir:\n        try:\n            loaded_set = self.create_from_directory(samples_dir, name)\n            logger.info(f\"Loaded initial set from samples directory: {samples_dir}\")\n            return loaded_set, False\n        except ValueError as e:\n            logger.error(f\"Failed to load from samples directory: {e}\")\n            # Fall through to next priority\n\n    # Priority 2: Load from saved set file\n    if name and name.lower() != \"untitled\":\n        loaded_set = self.open_set_by_name(name)\n        if loaded_set:\n            logger.info(f\"Loaded initial set from saved file: {name}\")\n            return loaded_set, False\n        else:\n            logger.warning(f\"Set '{name}' not found, creating empty set\")\n            # Fallback: auto-create empty set\n            logger.info(f\"Creating empty set '{name}'\")\n            return self.create_empty(name), True\n\n    # Fallback: empty set (intentional \"Untitled\" case, not auto-created)\n    logger.info(f\"Creating empty set '{name}'\")\n    return self.create_empty(name), False\n</code></pre>"},{"location":"api/tui/","title":"Tui","text":"<p>Terminal user interface</p> <p>TUI (Text User Interface) package for Launchpad Sampler.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler","title":"<code>LaunchpadSampler(orchestrator, start_mode='play')</code>","text":"<p>               Bases: <code>App</code></p> <p>Textual TUI for Launchpad Sampler.</p> <p>This is a PURE UI layer that delegates all business logic to the orchestrator. The orchestrator owns all state and services.</p> <p>Implements UIAdapter protocol via structural subtyping (no explicit inheritance to avoid metaclass conflicts between App and Protocol).</p> <p>Responsibilities: - Textual framework integration (widgets, layouts, bindings) - UI event handling (keyboard, mouse) - Visual presentation and updates via TUIService</p> <p>The orchestrator provides: - Core state (launchpad, current_set, mode) - Services (Player, EditorService, SetManagerService) - Observer pattern for UI synchronization</p> <p>Modes: - Edit Mode: Build sets, assign samples, configure pads - Play Mode: Full MIDI integration for live performance</p> <p>Switch modes anytime with E (edit) or P (play) keys.</p> <p>Initialize the Textual UI application.</p> <p>This is a thin UI layer that delegates all business logic to the orchestrator. The orchestrator should NOT be initialized yet - call orchestrator.initialize() after registering this UI to ensure event synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator instance (not yet initialized)</p> required <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'play'</code> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def __init__(\n    self,\n    orchestrator: \"Orchestrator\",\n    start_mode: str = \"play\"\n):\n    \"\"\"\n    Initialize the Textual UI application.\n\n    This is a thin UI layer that delegates all business logic to the orchestrator.\n    The orchestrator should NOT be initialized yet - call orchestrator.initialize()\n    after registering this UI to ensure event synchronization.\n\n    Args:\n        orchestrator: The Orchestrator instance (not yet initialized)\n        start_mode: Mode to start in (\"edit\" or \"play\")\n    \"\"\"\n    super().__init__()\n\n    # Orchestrator owns all business logic and state\n    self.orchestrator = orchestrator\n    self.config = orchestrator.config\n    self._start_mode = start_mode\n\n    # UI-specific ephemeral state (not persisted)\n    self._selected_pad_index: Optional[int] = None\n\n    # Services\n    self.tui_service: Optional[TUIService] = None  # Initialized in initialize()\n    self.navigation: NavigationService = NavigationService(orchestrator.launchpad)\n\n    self._selection_observers: list = []  # For SelectionObserver pattern\n    self._initialized = False  # Track initialization state\n    self._startup_error: Optional[Exception] = None  # Store startup errors to display after exit\n    logger.info(\"LaunchpadSampler TUI created\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>READ-ONLY access to launchpad state.</p> <p>Do NOT mutate this directly. Use EditorService methods to make changes (they fire events for observer synchronization).</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.current_set","title":"<code>current_set</code>  <code>property</code>","text":"<p>READ-ONLY access to current set.</p> <p>To change sets, use orchestrator.mount_set() which fires AppEvent.SET_MOUNTED for observers.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.set_manager","title":"<code>set_manager</code>  <code>property</code>","text":"<p>Get the set manager service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.player","title":"<code>player</code>  <code>property</code>","text":"<p>Get the player service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get the editor service from orchestrator.</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.selected_pad_index","title":"<code>selected_pad_index</code>  <code>property</code>","text":"<p>Get the currently selected pad index (UI state).</p>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the TUI and register observers.</p> <p>This is called by orchestrator.run() to set up the TUI service and register app-level observers.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the TUI and register observers.\n\n    This is called by orchestrator.run() to set up the TUI service\n    and register app-level observers.\n    \"\"\"\n    if self._initialized:\n        logger.warning(\"TUI already initialized\")\n        return\n\n    logger.info(\"Initializing TUI service and registering observers\")\n\n    # Create TUI service - handles ALL UI updates via observer pattern\n    self.tui_service = TUIService(self)\n\n    # Register TUI service for app-level events (SET_MOUNTED, MODE_CHANGED)\n    self.orchestrator.register_observer(self.tui_service)\n\n    # Register for selection events (UI-specific state)\n    self.register_selection_observer(self.tui_service)\n\n    self._initialized = True\n    logger.info(\"TUI initialization complete - ready to receive events\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register TUI service with orchestrator services.</p> <p>Called by orchestrator.initialize() after services are created but BEFORE events are fired. This ensures we receive all edit events.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The orchestrator with initialized services</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"Orchestrator\") -&gt; None:\n    \"\"\"\n    Register TUI service with orchestrator services.\n\n    Called by orchestrator.initialize() after services are created\n    but BEFORE events are fired. This ensures we receive all edit events.\n\n    Args:\n        orchestrator: The orchestrator with initialized services\n    \"\"\"\n    if not self.tui_service:\n        raise RuntimeError(\"TUI service not initialized - call initialize() first\")\n\n    logger.info(\"Registering TUI service with orchestrator services\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.tui_service)\n\n    # Register for MIDI events (for visual feedback - green borders)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.tui_service)\n        logger.info(\"TUI service registered as MIDI observer\")\n\n    # Register for playback events\n    orchestrator.player.set_playback_callback(self.tui_service.on_playback_event)\n\n    logger.info(\"TUI service registered with all orchestrator services\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.run","title":"<code>run()</code>","text":"<p>Run the Textual TUI (blocks until app exits).</p> <p>This is called by the orchestrator after initialization completes. The orchestrator has already fired startup events which the TUI received.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a startup error occurred (e.g., audio device in use)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the Textual TUI (blocks until app exits).\n\n    This is called by the orchestrator after initialization completes.\n    The orchestrator has already fired startup events which the TUI received.\n\n    Raises:\n        RuntimeError: If a startup error occurred (e.g., audio device in use)\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"TUI must be initialized before running\")\n\n    logger.info(\"Starting Textual TUI\")\n    # Call Textual's run method (blocks until app exits)\n    super().run()\n\n    # After Textual exits, check if there was a startup error\n    # Re-raise the original exception to preserve type and attributes\n    if self._startup_error:\n        raise self._startup_error\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the TUI and clean up resources.</p> <p>Called by the orchestrator during application exit.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the TUI and clean up resources.\n\n    Called by the orchestrator during application exit.\n    \"\"\"\n    logger.info(\"Shutting down TUI\")\n    # Unregister observers\n    if self.tui_service:\n        self.orchestrator.unregister_observer(self.tui_service)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.tui_service)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Select a pad (UI operation).</p> <p>This updates UI-specific selection state and notifies selection observers. This does NOT modify persistent data or fire EditEvent.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Select a pad (UI operation).\n\n    This updates UI-specific selection state and notifies selection observers.\n    This does NOT modify persistent data or fire EditEvent.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; 64:\n        logger.error(f\"Pad index {pad_index} out of range\")\n        return\n\n    self._selected_pad_index = pad_index\n\n    # Notify selection observers (TUIService will update UI)\n    self._notify_selection_observers(SelectionEvent.CHANGED, pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.clear_pad_selection","title":"<code>clear_pad_selection()</code>","text":"<p>Clear pad selection (UI operation - renamed to avoid Textual API conflict).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def clear_pad_selection(self) -&gt; None:\n    \"\"\"Clear pad selection (UI operation - renamed to avoid Textual API conflict).\"\"\"\n    self._notify_selection_observers(SelectionEvent.CLEARED, None)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.register_selection_observer","title":"<code>register_selection_observer(observer)</code>","text":"<p>Register an observer for selection events.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_selection_observer(self, observer) -&gt; None:\n    \"\"\"Register an observer for selection events.\"\"\"\n    if observer not in self._selection_observers:\n        self._selection_observers.append(observer)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.compose","title":"<code>compose()</code>","text":"<p>Create the main layout.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the main layout.\"\"\"\n    yield Header(show_clock=True)\n\n    with Horizontal():\n        yield PadGrid()  # No launchpad parameter - data-driven\n        yield PadDetailsPanel()\n\n    yield StatusBar()\n    yield Footer()\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_mount","title":"<code>on_mount()</code>","text":"<p>Initialize the app after Textual mounting.</p> <p>At this point, Textual is running with its event loop active, so we can safely process events and update widgets.</p> <p>Flow: 1. UIAdapter.initialize() has created TUI service and registered app observers 2. Now Textual is running (we're in on_mount) 3. Initialize the grid widgets 4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED) 5. TUI service receives events and updates widgets (now they exist!)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Initialize the app after Textual mounting.\n\n    At this point, Textual is running with its event loop active,\n    so we can safely process events and update widgets.\n\n    Flow:\n    1. UIAdapter.initialize() has created TUI service and registered app observers\n    2. Now Textual is running (we're in on_mount)\n    3. Initialize the grid widgets\n    4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED)\n    5. TUI service receives events and updates widgets (now they exist!)\n    \"\"\"\n    if not self._initialized or not self.tui_service:\n        raise RuntimeError(\"TUI must be initialized via UIAdapter.initialize() before mounting\")\n\n    logger.info(\"TUI mounting - Textual is now running\")\n\n    # Initialize grid with launchpad (creates button widgets)\n    grid = self.query_one(PadGrid)\n    grid.initialize_pads(self.launchpad)\n\n    # NOW initialize the orchestrator (Textual is running, widgets exist)\n    # orchestrator.initialize() will:\n    # 1. Create services (SetManager, Player, Editor)\n    # 2. Call ui.register_with_services() to register observers\n    # 3. Fire SET_MOUNTED and MODE_CHANGED events (TUI service receives and processes them)\n    logger.info(\"Initializing orchestrator from TUI on_mount\")\n    try:\n        self.orchestrator.initialize()\n    except Exception as e:\n        # Handle initialization errors (e.g., audio device in use)\n        # Store the full exception object (not just string) to preserve\n        # custom exception attributes like recovery hints\n        logger.error(f\"Failed to initialize orchestrator: {e}\")\n\n        # Store exception to display after Textual exits\n        self._startup_error = e\n\n        # Exit the app with error code\n        self.exit(1)\n        return\n\n    # Update subtitle (events have already synced the widgets)\n    if self.orchestrator.mode:\n        self.sub_title = f\"{self.orchestrator.mode.title()}: {self.current_set.name}\"\n\n    logger.info(\"TUI mount complete - orchestrator initialized, UI synchronized\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_unmount","title":"<code>on_unmount()</code>","text":"<p>Cleanup when Textual app unmounts.</p> <p>Note: Orchestrator shutdown is handled by orchestrator.shutdown(), which calls our UIAdapter.shutdown() method. We don't call it here to avoid double-shutdown.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_unmount(self) -&gt; None:\n    \"\"\"\n    Cleanup when Textual app unmounts.\n\n    Note: Orchestrator shutdown is handled by orchestrator.shutdown(),\n    which calls our UIAdapter.shutdown() method. We don't call it here\n    to avoid double-shutdown.\n    \"\"\"\n    logger.info(\"TUI unmounted\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_switch_mode","title":"<code>action_switch_mode(mode)</code>","text":"<p>Switch between edit and play modes.</p> <p>Entry point for keybindings (E/P keys). Delegates to _set_mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_switch_mode(self, mode: str) -&gt; None:\n    \"\"\"\n    Switch between edit and play modes.\n\n    Entry point for keybindings (E/P keys). Delegates to _set_mode.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n    \"\"\"\n    self._set_mode(mode)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_grid_pad_selected","title":"<code>on_pad_grid_pad_selected(message)</code>","text":"<p>Handle pad selection from grid.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_pad_grid_pad_selected(self, message: PadGrid.PadSelected) -&gt; None:\n    \"\"\"Handle pad selection from grid.\"\"\"\n    if self._sampler_mode == \"edit\":\n        try:\n            self.select_pad(message.pad_index)  # Fires SelectionEvent\n        except Exception as e:\n            logger.error(f\"Error selecting pad: {e}\")\n            self.notify(f\"Error selecting pad: {e}\", severity=\"error\")\n    elif self._sampler_mode == \"play\":\n        # In play mode, clicking a pad triggers it (same as spacebar)\n        pad = self.editor.get_pad(message.pad_index)\n        if not pad.is_assigned:\n            return\n\n        # Toggle playback: stop if playing, start if not\n        if self.player.is_pad_playing(message.pad_index):\n            self.player.stop_pad(message.pad_index)\n        else:\n            self.player.trigger_pad(message.pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses from details panel.\"\"\"\n    button_id = event.button.id\n\n    if not button_id:\n        return\n\n    if button_id == \"browse-btn\":\n        self.action_browse_sample()\n    elif button_id == \"clear-btn\":\n        self.action_delete_pad()\n    elif button_id == \"test-btn\":\n        self.action_test_pad()\n    elif button_id == \"stop-btn\":\n        self.action_toggle_test()  # Use same toggle behavior\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_radio_set_changed","title":"<code>on_radio_set_changed(event)</code>","text":"<p>Handle mode radio button changes.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_radio_set_changed(self, event: RadioSet.Changed) -&gt; None:\n    \"\"\"Handle mode radio button changes.\"\"\"\n    if event.radio_set.id != \"mode-radio\":\n        return\n\n    # Map radio button IDs to playback modes\n    mode_map = {\n        \"mode-oneshot\": PlaybackMode.ONE_SHOT,\n        \"mode-toggle\": PlaybackMode.TOGGLE,\n        \"mode-hold\": PlaybackMode.HOLD,\n        \"mode-loop\": PlaybackMode.LOOP,\n        \"mode-looptoggle\": PlaybackMode.LOOP_TOGGLE\n    }\n\n    pressed_id = event.pressed.id if event.pressed else None\n    if pressed_id in mode_map:\n        self._set_pad_mode(mode_map[pressed_id])\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_volume_changed","title":"<code>on_pad_details_panel_volume_changed(event)</code>","text":"<p>Handle volume change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_volume_changed(self, event: PadDetailsPanel.VolumeChanged) -&gt; None:\n    \"\"\"Handle volume change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle audio/UI sync automatically)\n        _ = self.editor.set_pad_volume(event.pad_index, event.volume)\n\n    except Exception as e:\n        logger.error(f\"Error updating volume: {e}\")\n        self.notify(f\"Error updating volume: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_name_changed","title":"<code>on_pad_details_panel_name_changed(event)</code>","text":"<p>Handle name change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_name_changed(self, event: PadDetailsPanel.NameChanged) -&gt; None:\n    \"\"\"Handle name change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle UI sync automatically)\n        _ = self.editor.set_sample_name(event.pad_index, event.name)\n\n    except Exception as e:\n        logger.error(f\"Error updating name: {e}\")\n        self.notify(f\"Error updating name: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.on_pad_details_panel_move_pad_requested","title":"<code>on_pad_details_panel_move_pad_requested(event)</code>","text":"<p>Handle move pad request from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_move_pad_requested(self, event: PadDetailsPanel.MovePadRequested) -&gt; None:\n    \"\"\"Handle move pad request from details panel.\"\"\"\n    try:\n        source_index = event.source_index\n        target_index = event.target_index\n        logger.info(f\"Move request received: {source_index} -&gt; {target_index}\")\n\n        # Check if target pad has a sample\n        target_pad = self.editor.get_pad(target_index)\n\n        if target_pad.is_assigned:\n            # Target has a sample - ask user what to do\n\n            logger.info(f\"Target pad {target_index} has sample, showing modal\")\n\n            # Show modal and handle result via callback\n            def handle_move_choice(result: str) -&gt; None:\n                \"\"\"Handle the user's choice from the modal.\"\"\"\n                logger.info(f\"Modal callback received result: {result}\")\n                if result == \"cancel\":\n                    logger.info(\"User cancelled move\")\n                    return\n                elif result == \"swap\":\n                    swap = True\n                elif result == \"overwrite\":\n                    swap = False\n                else:\n                    logger.warning(f\"Unknown result: {result}\")\n                    return\n\n                # Perform the move with user's choice\n                logger.info(f\"Executing move with swap={swap}\")\n                self._perform_pad_move(source_index, target_index, swap)\n\n            self.push_screen(\n                MoveConfirmationModal(\n                    source_index=source_index,\n                    target_index=target_index,\n                    target_sample_name=target_pad.sample.name if target_pad.sample else \"Unknown\"\n                ),\n                callback=handle_move_choice\n            )\n            logger.info(\"Modal pushed, waiting for user input\")\n        else:\n            # Target is empty - just move\n            logger.info(f\"Target pad {target_index} is empty, moving directly\")\n            self._perform_pad_move(source_index, target_index, swap=False)\n\n    except Exception as e:\n        logger.error(f\"Error moving pad: {e}\")\n        self.notify(f\"Error moving pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_browse_sample","title":"<code>action_browse_sample()</code>","text":"<p>Open file browser to assign a sample.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_browse_sample(self) -&gt; None:\n    \"\"\"Open file browser to assign a sample.\"\"\"\n    if self.selected_pad_index is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    # Capture selected pad index (guaranteed not None here)\n    selected_pad = self.selected_pad_index\n\n    def handle_file(file_path: Optional[Path]) -&gt; None:\n        if file_path:\n            try:\n                # Assign sample (events handle audio/UI sync automatically)\n                pad = self.editor.assign_sample(selected_pad, file_path)\n\n                # Safe to access sample.name after assign_sample\n                if pad.sample:\n                    self.notify(f\"Assigned: {pad.sample.name}\")\n            except Exception as e:\n                logger.error(f\"Error assigning sample: {e}\")\n                self.notify(f\"Error: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    browse_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(\n        FileBrowserScreen(browse_dir),\n        handle_file\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_save","title":"<code>action_save()</code>","text":"<p>Save the current set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_save(self) -&gt; None:\n    \"\"\"Save the current set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_save(result: Optional[tuple[Path, str]]) -&gt; None:\n        if result:\n            directory, filename = result\n            try:\n                # Construct full path\n                save_path = directory / f\"{filename}.json\"\n\n                # Save set using orchestrator (handles name changes internally)\n                self.orchestrator.save_set(save_path, name=filename)\n\n                self.notify(f\"Saved set to: {save_path}\")\n\n                # Update subtitle\n                if self._sampler_mode:\n                    self.sub_title = f\"{self._sampler_mode.title()}: {filename}\"\n\n            except Exception as e:\n                logger.error(f\"Error saving set: {e}\", exc_info=True)\n                self.notify(f\"Error saving: {e}\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(\n        SaveSetBrowserScreen(self.config.sets_dir, self.current_set.name),\n        handle_save\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_load","title":"<code>action_load()</code>","text":"<p>Load a saved set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_load(self) -&gt; None:\n    \"\"\"Load a saved set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_load(set_path: Optional[Path]) -&gt; None:\n        if set_path:\n            try:\n                # Load set using SetManagerService\n                loaded_set = self.set_manager.open_set(set_path)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                self.notify(f\"Loaded set: {loaded_set.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading set: {e}\")\n                self.notify(\"Error loading set file\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(SetFileBrowserScreen(self.set_manager, self.config.sets_dir), handle_load)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_open_directory","title":"<code>action_open_directory()</code>","text":"<p>Open a directory to load samples from.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_open_directory(self) -&gt; None:\n    \"\"\"Open a directory to load samples from.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_directory_selected(dir_path: Optional[Path]) -&gt; None:\n        if dir_path:\n            try:\n                # Load samples using SetManagerService\n                loaded_set = self.set_manager.create_from_directory(dir_path, dir_path.name)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                # Switch to edit mode after loading directory\n                self._set_mode(\"edit\")\n\n                self.notify(f\"Loaded {len(self.launchpad.assigned_pads)} samples from {dir_path.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading directory: {e}\")\n                self.notify(f\"Error loading directory: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    start_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(DirectoryBrowserScreen(start_dir), handle_directory_selected)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_copy_pad","title":"<code>action_copy_pad()</code>","text":"<p>Copy selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_copy_pad(self) -&gt; None:\n    \"\"\"Copy selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        pad = self.editor.copy_pad(selected_pad)\n        self.notify(f\"Copied: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_cut_pad","title":"<code>action_cut_pad()</code>","text":"<p>Cut selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\n@handle_action_errors(\"cut pad\")\ndef action_cut_pad(self) -&gt; None:\n    \"\"\"Cut selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Stop playback if pad is playing (PAD_STOPPED event will update UI)\n    if self.player.is_pad_playing(selected_pad):\n        self.player.stop_pad(selected_pad)\n\n    # Cut pad (events handle audio/UI sync automatically)\n    pad = self.editor.cut_pad(selected_pad)\n\n    self.notify(f\"Cut: {pad.sample.name}\", severity=\"information\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_paste_pad","title":"<code>action_paste_pad()</code>","text":"<p>Paste clipboard to selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_paste_pad(self) -&gt; None:\n    \"\"\"Paste clipboard to selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    if not self.editor.has_clipboard:\n        self.notify(\"Clipboard is empty\", severity=\"warning\")\n        return\n\n    try:\n        # Try paste with overwrite=False first (events handle audio/UI sync automatically)\n        pad = self.editor.paste_pad(selected_pad, overwrite=False)\n\n        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n\n    except ValueError as e:\n        # Check if it's because target is occupied\n        if \"already has sample\" in str(e):\n            # Show confirmation modal\n            target_pad = self.editor.get_pad(selected_pad)\n\n            def handle_paste_confirm(overwrite: bool) -&gt; None:\n                if overwrite:\n                    try:\n                        # Paste (events handle audio/UI sync automatically)\n                        pad = self.editor.paste_pad(selected_pad, overwrite=True)\n                        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n                    except Exception as e:\n                        logger.error(f\"Error pasting: {e}\")\n                        self.notify(f\"Error: {e}\", severity=\"error\")\n\n            self.push_screen(\n                PasteConfirmationModal(selected_pad, target_pad.sample.name),\n                handle_paste_confirm\n            )\n        else:\n            # Some other error\n            self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_delete_pad","title":"<code>action_delete_pad()</code>","text":"<p>Delete the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_delete_pad(self) -&gt; None:\n    \"\"\"Delete the selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Check if pad has a sample\n    pad = self.editor.get_pad(selected_pad)\n    if not pad.is_assigned or not pad.sample:\n        self.notify(\"Pad is already empty\", severity=\"warning\")\n        return\n\n    # Show confirmation modal\n    def handle_confirmation(confirmed: bool) -&gt; None:\n        if not confirmed:\n            return\n\n        try:\n            # Clear pad (events handle audio/UI sync automatically)\n            _ = self.editor.clear_pad(selected_pad)\n\n            self.notify(\"Pad deleted\")\n        except Exception as e:\n            logger.error(f\"Error deleting pad: {e}\")\n            self.notify(f\"Error: {e}\", severity=\"error\")\n\n    self.push_screen(\n        ClearConfirmationModal(selected_pad, pad.sample.name),\n        handle_confirmation\n    )\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_up","title":"<code>action_navigate_up()</code>","text":"<p>Navigate to pad above current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_up(self) -&gt; None:\n    \"\"\"Navigate to pad above current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"up\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_down","title":"<code>action_navigate_down()</code>","text":"<p>Navigate to pad below current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_down(self) -&gt; None:\n    \"\"\"Navigate to pad below current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"down\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_left","title":"<code>action_navigate_left()</code>","text":"<p>Navigate to pad left of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_left(self) -&gt; None:\n    \"\"\"Navigate to pad left of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"left\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_navigate_right","title":"<code>action_navigate_right()</code>","text":"<p>Navigate to pad right of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_right(self) -&gt; None:\n    \"\"\"Navigate to pad right of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"right\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_up","title":"<code>action_duplicate_up()</code>","text":"<p>Duplicate selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_up(self) -&gt; None:\n    \"\"\"Duplicate selected pad upward.\"\"\"\n    self._duplicate_directional(\"up\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_down","title":"<code>action_duplicate_down()</code>","text":"<p>Duplicate selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_down(self) -&gt; None:\n    \"\"\"Duplicate selected pad downward.\"\"\"\n    self._duplicate_directional(\"down\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_left","title":"<code>action_duplicate_left()</code>","text":"<p>Duplicate selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_left(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the left.\"\"\"\n    self._duplicate_directional(\"left\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_duplicate_right","title":"<code>action_duplicate_right()</code>","text":"<p>Duplicate selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_right(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the right.\"\"\"\n    self._duplicate_directional(\"right\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_up","title":"<code>action_move_up()</code>","text":"<p>Move selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_up(self) -&gt; None:\n    \"\"\"Move selected pad upward.\"\"\"\n    self._move_directional(\"up\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_down","title":"<code>action_move_down()</code>","text":"<p>Move selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_down(self) -&gt; None:\n    \"\"\"Move selected pad downward.\"\"\"\n    self._move_directional(\"down\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_left","title":"<code>action_move_left()</code>","text":"<p>Move selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_left(self) -&gt; None:\n    \"\"\"Move selected pad to the left.\"\"\"\n    self._move_directional(\"left\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_move_right","title":"<code>action_move_right()</code>","text":"<p>Move selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_right(self) -&gt; None:\n    \"\"\"Move selected pad to the right.\"\"\"\n    self._move_directional(\"right\")\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_test_pad","title":"<code>action_test_pad()</code>","text":"<p>Test the selected pad (works in both modes).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_test_pad(self) -&gt; None:\n    \"\"\"Test the selected pad (works in both modes).\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if pad.is_assigned:\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_toggle_test","title":"<code>action_toggle_test()</code>","text":"<p>Toggle between test and stop for the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_toggle_test(self) -&gt; None:\n    \"\"\"Toggle between test and stop for the selected pad.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if not pad.is_assigned:\n        return\n\n    # Check if pad is currently playing\n    if self.player.is_pad_playing(self.selected_pad_index):\n        # Stop the pad - goes through queue and fires proper events\n        self.player.stop_pad(self.selected_pad_index)\n    else:\n        # Start the pad\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_stop_audio","title":"<code>action_stop_audio()</code>","text":"<p>Stop all audio playback.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_stop_audio(self) -&gt; None:\n    \"\"\"Stop all audio playback.\"\"\"\n    self.player.stop_all()\n\n    # Also release selected pad if in HOLD mode\n    if self.selected_pad_index is not None:\n        self.player.release_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_one_shot","title":"<code>action_set_mode_one_shot()</code>","text":"<p>Set selected pad to one-shot mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_one_shot(self) -&gt; None:\n    \"\"\"Set selected pad to one-shot mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.ONE_SHOT)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_toggle","title":"<code>action_set_mode_toggle()</code>","text":"<p>Set selected pad to toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.TOGGLE)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_hold","title":"<code>action_set_mode_hold()</code>","text":"<p>Set selected pad to hold mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_hold(self) -&gt; None:\n    \"\"\"Set selected pad to hold mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.HOLD)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_loop","title":"<code>action_set_mode_loop()</code>","text":"<p>Set selected pad to loop mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop(self) -&gt; None:\n    \"\"\"Set selected pad to loop mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP)\n</code></pre>"},{"location":"api/tui/#launchsampler.tui.LaunchpadSampler.action_set_mode_loop_toggle","title":"<code>action_set_mode_loop_toggle()</code>","text":"<p>Set selected pad to loop toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to loop toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP_TOGGLE)\n</code></pre>"},{"location":"api/tui/app/","title":"App","text":""},{"location":"api/tui/app/#launchsampler.tui.app","title":"<code>app</code>","text":"<p>Main unified TUI application with edit and play modes.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler","title":"<code>LaunchpadSampler(orchestrator, start_mode='play')</code>","text":"<p>               Bases: <code>App</code></p> <p>Textual TUI for Launchpad Sampler.</p> <p>This is a PURE UI layer that delegates all business logic to the orchestrator. The orchestrator owns all state and services.</p> <p>Implements UIAdapter protocol via structural subtyping (no explicit inheritance to avoid metaclass conflicts between App and Protocol).</p> <p>Responsibilities: - Textual framework integration (widgets, layouts, bindings) - UI event handling (keyboard, mouse) - Visual presentation and updates via TUIService</p> <p>The orchestrator provides: - Core state (launchpad, current_set, mode) - Services (Player, EditorService, SetManagerService) - Observer pattern for UI synchronization</p> <p>Modes: - Edit Mode: Build sets, assign samples, configure pads - Play Mode: Full MIDI integration for live performance</p> <p>Switch modes anytime with E (edit) or P (play) keys.</p> <p>Initialize the Textual UI application.</p> <p>This is a thin UI layer that delegates all business logic to the orchestrator. The orchestrator should NOT be initialized yet - call orchestrator.initialize() after registering this UI to ensure event synchronization.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The Orchestrator instance (not yet initialized)</p> required <code>start_mode</code> <code>str</code> <p>Mode to start in (\"edit\" or \"play\")</p> <code>'play'</code> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def __init__(\n    self,\n    orchestrator: \"Orchestrator\",\n    start_mode: str = \"play\"\n):\n    \"\"\"\n    Initialize the Textual UI application.\n\n    This is a thin UI layer that delegates all business logic to the orchestrator.\n    The orchestrator should NOT be initialized yet - call orchestrator.initialize()\n    after registering this UI to ensure event synchronization.\n\n    Args:\n        orchestrator: The Orchestrator instance (not yet initialized)\n        start_mode: Mode to start in (\"edit\" or \"play\")\n    \"\"\"\n    super().__init__()\n\n    # Orchestrator owns all business logic and state\n    self.orchestrator = orchestrator\n    self.config = orchestrator.config\n    self._start_mode = start_mode\n\n    # UI-specific ephemeral state (not persisted)\n    self._selected_pad_index: Optional[int] = None\n\n    # Services\n    self.tui_service: Optional[TUIService] = None  # Initialized in initialize()\n    self.navigation: NavigationService = NavigationService(orchestrator.launchpad)\n\n    self._selection_observers: list = []  # For SelectionObserver pattern\n    self._initialized = False  # Track initialization state\n    self._startup_error: Optional[Exception] = None  # Store startup errors to display after exit\n    logger.info(\"LaunchpadSampler TUI created\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.launchpad","title":"<code>launchpad</code>  <code>property</code>","text":"<p>READ-ONLY access to launchpad state.</p> <p>Do NOT mutate this directly. Use EditorService methods to make changes (they fire events for observer synchronization).</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.current_set","title":"<code>current_set</code>  <code>property</code>","text":"<p>READ-ONLY access to current set.</p> <p>To change sets, use orchestrator.mount_set() which fires AppEvent.SET_MOUNTED for observers.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.set_manager","title":"<code>set_manager</code>  <code>property</code>","text":"<p>Get the set manager service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.player","title":"<code>player</code>  <code>property</code>","text":"<p>Get the player service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get the editor service from orchestrator.</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.selected_pad_index","title":"<code>selected_pad_index</code>  <code>property</code>","text":"<p>Get the currently selected pad index (UI state).</p>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the TUI and register observers.</p> <p>This is called by orchestrator.run() to set up the TUI service and register app-level observers.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the TUI and register observers.\n\n    This is called by orchestrator.run() to set up the TUI service\n    and register app-level observers.\n    \"\"\"\n    if self._initialized:\n        logger.warning(\"TUI already initialized\")\n        return\n\n    logger.info(\"Initializing TUI service and registering observers\")\n\n    # Create TUI service - handles ALL UI updates via observer pattern\n    self.tui_service = TUIService(self)\n\n    # Register TUI service for app-level events (SET_MOUNTED, MODE_CHANGED)\n    self.orchestrator.register_observer(self.tui_service)\n\n    # Register for selection events (UI-specific state)\n    self.register_selection_observer(self.tui_service)\n\n    self._initialized = True\n    logger.info(\"TUI initialization complete - ready to receive events\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.register_with_services","title":"<code>register_with_services(orchestrator)</code>","text":"<p>Register TUI service with orchestrator services.</p> <p>Called by orchestrator.initialize() after services are created but BEFORE events are fired. This ensures we receive all edit events.</p> <p>Parameters:</p> Name Type Description Default <code>orchestrator</code> <code>Orchestrator</code> <p>The orchestrator with initialized services</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_with_services(self, orchestrator: \"Orchestrator\") -&gt; None:\n    \"\"\"\n    Register TUI service with orchestrator services.\n\n    Called by orchestrator.initialize() after services are created\n    but BEFORE events are fired. This ensures we receive all edit events.\n\n    Args:\n        orchestrator: The orchestrator with initialized services\n    \"\"\"\n    if not self.tui_service:\n        raise RuntimeError(\"TUI service not initialized - call initialize() first\")\n\n    logger.info(\"Registering TUI service with orchestrator services\")\n\n    # Register for edit events\n    orchestrator.editor.register_observer(self.tui_service)\n\n    # Register for MIDI events (for visual feedback - green borders)\n    if orchestrator.midi_controller:\n        orchestrator.midi_controller.register_observer(self.tui_service)\n        logger.info(\"TUI service registered as MIDI observer\")\n\n    # Register for playback events\n    orchestrator.player.set_playback_callback(self.tui_service.on_playback_event)\n\n    logger.info(\"TUI service registered with all orchestrator services\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.run","title":"<code>run()</code>","text":"<p>Run the Textual TUI (blocks until app exits).</p> <p>This is called by the orchestrator after initialization completes. The orchestrator has already fired startup events which the TUI received.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If a startup error occurred (e.g., audio device in use)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the Textual TUI (blocks until app exits).\n\n    This is called by the orchestrator after initialization completes.\n    The orchestrator has already fired startup events which the TUI received.\n\n    Raises:\n        RuntimeError: If a startup error occurred (e.g., audio device in use)\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"TUI must be initialized before running\")\n\n    logger.info(\"Starting Textual TUI\")\n    # Call Textual's run method (blocks until app exits)\n    super().run()\n\n    # After Textual exits, check if there was a startup error\n    # Re-raise the original exception to preserve type and attributes\n    if self._startup_error:\n        raise self._startup_error\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the TUI and clean up resources.</p> <p>Called by the orchestrator during application exit.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the TUI and clean up resources.\n\n    Called by the orchestrator during application exit.\n    \"\"\"\n    logger.info(\"Shutting down TUI\")\n    # Unregister observers\n    if self.tui_service:\n        self.orchestrator.unregister_observer(self.tui_service)\n        if self.orchestrator.editor:\n            self.orchestrator.editor.unregister_observer(self.tui_service)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Select a pad (UI operation).</p> <p>This updates UI-specific selection state and notifies selection observers. This does NOT modify persistent data or fire EditEvent.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Select a pad (UI operation).\n\n    This updates UI-specific selection state and notifies selection observers.\n    This does NOT modify persistent data or fire EditEvent.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; 64:\n        logger.error(f\"Pad index {pad_index} out of range\")\n        return\n\n    self._selected_pad_index = pad_index\n\n    # Notify selection observers (TUIService will update UI)\n    self._notify_selection_observers(SelectionEvent.CHANGED, pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.clear_pad_selection","title":"<code>clear_pad_selection()</code>","text":"<p>Clear pad selection (UI operation - renamed to avoid Textual API conflict).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def clear_pad_selection(self) -&gt; None:\n    \"\"\"Clear pad selection (UI operation - renamed to avoid Textual API conflict).\"\"\"\n    self._notify_selection_observers(SelectionEvent.CLEARED, None)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.register_selection_observer","title":"<code>register_selection_observer(observer)</code>","text":"<p>Register an observer for selection events.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def register_selection_observer(self, observer) -&gt; None:\n    \"\"\"Register an observer for selection events.\"\"\"\n    if observer not in self._selection_observers:\n        self._selection_observers.append(observer)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.compose","title":"<code>compose()</code>","text":"<p>Create the main layout.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the main layout.\"\"\"\n    yield Header(show_clock=True)\n\n    with Horizontal():\n        yield PadGrid()  # No launchpad parameter - data-driven\n        yield PadDetailsPanel()\n\n    yield StatusBar()\n    yield Footer()\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_mount","title":"<code>on_mount()</code>","text":"<p>Initialize the app after Textual mounting.</p> <p>At this point, Textual is running with its event loop active, so we can safely process events and update widgets.</p> <p>Flow: 1. UIAdapter.initialize() has created TUI service and registered app observers 2. Now Textual is running (we're in on_mount) 3. Initialize the grid widgets 4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED) 5. TUI service receives events and updates widgets (now they exist!)</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"\n    Initialize the app after Textual mounting.\n\n    At this point, Textual is running with its event loop active,\n    so we can safely process events and update widgets.\n\n    Flow:\n    1. UIAdapter.initialize() has created TUI service and registered app observers\n    2. Now Textual is running (we're in on_mount)\n    3. Initialize the grid widgets\n    4. Initialize the orchestrator (fires SET_MOUNTED, MODE_CHANGED)\n    5. TUI service receives events and updates widgets (now they exist!)\n    \"\"\"\n    if not self._initialized or not self.tui_service:\n        raise RuntimeError(\"TUI must be initialized via UIAdapter.initialize() before mounting\")\n\n    logger.info(\"TUI mounting - Textual is now running\")\n\n    # Initialize grid with launchpad (creates button widgets)\n    grid = self.query_one(PadGrid)\n    grid.initialize_pads(self.launchpad)\n\n    # NOW initialize the orchestrator (Textual is running, widgets exist)\n    # orchestrator.initialize() will:\n    # 1. Create services (SetManager, Player, Editor)\n    # 2. Call ui.register_with_services() to register observers\n    # 3. Fire SET_MOUNTED and MODE_CHANGED events (TUI service receives and processes them)\n    logger.info(\"Initializing orchestrator from TUI on_mount\")\n    try:\n        self.orchestrator.initialize()\n    except Exception as e:\n        # Handle initialization errors (e.g., audio device in use)\n        # Store the full exception object (not just string) to preserve\n        # custom exception attributes like recovery hints\n        logger.error(f\"Failed to initialize orchestrator: {e}\")\n\n        # Store exception to display after Textual exits\n        self._startup_error = e\n\n        # Exit the app with error code\n        self.exit(1)\n        return\n\n    # Update subtitle (events have already synced the widgets)\n    if self.orchestrator.mode:\n        self.sub_title = f\"{self.orchestrator.mode.title()}: {self.current_set.name}\"\n\n    logger.info(\"TUI mount complete - orchestrator initialized, UI synchronized\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_unmount","title":"<code>on_unmount()</code>","text":"<p>Cleanup when Textual app unmounts.</p> <p>Note: Orchestrator shutdown is handled by orchestrator.shutdown(), which calls our UIAdapter.shutdown() method. We don't call it here to avoid double-shutdown.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_unmount(self) -&gt; None:\n    \"\"\"\n    Cleanup when Textual app unmounts.\n\n    Note: Orchestrator shutdown is handled by orchestrator.shutdown(),\n    which calls our UIAdapter.shutdown() method. We don't call it here\n    to avoid double-shutdown.\n    \"\"\"\n    logger.info(\"TUI unmounted\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_switch_mode","title":"<code>action_switch_mode(mode)</code>","text":"<p>Switch between edit and play modes.</p> <p>Entry point for keybindings (E/P keys). Delegates to _set_mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Target mode (\"edit\" or \"play\")</p> required Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_switch_mode(self, mode: str) -&gt; None:\n    \"\"\"\n    Switch between edit and play modes.\n\n    Entry point for keybindings (E/P keys). Delegates to _set_mode.\n\n    Args:\n        mode: Target mode (\"edit\" or \"play\")\n    \"\"\"\n    self._set_mode(mode)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_grid_pad_selected","title":"<code>on_pad_grid_pad_selected(message)</code>","text":"<p>Handle pad selection from grid.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_pad_grid_pad_selected(self, message: PadGrid.PadSelected) -&gt; None:\n    \"\"\"Handle pad selection from grid.\"\"\"\n    if self._sampler_mode == \"edit\":\n        try:\n            self.select_pad(message.pad_index)  # Fires SelectionEvent\n        except Exception as e:\n            logger.error(f\"Error selecting pad: {e}\")\n            self.notify(f\"Error selecting pad: {e}\", severity=\"error\")\n    elif self._sampler_mode == \"play\":\n        # In play mode, clicking a pad triggers it (same as spacebar)\n        pad = self.editor.get_pad(message.pad_index)\n        if not pad.is_assigned:\n            return\n\n        # Toggle playback: stop if playing, start if not\n        if self.player.is_pad_playing(message.pad_index):\n            self.player.stop_pad(message.pad_index)\n        else:\n            self.player.trigger_pad(message.pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses from details panel.\"\"\"\n    button_id = event.button.id\n\n    if not button_id:\n        return\n\n    if button_id == \"browse-btn\":\n        self.action_browse_sample()\n    elif button_id == \"clear-btn\":\n        self.action_delete_pad()\n    elif button_id == \"test-btn\":\n        self.action_test_pad()\n    elif button_id == \"stop-btn\":\n        self.action_toggle_test()  # Use same toggle behavior\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_radio_set_changed","title":"<code>on_radio_set_changed(event)</code>","text":"<p>Handle mode radio button changes.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_radio_set_changed(self, event: RadioSet.Changed) -&gt; None:\n    \"\"\"Handle mode radio button changes.\"\"\"\n    if event.radio_set.id != \"mode-radio\":\n        return\n\n    # Map radio button IDs to playback modes\n    mode_map = {\n        \"mode-oneshot\": PlaybackMode.ONE_SHOT,\n        \"mode-toggle\": PlaybackMode.TOGGLE,\n        \"mode-hold\": PlaybackMode.HOLD,\n        \"mode-loop\": PlaybackMode.LOOP,\n        \"mode-looptoggle\": PlaybackMode.LOOP_TOGGLE\n    }\n\n    pressed_id = event.pressed.id if event.pressed else None\n    if pressed_id in mode_map:\n        self._set_pad_mode(mode_map[pressed_id])\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_volume_changed","title":"<code>on_pad_details_panel_volume_changed(event)</code>","text":"<p>Handle volume change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_volume_changed(self, event: PadDetailsPanel.VolumeChanged) -&gt; None:\n    \"\"\"Handle volume change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle audio/UI sync automatically)\n        _ = self.editor.set_pad_volume(event.pad_index, event.volume)\n\n    except Exception as e:\n        logger.error(f\"Error updating volume: {e}\")\n        self.notify(f\"Error updating volume: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_name_changed","title":"<code>on_pad_details_panel_name_changed(event)</code>","text":"<p>Handle name change from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_name_changed(self, event: PadDetailsPanel.NameChanged) -&gt; None:\n    \"\"\"Handle name change from details panel.\"\"\"\n    try:\n        # Update through editor service (events handle UI sync automatically)\n        _ = self.editor.set_sample_name(event.pad_index, event.name)\n\n    except Exception as e:\n        logger.error(f\"Error updating name: {e}\")\n        self.notify(f\"Error updating name: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.on_pad_details_panel_move_pad_requested","title":"<code>on_pad_details_panel_move_pad_requested(event)</code>","text":"<p>Handle move pad request from details panel.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef on_pad_details_panel_move_pad_requested(self, event: PadDetailsPanel.MovePadRequested) -&gt; None:\n    \"\"\"Handle move pad request from details panel.\"\"\"\n    try:\n        source_index = event.source_index\n        target_index = event.target_index\n        logger.info(f\"Move request received: {source_index} -&gt; {target_index}\")\n\n        # Check if target pad has a sample\n        target_pad = self.editor.get_pad(target_index)\n\n        if target_pad.is_assigned:\n            # Target has a sample - ask user what to do\n\n            logger.info(f\"Target pad {target_index} has sample, showing modal\")\n\n            # Show modal and handle result via callback\n            def handle_move_choice(result: str) -&gt; None:\n                \"\"\"Handle the user's choice from the modal.\"\"\"\n                logger.info(f\"Modal callback received result: {result}\")\n                if result == \"cancel\":\n                    logger.info(\"User cancelled move\")\n                    return\n                elif result == \"swap\":\n                    swap = True\n                elif result == \"overwrite\":\n                    swap = False\n                else:\n                    logger.warning(f\"Unknown result: {result}\")\n                    return\n\n                # Perform the move with user's choice\n                logger.info(f\"Executing move with swap={swap}\")\n                self._perform_pad_move(source_index, target_index, swap)\n\n            self.push_screen(\n                MoveConfirmationModal(\n                    source_index=source_index,\n                    target_index=target_index,\n                    target_sample_name=target_pad.sample.name if target_pad.sample else \"Unknown\"\n                ),\n                callback=handle_move_choice\n            )\n            logger.info(\"Modal pushed, waiting for user input\")\n        else:\n            # Target is empty - just move\n            logger.info(f\"Target pad {target_index} is empty, moving directly\")\n            self._perform_pad_move(source_index, target_index, swap=False)\n\n    except Exception as e:\n        logger.error(f\"Error moving pad: {e}\")\n        self.notify(f\"Error moving pad: {e}\", severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_browse_sample","title":"<code>action_browse_sample()</code>","text":"<p>Open file browser to assign a sample.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_browse_sample(self) -&gt; None:\n    \"\"\"Open file browser to assign a sample.\"\"\"\n    if self.selected_pad_index is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    # Capture selected pad index (guaranteed not None here)\n    selected_pad = self.selected_pad_index\n\n    def handle_file(file_path: Optional[Path]) -&gt; None:\n        if file_path:\n            try:\n                # Assign sample (events handle audio/UI sync automatically)\n                pad = self.editor.assign_sample(selected_pad, file_path)\n\n                # Safe to access sample.name after assign_sample\n                if pad.sample:\n                    self.notify(f\"Assigned: {pad.sample.name}\")\n            except Exception as e:\n                logger.error(f\"Error assigning sample: {e}\")\n                self.notify(f\"Error: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    browse_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(\n        FileBrowserScreen(browse_dir),\n        handle_file\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_save","title":"<code>action_save()</code>","text":"<p>Save the current set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_save(self) -&gt; None:\n    \"\"\"Save the current set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_save(result: Optional[tuple[Path, str]]) -&gt; None:\n        if result:\n            directory, filename = result\n            try:\n                # Construct full path\n                save_path = directory / f\"{filename}.json\"\n\n                # Save set using orchestrator (handles name changes internally)\n                self.orchestrator.save_set(save_path, name=filename)\n\n                self.notify(f\"Saved set to: {save_path}\")\n\n                # Update subtitle\n                if self._sampler_mode:\n                    self.sub_title = f\"{self._sampler_mode.title()}: {filename}\"\n\n            except Exception as e:\n                logger.error(f\"Error saving set: {e}\", exc_info=True)\n                self.notify(f\"Error saving: {e}\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(\n        SaveSetBrowserScreen(self.config.sets_dir, self.current_set.name),\n        handle_save\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_load","title":"<code>action_load()</code>","text":"<p>Load a saved set.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_load(self) -&gt; None:\n    \"\"\"Load a saved set.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_load(set_path: Optional[Path]) -&gt; None:\n        if set_path:\n            try:\n                # Load set using SetManagerService\n                loaded_set = self.set_manager.open_set(set_path)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                self.notify(f\"Loaded set: {loaded_set.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading set: {e}\")\n                self.notify(\"Error loading set file\", severity=\"error\")\n\n    # Start in the sets directory\n    self.push_screen(SetFileBrowserScreen(self.set_manager, self.config.sets_dir), handle_load)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_open_directory","title":"<code>action_open_directory()</code>","text":"<p>Open a directory to load samples from.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_open_directory(self) -&gt; None:\n    \"\"\"Open a directory to load samples from.\"\"\"\n    # Don't open modal if one is already open\n    if len(self.screen_stack) &gt; 1:\n        return\n\n    def handle_directory_selected(dir_path: Optional[Path]) -&gt; None:\n        if dir_path:\n            try:\n                # Load samples using SetManagerService\n                loaded_set = self.set_manager.create_from_directory(dir_path, dir_path.name)\n\n                # Use single load method\n                self._load_set(loaded_set)\n\n                # Switch to edit mode after loading directory\n                self._set_mode(\"edit\")\n\n                self.notify(f\"Loaded {len(self.launchpad.assigned_pads)} samples from {dir_path.name}\")\n\n            except Exception as e:\n                logger.error(f\"Error loading directory: {e}\")\n                self.notify(f\"Error loading directory: {e}\", severity=\"error\")\n\n    # Start browsing from current samples_root if available, otherwise home\n    start_dir = self.current_set.samples_root if self.current_set.samples_root else Path.home()\n    self.push_screen(DirectoryBrowserScreen(start_dir), handle_directory_selected)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_copy_pad","title":"<code>action_copy_pad()</code>","text":"<p>Copy selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_copy_pad(self) -&gt; None:\n    \"\"\"Copy selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    try:\n        pad = self.editor.copy_pad(selected_pad)\n        self.notify(f\"Copied: {pad.sample.name}\", severity=\"information\")\n    except ValueError as e:\n        self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_cut_pad","title":"<code>action_cut_pad()</code>","text":"<p>Cut selected pad to clipboard.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\n@handle_action_errors(\"cut pad\")\ndef action_cut_pad(self) -&gt; None:\n    \"\"\"Cut selected pad to clipboard.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Stop playback if pad is playing (PAD_STOPPED event will update UI)\n    if self.player.is_pad_playing(selected_pad):\n        self.player.stop_pad(selected_pad)\n\n    # Cut pad (events handle audio/UI sync automatically)\n    pad = self.editor.cut_pad(selected_pad)\n\n    self.notify(f\"Cut: {pad.sample.name}\", severity=\"information\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_paste_pad","title":"<code>action_paste_pad()</code>","text":"<p>Paste clipboard to selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_paste_pad(self) -&gt; None:\n    \"\"\"Paste clipboard to selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    if not self.editor.has_clipboard:\n        self.notify(\"Clipboard is empty\", severity=\"warning\")\n        return\n\n    try:\n        # Try paste with overwrite=False first (events handle audio/UI sync automatically)\n        pad = self.editor.paste_pad(selected_pad, overwrite=False)\n\n        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n\n    except ValueError as e:\n        # Check if it's because target is occupied\n        if \"already has sample\" in str(e):\n            # Show confirmation modal\n            target_pad = self.editor.get_pad(selected_pad)\n\n            def handle_paste_confirm(overwrite: bool) -&gt; None:\n                if overwrite:\n                    try:\n                        # Paste (events handle audio/UI sync automatically)\n                        pad = self.editor.paste_pad(selected_pad, overwrite=True)\n                        self.notify(f\"Pasted: {pad.sample.name}\", severity=\"information\")\n                    except Exception as e:\n                        logger.error(f\"Error pasting: {e}\")\n                        self.notify(f\"Error: {e}\", severity=\"error\")\n\n            self.push_screen(\n                PasteConfirmationModal(selected_pad, target_pad.sample.name),\n                handle_paste_confirm\n            )\n        else:\n            # Some other error\n            self.notify(str(e), severity=\"error\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_delete_pad","title":"<code>action_delete_pad()</code>","text":"<p>Delete the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>@edit_only\ndef action_delete_pad(self) -&gt; None:\n    \"\"\"Delete the selected pad.\"\"\"\n    selected_pad = self.selected_pad_index\n    if selected_pad is None:\n        self.notify(\"Select a pad first\", severity=\"warning\")\n        return\n\n    # Check if pad has a sample\n    pad = self.editor.get_pad(selected_pad)\n    if not pad.is_assigned or not pad.sample:\n        self.notify(\"Pad is already empty\", severity=\"warning\")\n        return\n\n    # Show confirmation modal\n    def handle_confirmation(confirmed: bool) -&gt; None:\n        if not confirmed:\n            return\n\n        try:\n            # Clear pad (events handle audio/UI sync automatically)\n            _ = self.editor.clear_pad(selected_pad)\n\n            self.notify(\"Pad deleted\")\n        except Exception as e:\n            logger.error(f\"Error deleting pad: {e}\")\n            self.notify(f\"Error: {e}\", severity=\"error\")\n\n    self.push_screen(\n        ClearConfirmationModal(selected_pad, pad.sample.name),\n        handle_confirmation\n    )\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_up","title":"<code>action_navigate_up()</code>","text":"<p>Navigate to pad above current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_up(self) -&gt; None:\n    \"\"\"Navigate to pad above current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"up\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_down","title":"<code>action_navigate_down()</code>","text":"<p>Navigate to pad below current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_down(self) -&gt; None:\n    \"\"\"Navigate to pad below current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"down\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_left","title":"<code>action_navigate_left()</code>","text":"<p>Navigate to pad left of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_left(self) -&gt; None:\n    \"\"\"Navigate to pad left of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"left\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_navigate_right","title":"<code>action_navigate_right()</code>","text":"<p>Navigate to pad right of current selection.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_navigate_right(self) -&gt; None:\n    \"\"\"Navigate to pad right of current selection.\"\"\"\n    if self._sampler_mode != \"edit\" or self.selected_pad_index is None:\n        return\n\n    new_index = self.navigation.get_neighbor(self.selected_pad_index, \"right\")\n    if new_index is not None:\n        try:\n            self.select_pad(new_index)  # Event system handles UI sync\n        except Exception as e:\n            logger.error(f\"Error navigating: {e}\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_up","title":"<code>action_duplicate_up()</code>","text":"<p>Duplicate selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_up(self) -&gt; None:\n    \"\"\"Duplicate selected pad upward.\"\"\"\n    self._duplicate_directional(\"up\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_down","title":"<code>action_duplicate_down()</code>","text":"<p>Duplicate selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_down(self) -&gt; None:\n    \"\"\"Duplicate selected pad downward.\"\"\"\n    self._duplicate_directional(\"down\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_left","title":"<code>action_duplicate_left()</code>","text":"<p>Duplicate selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_left(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the left.\"\"\"\n    self._duplicate_directional(\"left\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_duplicate_right","title":"<code>action_duplicate_right()</code>","text":"<p>Duplicate selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_duplicate_right(self) -&gt; None:\n    \"\"\"Duplicate selected pad to the right.\"\"\"\n    self._duplicate_directional(\"right\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_up","title":"<code>action_move_up()</code>","text":"<p>Move selected pad upward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_up(self) -&gt; None:\n    \"\"\"Move selected pad upward.\"\"\"\n    self._move_directional(\"up\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_down","title":"<code>action_move_down()</code>","text":"<p>Move selected pad downward.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_down(self) -&gt; None:\n    \"\"\"Move selected pad downward.\"\"\"\n    self._move_directional(\"down\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_left","title":"<code>action_move_left()</code>","text":"<p>Move selected pad to the left.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_left(self) -&gt; None:\n    \"\"\"Move selected pad to the left.\"\"\"\n    self._move_directional(\"left\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_move_right","title":"<code>action_move_right()</code>","text":"<p>Move selected pad to the right.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_move_right(self) -&gt; None:\n    \"\"\"Move selected pad to the right.\"\"\"\n    self._move_directional(\"right\")\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_test_pad","title":"<code>action_test_pad()</code>","text":"<p>Test the selected pad (works in both modes).</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_test_pad(self) -&gt; None:\n    \"\"\"Test the selected pad (works in both modes).\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if pad.is_assigned:\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_toggle_test","title":"<code>action_toggle_test()</code>","text":"<p>Toggle between test and stop for the selected pad.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_toggle_test(self) -&gt; None:\n    \"\"\"Toggle between test and stop for the selected pad.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    pad = self.editor.get_pad(self.selected_pad_index)\n    if not pad.is_assigned:\n        return\n\n    # Check if pad is currently playing\n    if self.player.is_pad_playing(self.selected_pad_index):\n        # Stop the pad - goes through queue and fires proper events\n        self.player.stop_pad(self.selected_pad_index)\n    else:\n        # Start the pad\n        self.player.trigger_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_stop_audio","title":"<code>action_stop_audio()</code>","text":"<p>Stop all audio playback.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_stop_audio(self) -&gt; None:\n    \"\"\"Stop all audio playback.\"\"\"\n    self.player.stop_all()\n\n    # Also release selected pad if in HOLD mode\n    if self.selected_pad_index is not None:\n        self.player.release_pad(self.selected_pad_index)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_one_shot","title":"<code>action_set_mode_one_shot()</code>","text":"<p>Set selected pad to one-shot mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_one_shot(self) -&gt; None:\n    \"\"\"Set selected pad to one-shot mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.ONE_SHOT)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_toggle","title":"<code>action_set_mode_toggle()</code>","text":"<p>Set selected pad to toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.TOGGLE)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_hold","title":"<code>action_set_mode_hold()</code>","text":"<p>Set selected pad to hold mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_hold(self) -&gt; None:\n    \"\"\"Set selected pad to hold mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.HOLD)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_loop","title":"<code>action_set_mode_loop()</code>","text":"<p>Set selected pad to loop mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop(self) -&gt; None:\n    \"\"\"Set selected pad to loop mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP)\n</code></pre>"},{"location":"api/tui/app/#launchsampler.tui.app.LaunchpadSampler.action_set_mode_loop_toggle","title":"<code>action_set_mode_loop_toggle()</code>","text":"<p>Set selected pad to loop toggle mode.</p> Source code in <code>src/launchsampler/tui/app.py</code> <pre><code>def action_set_mode_loop_toggle(self) -&gt; None:\n    \"\"\"Set selected pad to loop toggle mode.\"\"\"\n    self._set_pad_mode(PlaybackMode.LOOP_TOGGLE)\n</code></pre>"},{"location":"api/tui/decorators/","title":"Decorators","text":""},{"location":"api/tui/decorators/#launchsampler.tui.decorators","title":"<code>decorators</code>","text":"<p>Decorators for TUI components.</p>"},{"location":"api/tui/decorators/#launchsampler.tui.decorators.require_mode","title":"<code>require_mode(*modes)</code>","text":"<p>Decorator to restrict action to specific sampler mode(s).</p> <p>Parameters:</p> Name Type Description Default <code>*modes</code> <p>One or more mode names (e.g., \"edit\", \"play\")</p> <code>()</code> <p>If the app is not in one of the specified modes, the decorated method will return immediately without executing.</p> Example <p>@require_mode(\"edit\") def action_copy_pad(self):     ...</p> <p>@require_mode(\"edit\", \"play\") def action_save(self):     ...</p> Source code in <code>src/launchsampler/tui/decorators.py</code> <pre><code>def require_mode(*modes):\n    \"\"\"Decorator to restrict action to specific sampler mode(s).\n\n    Args:\n        *modes: One or more mode names (e.g., \"edit\", \"play\")\n\n    If the app is not in one of the specified modes, the decorated\n    method will return immediately without executing.\n\n    Example:\n        @require_mode(\"edit\")\n        def action_copy_pad(self):\n            ...\n\n        @require_mode(\"edit\", \"play\")\n        def action_save(self):\n            ...\n    \"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            if self._sampler_mode not in modes:\n                return\n            return func(self, *args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/tui/decorators/#launchsampler.tui.decorators.handle_action_errors","title":"<code>handle_action_errors(operation_name)</code>","text":"<p>Decorator for TUI action methods that wraps the centralized error handler.</p> <p>This is a TUI-specific wrapper around the centralized error handler that: - Uses self.notify for user notifications - Doesn't re-raise exceptions (keeps TUI responsive) - Returns None on error</p> Example <p>@handle_action_errors(\"cut pad\") def action_cut_pad(self):     ...</p> Source code in <code>src/launchsampler/tui/decorators.py</code> <pre><code>def handle_action_errors(operation_name: str):\n    \"\"\"\n    Decorator for TUI action methods that wraps the centralized error handler.\n\n    This is a TUI-specific wrapper around the centralized error handler that:\n    - Uses self.notify for user notifications\n    - Doesn't re-raise exceptions (keeps TUI responsive)\n    - Returns None on error\n\n    Example:\n        @handle_action_errors(\"cut pad\")\n        def action_cut_pad(self):\n            ...\n    \"\"\"\n    def decorator(func):\n        # Get the method's self instance\n        @wraps(func)\n        def wrapper(self, *args, **kwargs):\n            # Create the error handler with TUI-specific settings\n            handler = _handle_errors(\n                operation_name=operation_name,\n                user_notification=lambda msg: self.notify(msg, severity=\"error\", timeout=5),\n                re_raise=False,\n                fallback_value=None\n            )\n            # Apply the handler and call the function\n            wrapped = handler(func)\n            return wrapped(self, *args, **kwargs)\n        return wrapper\n    return decorator\n</code></pre>"},{"location":"api/tui/screens/base_browser/","title":"Base Browser","text":""},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser","title":"<code>base_browser</code>","text":"<p>Abstract base class for file/directory browser screens.</p>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.FilteredDirectoryTree","title":"<code>FilteredDirectoryTree</code>","text":"<p>               Bases: <code>DirectoryTree</code></p> <p>DirectoryTree that filters out hidden files and directories.</p>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.FilteredDirectoryTree.filter_paths","title":"<code>filter_paths(paths)</code>","text":"<p>Filter out hidden files and directories (those starting with a dot).</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>Iterable[Path]</code> <p>Iterable of Path objects to filter</p> required <p>Returns:</p> Type Description <code>Iterable[Path]</code> <p>Filtered iterable of Path objects</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def filter_paths(self, paths: Iterable[Path]) -&gt; Iterable[Path]:\n    \"\"\"\n    Filter out hidden files and directories (those starting with a dot).\n\n    Args:\n        paths: Iterable of Path objects to filter\n\n    Returns:\n        Filtered iterable of Path objects\n    \"\"\"\n    return [path for path in paths if not path.name.startswith(\".\")]\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen","title":"<code>BaseBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>Screen</code></p> <p>Abstract base class for all file/directory browser screens.</p> <p>Provides common functionality for navigating directories, path input, keyboard shortcuts, and consistent styling. Subclasses implement specific selection logic and validation.</p> <p>Subclasses must implement: - _is_valid_selection(path): Validate if a path can be selected - _get_selection_value(): Get the value to return on dismiss - _get_title(): Return the screen title - _get_instructions(): Return usage instructions</p> <p>Initialize browser.</p> <p>Parameters:</p> Name Type Description Default <code>start_dir</code> <code>Path</code> <p>Directory to start browsing from</p> required Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_ignore","title":"<code>action_ignore()</code>","text":"<p>No-op action to disable parent bindings.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_ignore(self) -&gt; None:\n    \"\"\"No-op action to disable parent bindings.\"\"\"\n    pass\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.compose","title":"<code>compose()</code>","text":"<p>Create the browser layout.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the browser layout.\"\"\"\n    with Vertical():\n        yield Label(self._get_title(), id=\"title\")\n        yield FilteredDirectoryTree(str(self.start_dir), id=\"tree\")\n        yield Input(\n            value=str(self.start_dir),\n            placeholder=\"Enter or paste directory path...\",\n            id=\"path-input\"\n        )\n\n        # Allow subclasses to add extra widgets\n        extra_widgets = self._get_extra_widgets()\n        if extra_widgets:\n            with Container(id=\"extra-widgets\"):\n                for widget in extra_widgets:\n                    yield widget\n\n        yield Label(self._get_instructions(), id=\"instructions\")\n\n        with Horizontal(id=\"button-row\"):\n            for button in self._get_buttons():\n                yield button\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_directory_tree_directory_selected","title":"<code>on_directory_tree_directory_selected(event)</code>","text":"<p>Handle directory selection in tree.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_directory_tree_directory_selected(\n    self, event: DirectoryTree.DirectorySelected\n) -&gt; None:\n    \"\"\"Handle directory selection in tree.\"\"\"\n    self._on_tree_directory_selected(event)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_directory_tree_file_selected","title":"<code>on_directory_tree_file_selected(event)</code>","text":"<p>Handle file selection in tree.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_directory_tree_file_selected(\n    self, event: DirectoryTree.FileSelected\n) -&gt; None:\n    \"\"\"Handle file selection in tree.\"\"\"\n    self._on_tree_file_selected(event)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle path input submission (Enter key in input field).</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle path input submission (Enter key in input field).\"\"\"\n    if event.input.id == \"path-input\":\n        self._navigate_to_path(event.value)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_input_blurred","title":"<code>on_input_blurred(event)</code>","text":"<p>Handle input losing focus - navigate to the entered path.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_input_blurred(self, event: Input.Blurred) -&gt; None:\n    \"\"\"Handle input losing focus - navigate to the entered path.\"\"\"\n    if event.input.id == \"path-input\":\n        self._navigate_to_path(event.input.value)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"select-btn\":\n        self._confirm_selection()\n    elif event.button.id == \"cancel-btn\":\n        self.dismiss(None)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_select_current","title":"<code>action_select_current()</code>","text":"<p>Select the currently highlighted item.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_select_current(self) -&gt; None:\n    \"\"\"Select the currently highlighted item.\"\"\"\n    tree = self.query_one(\"#tree\", DirectoryTree)\n    if tree.cursor_node:\n        cursor_path = Path(str(tree.cursor_node.data.path))\n        self.selected_path = cursor_path\n        self._confirm_selection()\n    else:\n        # Fallback to selected_path if no cursor\n        self._confirm_selection()\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.action_cancel","title":"<code>action_cancel()</code>","text":"<p>Cancel and close the screen.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def action_cancel(self) -&gt; None:\n    \"\"\"Cancel and close the screen.\"\"\"\n    self.dismiss(None)\n</code></pre>"},{"location":"api/tui/screens/base_browser/#launchsampler.tui.screens.base_browser.BaseBrowserScreen.on_key","title":"<code>on_key(event)</code>","text":"<p>Handle key presses - intercept enter for selection, left/right for navigation.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def on_key(self, event: events.Key) -&gt; None:\n    \"\"\"Handle key presses - intercept enter for selection, left/right for navigation.\"\"\"\n    if event.key == \"enter\":\n        event.prevent_default()\n        event.stop()\n        self.action_select_current()\n    elif event.key == \"right\":\n        # Expand the current node (step into folder)\n        tree = self.query_one(\"#tree\", DirectoryTree)\n        if tree.cursor_node and not tree.cursor_node.is_expanded:\n            tree.cursor_node.expand()\n            event.prevent_default()\n            event.stop()\n    elif event.key == \"left\":\n        # Collapse current node, go to parent, or navigate up past root\n        tree = self.query_one(\"#tree\", DirectoryTree)\n        if tree.cursor_node:\n            if tree.cursor_node.is_expanded:\n                # If expanded, collapse it\n                tree.cursor_node.collapse()\n                event.prevent_default()\n                event.stop()\n            elif tree.cursor_node.parent:\n                # If collapsed, move to parent\n                tree.select_node(tree.cursor_node.parent)\n                event.prevent_default()\n                event.stop()\n            else:\n                # We're at the root node, navigate up one directory level\n                current_path = Path(str(tree.cursor_node.data.path))\n                parent_path = current_path.parent\n                if parent_path != current_path:  # Make sure we're not at filesystem root\n                    self.run_worker(self._navigate_to_directory(parent_path))\n                    event.prevent_default()\n                    event.stop()\n</code></pre>"},{"location":"api/tui/screens/directory_browser/","title":"Directory Browser","text":""},{"location":"api/tui/screens/directory_browser/#launchsampler.tui.screens.directory_browser","title":"<code>directory_browser</code>","text":"<p>Directory browser screen for loading samples from a folder.</p>"},{"location":"api/tui/screens/directory_browser/#launchsampler.tui.screens.directory_browser.DirectoryBrowserScreen","title":"<code>DirectoryBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting directories containing samples.</p> <p>Displays a directory tree and allows selection of directories. User can select a directory by pressing Enter on it or using the \"Select\" button.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/file_browser/","title":"File Browser","text":""},{"location":"api/tui/screens/file_browser/#launchsampler.tui.screens.file_browser","title":"<code>file_browser</code>","text":"<p>File browser screen for selecting audio samples.</p>"},{"location":"api/tui/screens/file_browser/#launchsampler.tui.screens.file_browser.FileBrowserScreen","title":"<code>FileBrowserScreen(start_dir)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting audio sample files.</p> <p>Displays a directory tree and allows selection of audio files (.wav, .mp3, .flac, .ogg, .aiff). Automatically selects and dismisses when an audio file is chosen.</p> Source code in <code>src/launchsampler/tui/screens/base_browser.py</code> <pre><code>def __init__(self, start_dir: Path) -&gt; None:\n    \"\"\"\n    Initialize browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n    \"\"\"\n    super().__init__()\n    self.start_dir = start_dir\n    self.selected_path: Path = start_dir\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/","title":"Save Set Browser","text":""},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser","title":"<code>save_set_browser</code>","text":"<p>Save set browser screen for choosing save location and filename.</p>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen","title":"<code>SaveSetBrowserScreen(start_dir, default_name='untitled')</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for selecting save location and entering filename for sets.</p> <p>Displays a directory tree to choose location, with an input field for entering the set name. Returns a tuple of (directory, filename).</p> <p>Initialize save set browser.</p> <p>Parameters:</p> Name Type Description Default <code>start_dir</code> <code>Path</code> <p>Directory to start browsing from</p> required <code>default_name</code> <code>str</code> <p>Default name for the set</p> <code>'untitled'</code> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def __init__(self, start_dir: Path, default_name: str = \"untitled\") -&gt; None:\n    \"\"\"\n    Initialize save set browser.\n\n    Args:\n        start_dir: Directory to start browsing from\n        default_name: Default name for the set\n    \"\"\"\n    super().__init__(start_dir)\n    self.default_name = default_name\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen.on_mount","title":"<code>on_mount()</code>","text":"<p>Focus the filename input when mounted.</p> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def on_mount(self) -&gt; None:\n    \"\"\"Focus the filename input when mounted.\"\"\"\n    # Give focus to the name input after a brief delay\n    # (need to wait for tree to be mounted first)\n    self.set_timer(0.1, self._focus_name_input)\n</code></pre>"},{"location":"api/tui/screens/save_set_browser/#launchsampler.tui.screens.save_set_browser.SaveSetBrowserScreen.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle input submission.</p> Source code in <code>src/launchsampler/tui/screens/save_set_browser.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle input submission.\"\"\"\n    if event.input.id == \"name-input\":\n        # Name input submitted - try to save\n        self._confirm_selection()\n    elif event.input.id == \"path-input\":\n        # Path input submitted - navigate\n        self._navigate_to_path(event.value)\n</code></pre>"},{"location":"api/tui/screens/set_file_browser/","title":"Set File Browser","text":""},{"location":"api/tui/screens/set_file_browser/#launchsampler.tui.screens.set_file_browser","title":"<code>set_file_browser</code>","text":"<p>Set file browser screen for loading saved sets.</p>"},{"location":"api/tui/screens/set_file_browser/#launchsampler.tui.screens.set_file_browser.SetFileBrowserScreen","title":"<code>SetFileBrowserScreen(set_manager, *args, **kwargs)</code>","text":"<p>               Bases: <code>BaseBrowserScreen</code></p> <p>Screen for browsing and selecting saved set files (.json).</p> <p>Displays a directory tree and allows selection of set files. Shows metadata about sets when available. User can navigate anywhere on the filesystem to find set files.</p> <p>Initialize the set file browser.</p> <p>Parameters:</p> Name Type Description Default <code>set_manager</code> <code>SetManagerService</code> <p>Service for loading sets</p> required Source code in <code>src/launchsampler/tui/screens/set_file_browser.py</code> <pre><code>def __init__(self, set_manager: \"SetManagerService\", *args, **kwargs):\n    \"\"\"\n    Initialize the set file browser.\n\n    Args:\n        set_manager: Service for loading sets\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.set_manager = set_manager\n</code></pre>"},{"location":"api/tui/services/navigation_service/","title":"Navigation Service","text":""},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service","title":"<code>navigation_service</code>","text":"<p>Grid navigation service for directional pad operations.</p> <p>This service handles pure grid geometry logic for navigating the 8x8 Launchpad grid. It is UI-agnostic and can be reused by different UI implementations (TUI, LED UI, etc.).</p> <p>Responsibilities: - Calculate neighboring pad indices in cardinal directions (up, down, left, right) - Validate grid boundaries before navigation - Pure functions with no side effects</p> <p>Design Principles: - Single Responsibility: Only grid geometry, no UI or business logic - Testable: No dependencies on Textual or UI framework - Reusable: Can be used by TUI, LED UI, or any other UI implementation</p>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService","title":"<code>NavigationService(launchpad)</code>","text":"<p>Service for navigating the Launchpad 8x8 grid.</p> <p>This service provides pure functions for calculating neighboring pad indices in cardinal directions. It respects grid boundaries and returns None when attempting to navigate beyond the grid edge.</p> Example <p>nav = NavigationService(launchpad) nav.get_neighbor(0, \"right\")  # Pad 0 -&gt; Pad 1 1 nav.get_neighbor(0, \"down\")   # Pad 0 -&gt; None (at bottom edge) None nav.get_neighbor(63, \"up\")    # Pad 63 -&gt; None (at top edge) None</p> <p>Initialize the navigation service.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>The Launchpad grid to navigate</p> required Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def __init__(self, launchpad: Launchpad):\n    \"\"\"\n    Initialize the navigation service.\n\n    Args:\n        launchpad: The Launchpad grid to navigate\n    \"\"\"\n    self.launchpad = launchpad\n    self._grid_size = launchpad.GRID_SIZE\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.get_neighbor","title":"<code>get_neighbor(pad_index, direction)</code>","text":"<p>Get the neighboring pad index in the given direction.</p> <p>Validates grid boundaries and returns None if the move would go beyond the grid edge. Uses the same coordinate system as the Launchpad: - X axis: left (0) to right (7) - Y axis: bottom (0) to top (7) - Index 0 is bottom-left, index 63 is top-right</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Current pad index (0-63)</p> required <code>direction</code> <code>Direction</code> <p>Direction to move (\"up\", \"down\", \"left\", \"right\")</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Target pad index, or None if at edge (cannot move in that direction)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pad_index is out of range (not 0-63)</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def get_neighbor(self, pad_index: int, direction: Direction) -&gt; Optional[int]:\n    \"\"\"\n    Get the neighboring pad index in the given direction.\n\n    Validates grid boundaries and returns None if the move would go beyond\n    the grid edge. Uses the same coordinate system as the Launchpad:\n    - X axis: left (0) to right (7)\n    - Y axis: bottom (0) to top (7)\n    - Index 0 is bottom-left, index 63 is top-right\n\n    Args:\n        pad_index: Current pad index (0-63)\n        direction: Direction to move (\"up\", \"down\", \"left\", \"right\")\n\n    Returns:\n        Target pad index, or None if at edge (cannot move in that direction)\n\n    Raises:\n        ValueError: If pad_index is out of range (not 0-63)\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; self.launchpad.TOTAL_PADS:\n        raise ValueError(f\"Pad index {pad_index} out of range (must be 0-63)\")\n\n    # Convert to grid coordinates\n    x, y = self.launchpad.note_to_xy(pad_index)\n\n    # Calculate new coordinates based on direction\n    # Check bounds BEFORE calculating target (fail fast)\n    if direction == \"up\":\n        if y &gt;= self._grid_size - 1:  # Already at top edge\n            return None\n        y = y + 1\n    elif direction == \"down\":\n        if y &lt;= 0:  # Already at bottom edge\n            return None\n        y = y - 1\n    elif direction == \"left\":\n        if x &lt;= 0:  # Already at left edge\n            return None\n        x = x - 1\n    elif direction == \"right\":\n        if x &gt;= self._grid_size - 1:  # Already at right edge\n            return None\n        x = x + 1\n    else:\n        logger.warning(f\"Invalid direction: {direction}\")\n        return None\n\n    # Convert back to pad index\n    return self.launchpad.xy_to_note(x, y)\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.can_move","title":"<code>can_move(pad_index, direction)</code>","text":"<p>Check if a move in the given direction is valid (not at edge).</p> <p>This is a convenience method that combines get_neighbor with a boolean check.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Current pad index (0-63)</p> required <code>direction</code> <code>Direction</code> <p>Direction to check (\"up\", \"down\", \"left\", \"right\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if move is valid, False if at edge or invalid input</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def can_move(self, pad_index: int, direction: Direction) -&gt; bool:\n    \"\"\"\n    Check if a move in the given direction is valid (not at edge).\n\n    This is a convenience method that combines get_neighbor with a boolean check.\n\n    Args:\n        pad_index: Current pad index (0-63)\n        direction: Direction to check (\"up\", \"down\", \"left\", \"right\")\n\n    Returns:\n        True if move is valid, False if at edge or invalid input\n    \"\"\"\n    try:\n        return self.get_neighbor(pad_index, direction) is not None\n    except ValueError:\n        return False\n</code></pre>"},{"location":"api/tui/services/navigation_service/#launchsampler.tui.services.navigation_service.NavigationService.get_edge_position","title":"<code>get_edge_position(pad_index)</code>","text":"<p>Get which edges this pad is on.</p> <p>Useful for UI feedback (e.g., showing disabled directional arrows).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Pad index to check (0-63)</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of edge names (e.g., {\"left\", \"bottom\"} for pad 0)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If pad_index is out of range</p> Source code in <code>src/launchsampler/tui/services/navigation_service.py</code> <pre><code>def get_edge_position(self, pad_index: int) -&gt; set[str]:\n    \"\"\"\n    Get which edges this pad is on.\n\n    Useful for UI feedback (e.g., showing disabled directional arrows).\n\n    Args:\n        pad_index: Pad index to check (0-63)\n\n    Returns:\n        Set of edge names (e.g., {\"left\", \"bottom\"} for pad 0)\n\n    Raises:\n        ValueError: If pad_index is out of range\n    \"\"\"\n    if not 0 &lt;= pad_index &lt; self.launchpad.TOTAL_PADS:\n        raise ValueError(f\"Pad index {pad_index} out of range (must be 0-63)\")\n\n    x, y = self.launchpad.note_to_xy(pad_index)\n    edges = set()\n\n    if x == 0:\n        edges.add(\"left\")\n    if x == self._grid_size - 1:\n        edges.add(\"right\")\n    if y == 0:\n        edges.add(\"bottom\")\n    if y == self._grid_size - 1:\n        edges.add(\"top\")\n\n    return edges\n</code></pre>"},{"location":"api/tui/services/tui_service/","title":"Tui Service","text":""},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service","title":"<code>tui_service</code>","text":"<p>Service for managing TUI synchronization with application state.</p>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService","title":"<code>TUIService(app)</code>","text":"<p>               Bases: <code>AppObserver</code>, <code>EditObserver</code>, <code>SelectionObserver</code>, <code>MidiObserver</code>, <code>StateObserver</code></p> <p>Service for synchronizing the Terminal UI with application state.</p> <p>This service observes all system events and updates the TUI components (pad grid, details panel, status bar) accordingly. It decouples the application core from UI-specific update logic.</p> <p>Implements multiple observer protocols: - AppObserver: App lifecycle events (SET_MOUNTED, SET_SAVED, etc.) - EditObserver: Editing events (PAD_ASSIGNED, PAD_CLEARED, etc.) - SelectionObserver: Selection events (CHANGED, CLEARED) - UI state only - MidiObserver: MIDI controller events (NOTE_ON, NOTE_OFF, etc.) - StateObserver: Playback events (PAD_PLAYING, PAD_STOPPED, etc.)</p> <p>Initialize the TUI service.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>LaunchpadSampler</code> <p>The LaunchpadSampler application instance</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def __init__(self, app: \"LaunchpadSampler\"):\n    \"\"\"\n    Initialize the TUI service.\n\n    Args:\n        app: The LaunchpadSampler application instance\n    \"\"\"\n    self.app = app\n    logger.info(\"TUIService initialized\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_app_event","title":"<code>on_app_event(event, **kwargs)</code>","text":"<p>Handle application lifecycle events.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>AppEvent</code> <p>The type of application event</p> required <code>**kwargs</code> <p>Event-specific data</p> <code>{}</code> Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_app_event(self, event: AppEvent, **kwargs) -&gt; None:\n    \"\"\"\n    Handle application lifecycle events.\n\n    Args:\n        event: The type of application event\n        **kwargs: Event-specific data\n    \"\"\"\n    try:\n        if event == AppEvent.SET_MOUNTED:\n            self._handle_set_mounted()\n        elif event == AppEvent.SET_SAVED:\n            self._handle_set_saved(**kwargs)\n        elif event == AppEvent.SET_AUTO_CREATED:\n            self._handle_set_auto_created(**kwargs)\n        elif event == AppEvent.MODE_CHANGED:\n            logger.info(f\"TUIService handling MODE_CHANGED event: {kwargs}\")\n            self._handle_mode_changed(**kwargs)\n        else:\n            logger.warning(f\"TUIService received unknown app event: {event}\")\n\n    except Exception as e:\n        logger.error(f\"Error handling app event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_edit_event","title":"<code>on_edit_event(event, pad_indices, pads)</code>","text":"<p>Handle editing events and update UI.</p> <p>This is called from the UI thread when editing operations occur. Automatically synchronizes the UI with the new pad states.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>EditEvent</code> <p>The type of editing event</p> required <code>pad_indices</code> <code>list[int]</code> <p>List of affected pad indices</p> required <code>pads</code> <code>list[Pad]</code> <p>List of affected pad states (post-edit)</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_edit_event(\n    self,\n    event: \"EditEvent\",\n    pad_indices: list[int],\n    pads: list[\"Pad\"]\n) -&gt; None:\n    \"\"\"\n    Handle editing events and update UI.\n\n    This is called from the UI thread when editing operations occur.\n    Automatically synchronizes the UI with the new pad states.\n\n    Args:\n        event: The type of editing event\n        pad_indices: List of affected pad indices\n        pads: List of affected pad states (post-edit)\n    \"\"\"\n    logger.debug(f\"TUIService received edit event: {event.value} for pads {pad_indices}\")\n\n    try:\n        # Update content - refresh grid and details if currently selected\n        for pad_index, pad in zip(pad_indices, pads):\n            self._update_pad_ui(pad_index, pad)\n\n    except Exception as e:\n        logger.error(f\"Error handling edit event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_selection_event","title":"<code>on_selection_event(event, pad_index)</code>","text":"<p>Handle selection change events.</p> <p>This is the NEW way to handle selection (replaces EditEvent.PAD_SELECTED). Selection is UI state that doesn't affect persistence or audio.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>SelectionEvent</code> <p>The type of selection event</p> required <code>pad_index</code> <code>Optional[int]</code> <p>Index of selected pad (0-63), or None if cleared</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_selection_event(\n    self,\n    event: \"SelectionEvent\",\n    pad_index: Optional[int]\n) -&gt; None:\n    \"\"\"\n    Handle selection change events.\n\n    This is the NEW way to handle selection (replaces EditEvent.PAD_SELECTED).\n    Selection is UI state that doesn't affect persistence or audio.\n\n    Args:\n        event: The type of selection event\n        pad_index: Index of selected pad (0-63), or None if cleared\n    \"\"\"\n    logger.info(f\"TUIService received selection event: {event.value}, pad: {pad_index}\")\n\n    try:\n        if event == SelectionEvent.CHANGED and pad_index is not None:\n            # Pad selected - update UI\n            pad = self.app.editor.get_pad(pad_index)\n            self._update_selected_pad_ui(pad_index, pad)\n        elif event == SelectionEvent.CLEARED:\n            # Selection cleared - update UI\n            grid = self.app.query_one(PadGrid)\n            grid.clear_selection()\n\n    except Exception as e:\n        logger.error(f\"Error handling selection event {event}: {e}\")\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_midi_event","title":"<code>on_midi_event(event, pad_index, control=0, value=0)</code>","text":"<p>Handle MIDI events from controller.</p> <p>Called from MIDI thread via LaunchpadController, so use call_from_thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>MidiEvent</code> <p>The MIDI event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63), or -1 for connection/CC events</p> required <code>control</code> <code>int</code> <p>MIDI CC control number (for CONTROL_CHANGE events)</p> <code>0</code> <code>value</code> <code>int</code> <p>MIDI CC value (for CONTROL_CHANGE events)</p> <code>0</code> Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_midi_event(self, event: \"MidiEvent\", pad_index: int, control: int = 0, value: int = 0) -&gt; None:\n    \"\"\"\n    Handle MIDI events from controller.\n\n    Called from MIDI thread via LaunchpadController, so use call_from_thread.\n\n    Args:\n        event: The MIDI event that occurred\n        pad_index: Index of the pad (0-63), or -1 for connection/CC events\n        control: MIDI CC control number (for CONTROL_CHANGE events)\n        value: MIDI CC value (for CONTROL_CHANGE events)\n    \"\"\"\n    logger.info(f\"TUI received MIDI event: {event}, pad_index: {pad_index}\")\n\n    if event == MidiEvent.NOTE_ON:\n        # MIDI note on - show green border\n        self.app.call_from_thread(self._set_pad_midi_on_ui, pad_index, True)\n\n    elif event == MidiEvent.NOTE_OFF:\n        # MIDI note off - remove green border\n        self.app.call_from_thread(self._set_pad_midi_on_ui, pad_index, False)\n\n    elif event in (MidiEvent.CONTROLLER_CONNECTED, MidiEvent.CONTROLLER_DISCONNECTED):\n        # MIDI controller connection changed - update status bar\n        self.app.call_from_thread(self._update_status_bar)\n</code></pre>"},{"location":"api/tui/services/tui_service/#launchsampler.tui.services.tui_service.TUIService.on_playback_event","title":"<code>on_playback_event(event, pad_index)</code>","text":"<p>Handle playback events from audio engine.</p> <p>Called from audio thread via callback, so use call_from_thread.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>PlaybackEvent</code> <p>The playback event that occurred</p> required <code>pad_index</code> <code>int</code> <p>Index of the pad (0-63)</p> required Source code in <code>src/launchsampler/tui/services/tui_service.py</code> <pre><code>def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n    \"\"\"\n    Handle playback events from audio engine.\n\n    Called from audio thread via callback, so use call_from_thread.\n\n    Args:\n        event: The playback event that occurred\n        pad_index: Index of the pad (0-63)\n    \"\"\"\n    # Handle audio playback events (yellow background)\n    if event == PlaybackEvent.PAD_PLAYING:\n        # Pad started playing - show as active\n        self.app.call_from_thread(self._set_pad_playing_ui, pad_index, True)\n        # Update status bar for voice count\n        self.app.call_from_thread(self._update_status_bar)\n\n    elif event in (PlaybackEvent.PAD_STOPPED, PlaybackEvent.PAD_FINISHED):\n        # Pad stopped or finished - show as inactive\n        self.app.call_from_thread(self._set_pad_playing_ui, pad_index, False)\n        # Update status bar for voice count\n        self.app.call_from_thread(self._update_status_bar)\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/","title":"Clear Confirmation Modal","text":""},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal","title":"<code>clear_confirmation_modal</code>","text":"<p>Modal dialog for confirming pad clear operations.</p>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal","title":"<code>ClearConfirmationModal(pad_index, sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[bool]</code></p> <p>Modal dialog asking user to confirm clearing a pad.</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to clear</p> required <code>sample_name</code> <code>str</code> <p>Name of sample to clear</p> required Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def __init__(self, pad_index: int, sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        pad_index: Index of pad to clear\n        sample_name: Name of sample to clear\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.sample_name = sample_name\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Delete pad {self.pad_index}?\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.sample_name}\"',\n            id=\"details\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Delete\", variant=\"error\", id=\"clear-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/clear_confirmation_modal/#launchsampler.tui.widgets.clear_confirmation_modal.ClearConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/clear_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"clear-btn\":\n        event.stop()\n        self.dismiss(True)\n    elif event.button.id == \"cancel-btn\":\n        event.stop()\n        self.dismiss(False)\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/","title":"Move Confirmation Modal","text":""},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal","title":"<code>move_confirmation_modal</code>","text":"<p>Modal dialog for confirming pad move operations.</p>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal","title":"<code>MoveConfirmationModal(source_index, target_index, target_sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[str]</code></p> <p>Modal dialog asking user to choose between overwrite or swap.</p> <p>User is presented with two options when moving a sample to an occupied pad: - Overwrite: Replace target sample (source pad becomes empty) - Swap: Exchange samples between source and target pads</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad</p> required <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>target_sample_name</code> <code>str</code> <p>Name of sample in target pad</p> required Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def __init__(self, source_index: int, target_index: int, target_sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        source_index: Index of source pad\n        target_index: Index of target pad\n        target_sample_name: Name of sample in target pad\n    \"\"\"\n    super().__init__()\n    self.source_index = source_index\n    self.target_index = target_index\n    self.target_sample_name = target_sample_name\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Pad {self.target_index} already has a sample\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.target_sample_name}\"',\n            id=\"details\"\n        )\n        yield Label(\n            \"Choose an action:\",\n            id=\"action-prompt\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Swap\", variant=\"success\", id=\"swap-btn\")\n            yield Button(\"Overwrite\", variant=\"error\", id=\"overwrite-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/move_confirmation_modal/#launchsampler.tui.widgets.move_confirmation_modal.MoveConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/move_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"overwrite-btn\":\n        event.stop()\n        self.dismiss(\"overwrite\")\n    elif event.button.id == \"swap-btn\":\n        event.stop()\n        self.dismiss(\"swap\")\n    elif event.button.id == \"cancel-btn\":\n        event.stop()\n        self.dismiss(\"cancel\")\n</code></pre>"},{"location":"api/tui/widgets/pad_details/","title":"Pad Details","text":""},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details","title":"<code>pad_details</code>","text":"<p>Details panel showing information and controls for selected pad.</p>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.NoTabInput","title":"<code>NoTabInput(*args, **kwargs)</code>","text":"<p>               Bases: <code>Input</code></p> <p>Input that doesn't move focus to next field on Enter.</p> <p>Initialize with submit tracking.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize with submit tracking.\"\"\"\n    super().__init__(*args, **kwargs)\n    self._just_submitted = False\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.NoTabInput.action_submit","title":"<code>action_submit()</code>","text":"<p>Override submit action to prevent focus moving to next field.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def action_submit(self) -&gt; None:\n    \"\"\"Override submit action to prevent focus moving to next field.\"\"\"\n    # Run validators and post submitted message\n    self.validate(self.value)\n    self.post_message(self.Submitted(self, self.value))\n    # Set flag to prevent duplicate submission on blur\n    self._just_submitted = True\n    # Focus the grandparent (PadDetailsPanel) to remove focus from input\n    # Structure: PadDetailsPanel &gt; Horizontal &gt; NoTabInput\n    if self.parent and self.parent.parent:\n        self.parent.parent.focus()\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel","title":"<code>PadDetailsPanel()</code>","text":"<p>               Bases: <code>Vertical</code></p> <p>Panel showing details and controls for the selected pad.</p> <p>Displays pad information (index, sample, mode, volume) and provides buttons for editing. Can be set to edit or play mode to disable/enable controls appropriately.</p> <p>Initialize details panel.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize details panel.\"\"\"\n    super().__init__()\n    self.selected_pad_index: Optional[int] = None\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.VolumeChanged","title":"<code>VolumeChanged(pad_index, volume)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when volume is changed.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>volume</code> <code>float</code> <p>New volume (0.0 - 1.0)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, pad_index: int, volume: float) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        volume: New volume (0.0 - 1.0)\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.volume = volume\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.NameChanged","title":"<code>NameChanged(pad_index, name)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when sample name is changed.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>name</code> <code>str</code> <p>New sample name</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, pad_index: int, name: str) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        name: New sample name\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self.name = name\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.MovePadRequested","title":"<code>MovePadRequested(source_index, target_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message sent when user requests to move pad to another location.</p> <p>Initialize message.</p> <p>Parameters:</p> Name Type Description Default <code>source_index</code> <code>int</code> <p>Index of source pad (0-63)</p> required <code>target_index</code> <code>int</code> <p>Index of target pad (0-63)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def __init__(self, source_index: int, target_index: int) -&gt; None:\n    \"\"\"\n    Initialize message.\n\n    Args:\n        source_index: Index of source pad (0-63)\n        target_index: Index of target pad (0-63)\n    \"\"\"\n    super().__init__()\n    self.source_index = source_index\n    self.target_index = target_index\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.compose","title":"<code>compose()</code>","text":"<p>Create the details panel widgets.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the details panel widgets.\"\"\"\n    with Horizontal(classes=\"pad-header\"):\n        yield Label(\"No pad selected\", id=\"pad-info\")\n        yield Label(\"\", id=\"pad-location\")\n\n    with Horizontal(classes=\"move-container\"):\n        yield Label(\"Move to:\", shrink=True)\n        yield NoTabInput(placeholder=\"0-63\", id=\"move-input\", disabled=True)\n\n    yield Rule()\n\n    with Horizontal(classes=\"name-container\"):\n        yield Label(\"Name:\", shrink=True)\n        yield NoTabInput(placeholder=\"Sample name\", id=\"name-input\", disabled=True)\n\n    with Horizontal(classes=\"volume-container\"):\n        yield Label(\"Volume [%]:\", shrink=True)\n        yield NoTabInput(placeholder=\"0-100\", id=\"volume-input\", type=\"integer\", disabled=True)\n\n    with RadioSet(id=\"mode-radio\"):\n        yield RadioButton(\"\\\\[1] One Shot\", id=\"mode-oneshot\", disabled=True)\n        yield RadioButton(\"\\\\[2] Toggle\", id=\"mode-toggle\", disabled=True)\n        yield RadioButton(\"\\\\[3] Hold\", id=\"mode-hold\", disabled=True)\n        yield RadioButton(\"\\\\[4] Loop\", id=\"mode-loop\", disabled=True)\n        yield RadioButton(\"\\\\[5] Loop Toggle\", id=\"mode-looptoggle\", disabled=True)\n\n    yield Rule()\n    with Grid(classes=\"button-grid\"):\n        yield Button(\"[\u25aa] Browse\", id=\"browse-btn\", variant=\"primary\", disabled=True)\n        yield Button(\"\\\\[X] Delete\", id=\"clear-btn\", variant=\"default\", disabled=True)\n\n    yield Rule()\n    yield Label(\"\", id=\"sample-info\") # gets updated by update_for_pad\n\n    with Grid(classes=\"control-buttons\"):\n        yield Button(\"\u25b6\", id=\"test-btn\", variant=\"success\", disabled=True)\n        yield Button(\"\u25a0\", id=\"stop-btn\", variant=\"error\", disabled=True)\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.update_for_pad","title":"<code>update_for_pad(pad_index, pad, audio_data=None)</code>","text":"<p>Update the panel to show info for selected pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of selected pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model instance</p> required <code>audio_data</code> <code>Optional[AudioData]</code> <p>Optional AudioData object for the loaded sample</p> <code>None</code> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def update_for_pad(self, pad_index: int, pad: Pad, audio_data: Optional[AudioData] = None) -&gt; None:\n    \"\"\"\n    Update the panel to show info for selected pad.\n\n    Args:\n        pad_index: Index of selected pad (0-63)\n        pad: Pad model instance\n        audio_data: Optional AudioData object for the loaded sample\n    \"\"\"\n    self.selected_pad_index = pad_index\n\n    # Update pad info labels\n    pad_info = self.query_one(\"#pad-info\", Label)\n    pad_info.update(f\"[b]Pad {pad_index}[/b]\")\n\n    pad_location = self.query_one(\"#pad-location\", Label)\n    pad_location.update(f\"[{pad_index % 8}, {pad_index // 8}]\")\n\n    # Update sample info\n    sample_info = self.query_one(\"#sample-info\", Label)\n    if pad.is_assigned and pad.sample:\n        # Build audio info string if audio data available\n        audio_info_str = \"\"\n        if audio_data is not None:\n            audio_info_str = f\"\\nDuration: {audio_data.duration:.2f}s\"\n            audio_info_str += f\"\\nSample Rate: {audio_data.sample_rate} Hz\"\n            audio_info_str += f\"\\nChannels: {audio_data.num_channels}\"\n\n            # Add format info if available\n            if audio_data.format:\n                audio_info_str += f\"\\nFormat: {audio_data.format}\"\n                if audio_data.subtype:\n                    audio_info_str += f\" ({audio_data.subtype})\"\n\n            # Add file size\n            info = audio_data.get_info()\n            audio_info_str += f\"\\nSize: {info['size_str']}\"\n        else:\n            audio_info_str = \"\\n[b]\u26a0\ufe0f File not found[/b]\"\n\n        sample_info.update(\n            f\"Path: {pad.sample.path}\"\n            f\"{audio_info_str}\"\n        )\n    else:\n        sample_info.update(\"[dim]No sample assigned[/dim]\")\n\n    # Update name input\n    name_input = self.query_one(\"#name-input\", Input)\n    if pad.is_assigned and pad.sample:\n        name_input.value = pad.sample.name\n    else:\n        name_input.value = \"\"\n\n    # Update volume input\n    volume_input = self.query_one(\"#volume-input\", Input)\n    if pad.is_assigned:\n        volume_input.value = str(int(pad.volume * 100))\n    else:\n        volume_input.value = \"\"\n\n    # Clear move input\n    move_input = self.query_one(\"#move-input\", Input)\n    move_input.value = \"\"\n\n    # Update button states based on pad and mode\n    self._update_button_states(pad)\n</code></pre>"},{"location":"api/tui/widgets/pad_details/#launchsampler.tui.widgets.pad_details.PadDetailsPanel.on_input_submitted","title":"<code>on_input_submitted(event)</code>","text":"<p>Handle input submissions.</p> Source code in <code>src/launchsampler/tui/widgets/pad_details.py</code> <pre><code>def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    \"\"\"Handle input submissions.\"\"\"\n    if self.selected_pad_index is None:\n        return\n\n    if event.input.id == \"name-input\":\n        # Update sample name\n        name = event.value.strip()\n        if name:  # Only update if not empty\n            self.post_message(self.NameChanged(self.selected_pad_index, name))\n\n    elif event.input.id == \"volume-input\":\n        try:\n            # Parse volume as percentage (0-100)\n            volume_percent = int(event.value)\n            if 0 &lt;= volume_percent &lt;= 100:\n                volume = volume_percent / 100.0\n                # Post message for parent to handle\n                self.post_message(self.VolumeChanged(self.selected_pad_index, volume))\n        except ValueError:\n            # Invalid input, keep current value\n            pass\n\n    elif event.input.id == \"move-input\":\n        try:\n            # Parse target pad index (0-63)\n            target_index = int(event.value)\n            if 0 &lt;= target_index &lt;= 63:\n                # Post message for parent to handle\n                self.post_message(self.MovePadRequested(self.selected_pad_index, target_index))\n                # Clear the input after submission\n                event.input.value = \"\"\n            else:\n                # Out of range, clear it\n                event.input.value = \"\"\n        except ValueError:\n            # Invalid input, clear it\n            event.input.value = \"\"\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/","title":"Pad Grid","text":""},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid","title":"<code>pad_grid</code>","text":"<p>Grid widget containing 8x8 pad widgets.</p>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid","title":"<code>PadGrid()</code>","text":"<p>               Bases: <code>Container</code></p> <p>8x8 grid of pad widgets (layout container).</p> <p>Arranges 64 pad widgets in an 8x8 grid layout, matching the physical Launchpad layout. Handles pad selection visualization and forwards selection events to parent.</p> <p>This widget is stateless - it doesn't store the launchpad model. Pad data is passed explicitly when needed (data-driven approach).</p> <p>Initialize empty pad grid.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize empty pad grid.\"\"\"\n    super().__init__()\n    # Map pad_index to widget\n    self.pad_widgets: dict[int, PadWidget] = {}\n    self._initialized = False\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.PadSelected","title":"<code>PadSelected(pad_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message posted when any pad is selected.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def __init__(self, pad_index: int):\n    super().__init__()\n    self.pad_index = pad_index\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.compose","title":"<code>compose()</code>","text":"<p>Create empty grid structure.</p> <p>Actual pad widgets are created later via initialize_pads() after the launchpad data is available.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"\n    Create empty grid structure.\n\n    Actual pad widgets are created later via initialize_pads()\n    after the launchpad data is available.\n    \"\"\"\n    # Return empty - will be populated via initialize_pads()\n    return []\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.initialize_pads","title":"<code>initialize_pads(launchpad)</code>","text":"<p>Initialize the grid with pad widgets from launchpad data.</p> <p>This is called after the widget is mounted and launchpad data is available.</p> <p>Parameters:</p> Name Type Description Default <code>launchpad</code> <code>Launchpad</code> <p>Launchpad model containing all pad data</p> required <p>Launchpad layout: (0,0) is bottom-left, (7,7) is top-right Grid layout: top-left to bottom-right So we flip vertically: iterate from row 7 down to row 0</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def initialize_pads(self, launchpad: Launchpad) -&gt; None:\n    \"\"\"\n    Initialize the grid with pad widgets from launchpad data.\n\n    This is called after the widget is mounted and launchpad data\n    is available.\n\n    Args:\n        launchpad: Launchpad model containing all pad data\n\n    Launchpad layout: (0,0) is bottom-left, (7,7) is top-right\n    Grid layout: top-left to bottom-right\n    So we flip vertically: iterate from row 7 down to row 0\n    \"\"\"\n    if self._initialized:\n        # Clear existing widgets\n        for widget in self.pad_widgets.values():\n            widget.remove()\n        self.pad_widgets.clear()\n\n    # Iterate rows from 7 (top) to 0 (bottom)\n    for y in range(7, -1, -1):\n        # Iterate columns from 0 (left) to 7 (right)\n        for x in range(8):\n            # Calculate pad index: row * 8 + col\n            i = y * 8 + x\n            pad = launchpad.pads[i]\n            widget = PadWidget(i, pad)\n\n            # Store widget by pad_index\n            self.pad_widgets[i] = widget\n            self.mount(widget)\n\n    self._initialized = True\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.update_pad","title":"<code>update_pad(pad_index, pad)</code>","text":"<p>Update a specific pad's display.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to update (0-63)</p> required <code>pad</code> <code>Pad</code> <p>New pad state (explicitly passed)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def update_pad(self, pad_index: int, pad: Pad) -&gt; None:\n    \"\"\"\n    Update a specific pad's display.\n\n    Args:\n        pad_index: Index of pad to update (0-63)\n        pad: New pad state (explicitly passed)\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].update(pad)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.select_pad","title":"<code>select_pad(pad_index)</code>","text":"<p>Visually mark a pad as selected.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad to select (0-63)</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def select_pad(self, pad_index: int) -&gt; None:\n    \"\"\"\n    Visually mark a pad as selected.\n\n    Args:\n        pad_index: Index of pad to select (0-63)\n    \"\"\"\n    # Deselect all pads\n    for widget in self.pad_widgets.values():\n        widget.remove_class(\"selected\")\n\n    # Select target pad\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].add_class(\"selected\")\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.clear_selection","title":"<code>clear_selection()</code>","text":"<p>Clear selection from all pads.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def clear_selection(self) -&gt; None:\n    \"\"\"Clear selection from all pads.\"\"\"\n    for widget in self.pad_widgets.values():\n        widget.remove_class(\"selected\")\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.set_pad_playing","title":"<code>set_pad_playing(pad_index, is_playing)</code>","text":"<p>Set the playing state of a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def set_pad_playing(self, pad_index: int, is_playing: bool) -&gt; None:\n    \"\"\"\n    Set the playing state of a pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        is_playing: Whether the pad is currently playing\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].set_playing(is_playing)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.set_pad_midi_on","title":"<code>set_pad_midi_on(pad_index, midi_on)</code>","text":"<p>Set the MIDI note on/off state of a pad.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>midi_on</code> <code>bool</code> <p>Whether a MIDI note on is held for this pad</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def set_pad_midi_on(self, pad_index: int, midi_on: bool) -&gt; None:\n    \"\"\"\n    Set the MIDI note on/off state of a pad.\n\n    Args:\n        pad_index: Index of pad (0-63)\n        midi_on: Whether a MIDI note on is held for this pad\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].set_midi_on(midi_on)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.set_pad_unavailable","title":"<code>set_pad_unavailable(pad_index, is_unavailable)</code>","text":"<p>Set the unavailable state of a pad (sample file not found).</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of pad (0-63)</p> required <code>is_unavailable</code> <code>bool</code> <p>Whether the pad's sample file is unavailable</p> required Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def set_pad_unavailable(self, pad_index: int, is_unavailable: bool) -&gt; None:\n    \"\"\"\n    Set the unavailable state of a pad (sample file not found).\n\n    Args:\n        pad_index: Index of pad (0-63)\n        is_unavailable: Whether the pad's sample file is unavailable\n    \"\"\"\n    if pad_index in self.pad_widgets:\n        self.pad_widgets[pad_index].set_unavailable(is_unavailable)\n</code></pre>"},{"location":"api/tui/widgets/pad_grid/#launchsampler.tui.widgets.pad_grid.PadGrid.on_pad_widget_selected","title":"<code>on_pad_widget_selected(message)</code>","text":"<p>Handle pad selection from child widgets.</p> <p>Forwards the selection event up to parent container.</p> Source code in <code>src/launchsampler/tui/widgets/pad_grid.py</code> <pre><code>def on_pad_widget_selected(self, message: PadWidget.Selected) -&gt; None:\n    \"\"\"\n    Handle pad selection from child widgets.\n\n    Forwards the selection event up to parent container.\n    \"\"\"\n    # Don't consume the message, let it bubble up\n    message.stop()\n\n    # Post our own message for parent\n    self.post_message(self.PadSelected(message.pad_index))\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/","title":"Pad Widget","text":""},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget","title":"<code>pad_widget</code>","text":"<p>Widget representing a single pad in the grid.</p>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget","title":"<code>PadWidget(pad_index, pad)</code>","text":"<p>               Bases: <code>Static</code></p> <p>Widget representing a single pad (presentation only).</p> <p>Displays pad index, sample name, and applies CSS classes based on playback mode. Posts messages when clicked, allowing parent containers to handle selection logic.</p> <p>Initialize pad widget.</p> <p>Parameters:</p> Name Type Description Default <code>pad_index</code> <code>int</code> <p>Index of this pad (0-63)</p> required <code>pad</code> <code>Pad</code> <p>Pad model instance</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def __init__(self, pad_index: int, pad: Pad) -&gt; None:\n    \"\"\"\n    Initialize pad widget.\n\n    Args:\n        pad_index: Index of this pad (0-63)\n        pad: Pad model instance\n    \"\"\"\n    super().__init__()\n    self.pad_index = pad_index\n    self._pad = pad\n    self._is_playing = False\n    self._midi_on = False\n    self._is_unavailable = False\n    self.update_display()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.Selected","title":"<code>Selected(pad_index)</code>","text":"<p>               Bases: <code>Message</code></p> <p>Message posted when pad is clicked.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def __init__(self, pad_index: int):\n    super().__init__()\n    self.pad_index = pad_index\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.update","title":"<code>update(pad)</code>","text":"<p>Update display with new pad state.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <code>Pad</code> <p>New pad state</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def update(self, pad: Pad) -&gt; None:\n    \"\"\"\n    Update display with new pad state.\n\n    Args:\n        pad: New pad state\n    \"\"\"\n    self._pad = pad\n    self.update_display()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.update_display","title":"<code>update_display()</code>","text":"<p>Render current pad state.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def update_display(self) -&gt; None:\n    \"\"\"Render current pad state.\"\"\"\n    # Clear mode classes (but preserve playing/midi state classes)\n    self.remove_class(\"one_shot\", \"toggle\", \"hold\", \"loop\", \"loop_toggle\", \"empty\")\n\n    if self._pad.is_assigned:\n        # Show pad index and sample name with warning if unavailable\n        name = self._pad.sample.name if self._pad.sample else \"???\"\n\n        # Prepend warning indicator to name if sample file is unavailable\n        if self._is_unavailable:\n            name = f\"!! {name} !!\"\n\n        super().update(f\"[b]{self.pad_index}[/b]\\n{name}\")\n\n        # Add mode class for styling (from centralized colors)\n        self.add_class(self._pad.mode.value)\n    else:\n        # Empty pad\n        super().update(f\"[dim]{self.pad_index}[/dim]\\n\u2014\")\n        self.add_class(\"empty\")\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.set_playing","title":"<code>set_playing(is_playing)</code>","text":"<p>Set the playing state of this pad.</p> <p>Parameters:</p> Name Type Description Default <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def set_playing(self, is_playing: bool) -&gt; None:\n    \"\"\"\n    Set the playing state of this pad.\n\n    Args:\n        is_playing: Whether the pad is currently playing audio\n    \"\"\"\n    if is_playing != self._is_playing:\n        self._is_playing = is_playing\n        if is_playing:\n            self.add_class(\"active\")\n        else:\n            self.remove_class(\"active\")\n        self.refresh()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.set_midi_on","title":"<code>set_midi_on(midi_on)</code>","text":"<p>Set the MIDI note on/off state of this pad.</p> <p>Parameters:</p> Name Type Description Default <code>midi_on</code> <code>bool</code> <p>Whether a MIDI note on is currently held for this pad</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def set_midi_on(self, midi_on: bool) -&gt; None:\n    \"\"\"\n    Set the MIDI note on/off state of this pad.\n\n    Args:\n        midi_on: Whether a MIDI note on is currently held for this pad\n    \"\"\"\n    if midi_on != self._midi_on:\n        self._midi_on = midi_on\n        if midi_on:\n            self.add_class(\"midi_on\")\n        else:\n            self.remove_class(\"midi_on\")\n        self.refresh()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.set_unavailable","title":"<code>set_unavailable(is_unavailable)</code>","text":"<p>Set the unavailable state of this pad (sample file not found).</p> <p>Parameters:</p> Name Type Description Default <code>is_unavailable</code> <code>bool</code> <p>Whether the pad's sample file is unavailable</p> required Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def set_unavailable(self, is_unavailable: bool) -&gt; None:\n    \"\"\"\n    Set the unavailable state of this pad (sample file not found).\n\n    Args:\n        is_unavailable: Whether the pad's sample file is unavailable\n    \"\"\"\n    if is_unavailable != self._is_unavailable:\n        self._is_unavailable = is_unavailable\n        if is_unavailable:\n            self.add_class(\"unavailable\")\n        else:\n            self.remove_class(\"unavailable\")\n        self.update_display()\n</code></pre>"},{"location":"api/tui/widgets/pad_widget/#launchsampler.tui.widgets.pad_widget.PadWidget.on_click","title":"<code>on_click()</code>","text":"<p>Handle click event - post message for parent to handle.</p> Source code in <code>src/launchsampler/tui/widgets/pad_widget.py</code> <pre><code>def on_click(self) -&gt; None:\n    \"\"\"Handle click event - post message for parent to handle.\"\"\"\n    self.post_message(self.Selected(self.pad_index))\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/","title":"Paste Confirmation Modal","text":""},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal","title":"<code>paste_confirmation_modal</code>","text":"<p>Modal dialog for confirming paste operations.</p>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal","title":"<code>PasteConfirmationModal(target_index, current_sample_name)</code>","text":"<p>               Bases: <code>ModalScreen[bool]</code></p> <p>Modal dialog asking user to confirm overwriting a pad on paste.</p> <p>User is presented with two options when pasting to an occupied pad: - Overwrite: Replace target sample with clipboard contents - Cancel: Abort the paste operation</p> <p>Initialize the modal.</p> <p>Parameters:</p> Name Type Description Default <code>target_index</code> <code>int</code> <p>Index of target pad</p> required <code>current_sample_name</code> <code>str</code> <p>Name of sample currently in target pad</p> required Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def __init__(self, target_index: int, current_sample_name: str) -&gt; None:\n    \"\"\"\n    Initialize the modal.\n\n    Args:\n        target_index: Index of target pad\n        current_sample_name: Name of sample currently in target pad\n    \"\"\"\n    super().__init__()\n    self.target_index = target_index\n    self.current_sample_name = current_sample_name\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal.compose","title":"<code>compose()</code>","text":"<p>Create the modal content.</p> Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def compose(self) -&gt; ComposeResult:\n    \"\"\"Create the modal content.\"\"\"\n    with Vertical(id=\"dialog\"):\n        yield Label(\n            f\"Pad {self.target_index} already has a sample\",\n            id=\"question\"\n        )\n        yield Label(\n            f'\"{self.current_sample_name}\"',\n            id=\"details\"\n        )\n        yield Label(\n            \"Overwrite with clipboard contents?\",\n            id=\"action-prompt\"\n        )\n        with Horizontal(id=\"button-container\"):\n            yield Button(\"Overwrite\", variant=\"error\", id=\"overwrite-btn\")\n            yield Button(\"Cancel\", variant=\"default\", id=\"cancel-btn\")\n</code></pre>"},{"location":"api/tui/widgets/paste_confirmation_modal/#launchsampler.tui.widgets.paste_confirmation_modal.PasteConfirmationModal.on_button_pressed","title":"<code>on_button_pressed(event)</code>","text":"<p>Handle button presses.</p> Source code in <code>src/launchsampler/tui/widgets/paste_confirmation_modal.py</code> <pre><code>def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    \"\"\"Handle button presses.\"\"\"\n    if event.button.id == \"overwrite-btn\":\n        self.dismiss(True)\n    elif event.button.id == \"cancel-btn\":\n        self.dismiss(False)\n</code></pre>"},{"location":"api/tui/widgets/status_bar/","title":"Status Bar","text":""},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar","title":"<code>status_bar</code>","text":"<p>Status bar widget showing mode, MIDI status, and active voices.</p>"},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar.StatusBar","title":"<code>StatusBar()</code>","text":"<p>               Bases: <code>Static</code></p> <p>Status bar displaying current application state.</p> <p>Shows: - Current mode (Edit or Play) - MIDI connection status - Active voice count</p> <p>Initialize status bar.</p> Source code in <code>src/launchsampler/tui/widgets/status_bar.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize status bar.\"\"\"\n    super().__init__()\n    self._mode = \"edit\"\n    self._connected = False\n    self._voices = 0\n    self._audio_device = \"No Audio\"\n    self._midi_device = \"No MIDI\"\n    self._update_display()\n</code></pre>"},{"location":"api/tui/widgets/status_bar/#launchsampler.tui.widgets.status_bar.StatusBar.update_state","title":"<code>update_state(mode, connected, voices, audio_device='Unknown', midi_device='No Device')</code>","text":"<p>Update all status information.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>Current mode (\"edit\" or \"play\")</p> required <code>connected</code> <code>bool</code> <p>Whether MIDI is connected</p> required <code>voices</code> <code>int</code> <p>Number of active voices</p> required <code>audio_device</code> <code>str</code> <p>Name of the audio device</p> <code>'Unknown'</code> <code>midi_device</code> <code>str</code> <p>Name of the MIDI device</p> <code>'No Device'</code> Source code in <code>src/launchsampler/tui/widgets/status_bar.py</code> <pre><code>def update_state(\n    self,\n    mode: str,\n    connected: bool,\n    voices: int,\n    audio_device: str = \"Unknown\",\n    midi_device: str = \"No Device\"\n) -&gt; None:\n    \"\"\"\n    Update all status information.\n\n    Args:\n        mode: Current mode (\"edit\" or \"play\")\n        connected: Whether MIDI is connected\n        voices: Number of active voices\n        audio_device: Name of the audio device\n        midi_device: Name of the MIDI device\n    \"\"\"\n    self._mode = mode\n    self._connected = connected\n    self._voices = voices\n    self._audio_device = audio_device\n    self._midi_device = midi_device\n    self._update_display()\n</code></pre>"},{"location":"api/ui_shared/","title":"UI Shared","text":"<p>Shared UI infrastructure (colors, adapters)</p> <p>Shared UI infrastructure for all UI implementations.</p> <p>This package contains shared components used by both TUI and LED UI: - colors: Color definitions and color scheme logic - adapter: UIAdapter protocol for UI lifecycle management</p>"},{"location":"api/ui_shared/#launchsampler.ui_shared.UIAdapter","title":"<code>UIAdapter</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for UI implementations that can be managed by the orchestrator.</p> <p>This protocol allows the orchestrator to manage multiple UI implementations (TUI, LED hardware, web UI, etc.) with a consistent lifecycle.</p> <p>The orchestrator will: 1. Register UIs before initialization (ensuring observers are connected) 2. Initialize services and state (UIs receive all startup events) 3. Run UIs (may block for interactive UIs like TUI) 4. Shutdown UIs on exit</p> <p>UI implementations should: - Register themselves as observers in init - Initialize their widgets/components in initialize() - Block in run() if interactive (TUI), or return immediately if background (LED) - Clean up resources in shutdown()</p>"},{"location":"api/ui_shared/#launchsampler.ui_shared.UIAdapter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the UI before the orchestrator starts.</p> <p>This is called BEFORE the orchestrator fires startup events, so UIs can set up their observer connections and widgets.</p> <p>For Textual UIs, this might create the app instance but not call run(). For hardware UIs (LED), this might initialize GPIO or device connections.</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the UI before the orchestrator starts.\n\n    This is called BEFORE the orchestrator fires startup events,\n    so UIs can set up their observer connections and widgets.\n\n    For Textual UIs, this might create the app instance but not call run().\n    For hardware UIs (LED), this might initialize GPIO or device connections.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/#launchsampler.ui_shared.UIAdapter.run","title":"<code>run()</code>","text":"<p>Run the UI.</p> <p>For interactive UIs (TUI): This should block until the UI exits. For background UIs (LED): This can return immediately after starting.</p> <p>The orchestrator will call this after initialization and startup events.</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the UI.\n\n    For interactive UIs (TUI): This should block until the UI exits.\n    For background UIs (LED): This can return immediately after starting.\n\n    The orchestrator will call this after initialization and startup events.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/#launchsampler.ui_shared.UIAdapter.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the UI and clean up resources.</p> <p>Called when the application is exiting. UIs should: - Unregister observers - Close connections - Release resources</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the UI and clean up resources.\n\n    Called when the application is exiting. UIs should:\n    - Unregister observers\n    - Close connections\n    - Release resources\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/#launchsampler.ui_shared.get_pad_led_color","title":"<code>get_pad_led_color(pad, is_playing=False)</code>","text":"<p>Get the LED color for a pad based on its state.</p> <p>This is the single source of truth for LED colors. Both TUI (via CSS classes) and LED UI (via palette colors) should reflect the same color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <p>The Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The RGB color to display</p> Source code in <code>src/launchsampler/ui_shared/colors.py</code> <pre><code>def get_pad_led_color(pad, is_playing: bool = False) -&gt; Color:\n    \"\"\"Get the LED color for a pad based on its state.\n\n    This is the single source of truth for LED colors.\n    Both TUI (via CSS classes) and LED UI (via palette colors) should\n    reflect the same color scheme.\n\n    Args:\n        pad: The Pad model\n        is_playing: Whether the pad is currently playing audio\n\n    Returns:\n        Color: The RGB color to display\n    \"\"\"\n    # Playing state takes priority\n    if is_playing:\n        return PLAYING_COLOR.rgb\n\n    # Assigned pad shows mode color\n    if pad.is_assigned:\n        return MODE_COLORS[pad.mode].rgb\n\n    # Empty pad is off\n    return EMPTY_COLOR.rgb\n</code></pre>"},{"location":"api/ui_shared/#launchsampler.ui_shared.get_pad_led_palette_index","title":"<code>get_pad_led_palette_index(pad, is_playing=False)</code>","text":"<p>Get the Launchpad palette color index for a pad based on its state.</p> <p>This is for LED UI implementations that need palette indices.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <p>The Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Launchpad palette color index (0-127)</p> Source code in <code>src/launchsampler/ui_shared/colors.py</code> <pre><code>def get_pad_led_palette_index(pad, is_playing: bool = False) -&gt; int:\n    \"\"\"Get the Launchpad palette color index for a pad based on its state.\n\n    This is for LED UI implementations that need palette indices.\n\n    Args:\n        pad: The Pad model\n        is_playing: Whether the pad is currently playing audio\n\n    Returns:\n        int: Launchpad palette color index (0-127)\n    \"\"\"\n    # Playing state takes priority\n    if is_playing:\n        return PLAYING_COLOR.palette\n\n    # Assigned pad shows mode color\n    if pad.is_assigned:\n        return MODE_COLORS[pad.mode].palette\n\n    # Empty pad is off\n    return EMPTY_COLOR.palette\n</code></pre>"},{"location":"api/ui_shared/adapter/","title":"Adapter","text":""},{"location":"api/ui_shared/adapter/#launchsampler.ui_shared.adapter","title":"<code>adapter</code>","text":"<p>UI adapter protocol for multiple UI implementations.</p> <p>This module defines the UIAdapter protocol that allows the orchestrator to manage multiple UI implementations (TUI, LED hardware, web UI, etc.) with a consistent lifecycle.</p>"},{"location":"api/ui_shared/adapter/#launchsampler.ui_shared.adapter.UIAdapter","title":"<code>UIAdapter</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for UI implementations that can be managed by the orchestrator.</p> <p>This protocol allows the orchestrator to manage multiple UI implementations (TUI, LED hardware, web UI, etc.) with a consistent lifecycle.</p> <p>The orchestrator will: 1. Register UIs before initialization (ensuring observers are connected) 2. Initialize services and state (UIs receive all startup events) 3. Run UIs (may block for interactive UIs like TUI) 4. Shutdown UIs on exit</p> <p>UI implementations should: - Register themselves as observers in init - Initialize their widgets/components in initialize() - Block in run() if interactive (TUI), or return immediately if background (LED) - Clean up resources in shutdown()</p>"},{"location":"api/ui_shared/adapter/#launchsampler.ui_shared.adapter.UIAdapter.initialize","title":"<code>initialize()</code>","text":"<p>Initialize the UI before the orchestrator starts.</p> <p>This is called BEFORE the orchestrator fires startup events, so UIs can set up their observer connections and widgets.</p> <p>For Textual UIs, this might create the app instance but not call run(). For hardware UIs (LED), this might initialize GPIO or device connections.</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Initialize the UI before the orchestrator starts.\n\n    This is called BEFORE the orchestrator fires startup events,\n    so UIs can set up their observer connections and widgets.\n\n    For Textual UIs, this might create the app instance but not call run().\n    For hardware UIs (LED), this might initialize GPIO or device connections.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/adapter/#launchsampler.ui_shared.adapter.UIAdapter.run","title":"<code>run()</code>","text":"<p>Run the UI.</p> <p>For interactive UIs (TUI): This should block until the UI exits. For background UIs (LED): This can return immediately after starting.</p> <p>The orchestrator will call this after initialization and startup events.</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the UI.\n\n    For interactive UIs (TUI): This should block until the UI exits.\n    For background UIs (LED): This can return immediately after starting.\n\n    The orchestrator will call this after initialization and startup events.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/adapter/#launchsampler.ui_shared.adapter.UIAdapter.shutdown","title":"<code>shutdown()</code>","text":"<p>Shutdown the UI and clean up resources.</p> <p>Called when the application is exiting. UIs should: - Unregister observers - Close connections - Release resources</p> Source code in <code>src/launchsampler/ui_shared/adapter.py</code> <pre><code>def shutdown(self) -&gt; None:\n    \"\"\"\n    Shutdown the UI and clean up resources.\n\n    Called when the application is exiting. UIs should:\n    - Unregister observers\n    - Close connections\n    - Release resources\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ui_shared/colors/","title":"Colors","text":""},{"location":"api/ui_shared/colors/#launchsampler.ui_shared.colors","title":"<code>colors</code>","text":"<p>UI Color Definitions - Single source of truth for all UI implementations.</p> <p>This module defines the color scheme used across all UI implementations (TUI, LED UI). Both UIs should synchronize their colors based on these definitions.</p> <p>Color Scheme: - Empty pads: Off (black) - Assigned pads: Mode-specific colors (one_shot=red, toggle=orange, hold=blue, loop=green, loop_toggle=magenta) - Playing pads: Yellow - Selected pads (TUI only): Warning color - MIDI-triggered pads (TUI only): Primary color</p> <p>The colors are defined using the LaunchpadColor enum, which contains both RGB values and palette indices for all 128 Launchpad colors. CSS class names are automatically derived from the PlaybackMode enum values.</p>"},{"location":"api/ui_shared/colors/#launchsampler.ui_shared.colors.get_pad_led_color","title":"<code>get_pad_led_color(pad, is_playing=False)</code>","text":"<p>Get the LED color for a pad based on its state.</p> <p>This is the single source of truth for LED colors. Both TUI (via CSS classes) and LED UI (via palette colors) should reflect the same color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <p>The Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Color</code> <code>Color</code> <p>The RGB color to display</p> Source code in <code>src/launchsampler/ui_shared/colors.py</code> <pre><code>def get_pad_led_color(pad, is_playing: bool = False) -&gt; Color:\n    \"\"\"Get the LED color for a pad based on its state.\n\n    This is the single source of truth for LED colors.\n    Both TUI (via CSS classes) and LED UI (via palette colors) should\n    reflect the same color scheme.\n\n    Args:\n        pad: The Pad model\n        is_playing: Whether the pad is currently playing audio\n\n    Returns:\n        Color: The RGB color to display\n    \"\"\"\n    # Playing state takes priority\n    if is_playing:\n        return PLAYING_COLOR.rgb\n\n    # Assigned pad shows mode color\n    if pad.is_assigned:\n        return MODE_COLORS[pad.mode].rgb\n\n    # Empty pad is off\n    return EMPTY_COLOR.rgb\n</code></pre>"},{"location":"api/ui_shared/colors/#launchsampler.ui_shared.colors.get_pad_led_palette_index","title":"<code>get_pad_led_palette_index(pad, is_playing=False)</code>","text":"<p>Get the Launchpad palette color index for a pad based on its state.</p> <p>This is for LED UI implementations that need palette indices.</p> <p>Parameters:</p> Name Type Description Default <code>pad</code> <p>The Pad model</p> required <code>is_playing</code> <code>bool</code> <p>Whether the pad is currently playing audio</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Launchpad palette color index (0-127)</p> Source code in <code>src/launchsampler/ui_shared/colors.py</code> <pre><code>def get_pad_led_palette_index(pad, is_playing: bool = False) -&gt; int:\n    \"\"\"Get the Launchpad palette color index for a pad based on its state.\n\n    This is for LED UI implementations that need palette indices.\n\n    Args:\n        pad: The Pad model\n        is_playing: Whether the pad is currently playing audio\n\n    Returns:\n        int: Launchpad palette color index (0-127)\n    \"\"\"\n    # Playing state takes priority\n    if is_playing:\n        return PLAYING_COLOR.palette\n\n    # Assigned pad shows mode color\n    if pad.is_assigned:\n        return MODE_COLORS[pad.mode].palette\n\n    # Empty pad is off\n    return EMPTY_COLOR.palette\n</code></pre>"},{"location":"api/utils/","title":"Utils","text":"<p>Generic utility functions (paths, formatting)</p> <p>Generic utility modules for launchsampler.</p> <p>This package contains generic utilities that are not specific to any domain: - paths: Path manipulation and common path finding - File size formatting</p>"},{"location":"api/utils/#launchsampler.utils.find_common_path","title":"<code>find_common_path(paths)</code>","text":"<p>Find the most specific common parent path shared by all paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[Path]</code> <p>List of Path objects (can be absolute or relative)</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>The deepest common parent directory, or None if paths is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\nPath('/a/b')\n&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\nPath('/')\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def find_common_path(paths: list[Path]) -&gt; Optional[Path]:\n    \"\"\"Find the most specific common parent path shared by all paths.\n\n    Args:\n        paths: List of Path objects (can be absolute or relative)\n\n    Returns:\n        The deepest common parent directory, or None if paths is empty\n\n    Examples:\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\n        Path('/a/b')\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\n        Path('/')\n    \"\"\"\n    if not paths:\n        return None\n\n    # Convert all paths to absolute for comparison\n    abs_paths = [p.resolve() for p in paths]\n\n    # Get all parent parts for each path\n    all_parts = [list(p.parents)[::-1] + [p.parent] for p in abs_paths]\n\n    # Find common prefix by comparing parts\n    if not all_parts:\n        return None\n\n    common = abs_paths[0].parent\n    for path in abs_paths[1:]:\n        # Find the common ancestor between current common and this path\n        try:\n            # Try to make path relative to common - if it works, common is still valid\n            path.relative_to(common)\n        except ValueError:\n            # Path is not under common, need to go up\n            # Find the actual common ancestor\n            while common != common.parent:  # Don't go above root\n                try:\n                    path.relative_to(common)\n                    break\n                except ValueError:\n                    common = common.parent\n\n    return common\n</code></pre>"},{"location":"api/utils/#launchsampler.utils.format_bytes","title":"<code>format_bytes(size_bytes)</code>","text":"<p>Format byte size as human-readable string.</p> <p>Parameters:</p> Name Type Description Default <code>size_bytes</code> <code>int</code> <p>Size in bytes</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_bytes(500)\n'500 B'\n&gt;&gt;&gt; format_bytes(1536)\n'1.5 KB'\n&gt;&gt;&gt; format_bytes(2621440)\n'2.5 MB'\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def format_bytes(size_bytes: int) -&gt; str:\n    \"\"\"Format byte size as human-readable string.\n\n    Args:\n        size_bytes: Size in bytes\n\n    Returns:\n        Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")\n\n    Examples:\n        &gt;&gt;&gt; format_bytes(500)\n        '500 B'\n        &gt;&gt;&gt; format_bytes(1536)\n        '1.5 KB'\n        &gt;&gt;&gt; format_bytes(2621440)\n        '2.5 MB'\n    \"\"\"\n    if size_bytes &lt; 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes &lt; 1024 * 1024:\n        return f\"{size_bytes / 1024:.1f} KB\"\n    else:\n        return f\"{size_bytes / (1024 * 1024):.1f} MB\"\n</code></pre>"},{"location":"api/utils/paths/","title":"Paths","text":""},{"location":"api/utils/paths/#launchsampler.utils.paths","title":"<code>paths</code>","text":"<p>Path utility functions.</p>"},{"location":"api/utils/paths/#launchsampler.utils.paths.format_bytes","title":"<code>format_bytes(size_bytes)</code>","text":"<p>Format byte size as human-readable string.</p> <p>Parameters:</p> Name Type Description Default <code>size_bytes</code> <code>int</code> <p>Size in bytes</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_bytes(500)\n'500 B'\n&gt;&gt;&gt; format_bytes(1536)\n'1.5 KB'\n&gt;&gt;&gt; format_bytes(2621440)\n'2.5 MB'\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def format_bytes(size_bytes: int) -&gt; str:\n    \"\"\"Format byte size as human-readable string.\n\n    Args:\n        size_bytes: Size in bytes\n\n    Returns:\n        Human-readable size string (e.g., \"1.5 KB\", \"2.3 MB\")\n\n    Examples:\n        &gt;&gt;&gt; format_bytes(500)\n        '500 B'\n        &gt;&gt;&gt; format_bytes(1536)\n        '1.5 KB'\n        &gt;&gt;&gt; format_bytes(2621440)\n        '2.5 MB'\n    \"\"\"\n    if size_bytes &lt; 1024:\n        return f\"{size_bytes} B\"\n    elif size_bytes &lt; 1024 * 1024:\n        return f\"{size_bytes / 1024:.1f} KB\"\n    else:\n        return f\"{size_bytes / (1024 * 1024):.1f} MB\"\n</code></pre>"},{"location":"api/utils/paths/#launchsampler.utils.paths.find_common_path","title":"<code>find_common_path(paths)</code>","text":"<p>Find the most specific common parent path shared by all paths.</p> <p>Parameters:</p> Name Type Description Default <code>paths</code> <code>list[Path]</code> <p>List of Path objects (can be absolute or relative)</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>The deepest common parent directory, or None if paths is empty</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\nPath('/a/b')\n&gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\nPath('/')\n</code></pre> Source code in <code>src/launchsampler/utils/paths.py</code> <pre><code>def find_common_path(paths: list[Path]) -&gt; Optional[Path]:\n    \"\"\"Find the most specific common parent path shared by all paths.\n\n    Args:\n        paths: List of Path objects (can be absolute or relative)\n\n    Returns:\n        The deepest common parent directory, or None if paths is empty\n\n    Examples:\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/a/b/d.wav')])\n        Path('/a/b')\n        &gt;&gt;&gt; find_common_path([Path('/a/b/c.wav'), Path('/x/y/z.wav')])\n        Path('/')\n    \"\"\"\n    if not paths:\n        return None\n\n    # Convert all paths to absolute for comparison\n    abs_paths = [p.resolve() for p in paths]\n\n    # Get all parent parts for each path\n    all_parts = [list(p.parents)[::-1] + [p.parent] for p in abs_paths]\n\n    # Find common prefix by comparing parts\n    if not all_parts:\n        return None\n\n    common = abs_paths[0].parent\n    for path in abs_paths[1:]:\n        # Find the common ancestor between current common and this path\n        try:\n            # Try to make path relative to common - if it works, common is still valid\n            path.relative_to(common)\n        except ValueError:\n            # Path is not under common, need to go up\n            # Find the actual common ancestor\n            while common != common.parent:  # Don't go above root\n                try:\n                    path.relative_to(common)\n                    break\n                except ValueError:\n                    common = common.parent\n\n    return common\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>LaunchSampler follows a clean architecture with clear separation of concerns, event-driven synchronization, and SOLID design principles.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    subgraph \"UI Layer\"\n        TUI[Terminal UI]\n        LED[LED Service]\n    end\n\n    subgraph \"Orchestrator\"\n        APP[LaunchpadSamplerApp]\n    end\n\n    subgraph \"Services\"\n        EDITOR[Editor Service]\n        SETMGR[Set Manager]\n        PLAYER[Player]\n    end\n\n    subgraph \"Core\"\n        ENGINE[Sampler Engine]\n        STATE[State Machine]\n    end\n\n    subgraph \"Devices\"\n        MIDI[MIDI Controller]\n        AUDIO[Audio Device]\n    end\n\n    subgraph \"Models\"\n        LP[Launchpad]\n        PAD[Pad]\n        SAMPLE[Sample]\n    end\n\n    TUI --&gt; APP\n    LED --&gt; APP\n    APP --&gt; EDITOR\n    APP --&gt; SETMGR\n    APP --&gt; PLAYER\n    PLAYER --&gt; ENGINE\n    PLAYER --&gt; MIDI\n    ENGINE --&gt; STATE\n    ENGINE --&gt; AUDIO\n    MIDI --&gt; AUDIO\n    EDITOR --&gt; LP\n    LP --&gt; PAD\n    PAD --&gt; SAMPLE\n\n    style APP fill:#673ab7,color:#fff\n    style PLAYER fill:#9c27b0,color:#fff\n    style ENGINE fill:#e91e63,color:#fff</code></pre>"},{"location":"architecture/overview/#design-principles","title":"Design Principles","text":"<p>LaunchSampler is built on SOLID principles:</p>"},{"location":"architecture/overview/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Each component has one well-defined purpose:</p> <ul> <li>EditorService: Pad editing operations only</li> <li>Player: Audio/MIDI coordination only</li> <li>SamplerEngine: Low-level audio rendering only</li> <li>TUIService: UI rendering and updates only</li> </ul>"},{"location":"architecture/overview/#openclosed-principle","title":"Open/Closed Principle","text":"<p>Extension without modification through protocols:</p> <pre><code>@runtime_checkable\nclass StateObserver(Protocol):\n    \"\"\"Any object can observe playback events.\"\"\"\n    def on_playback_event(self, event: PlaybackEvent, pad_index: int) -&gt; None:\n        ...\n</code></pre>"},{"location":"architecture/overview/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>All implementations are interchangeable:</p> <ul> <li>Any <code>DeviceInput</code> works for MIDI</li> <li>Any <code>DeviceOutput</code> works for audio</li> <li>Any <code>StateObserver</code> can receive events</li> </ul>"},{"location":"architecture/overview/#interface-segregation-principle","title":"Interface Segregation Principle","text":"<p>Focused, granular protocols:</p> <ul> <li><code>EditObserver</code> - Editing events only</li> <li><code>StateObserver</code> - Playback events only</li> <li><code>MidiObserver</code> - MIDI events only</li> <li><code>AppObserver</code> - App lifecycle events only</li> </ul>"},{"location":"architecture/overview/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>High-level modules depend on abstractions:</p> <pre><code>class Player:\n    def __init__(\n        self,\n        config: AppConfig,\n        state_machine: Optional[SamplerStateMachine] = None\n    ):\n        # Dependency injection, not hard-coded creation\n        self._state_machine = state_machine or SamplerStateMachine()\n</code></pre>"},{"location":"architecture/overview/#key-patterns","title":"Key Patterns","text":""},{"location":"architecture/overview/#observer-pattern","title":"Observer Pattern","text":"<p>Event-driven synchronization keeps all components in sync:</p> <pre><code># Editor fires events when pads change\neditor.assign_sample(pad_index, sample_path)\n  \u2192 EditEvent.PAD_ASSIGNED\n    \u2192 TUIService updates UI\n    \u2192 Player loads sample into engine\n    \u2192 LEDService updates LED color\n</code></pre> <p>Benefits: - \u2705 Loose coupling - components don't know about each other - \u2705 Automatic synchronization - no manual update calls - \u2705 Extensible - add new observers without changing existing code</p>"},{"location":"architecture/overview/#service-layer-pattern","title":"Service Layer Pattern","text":"<p>Services encapsulate business logic:</p> <pre><code># EditorService - Manages pad edits\neditor.assign_sample(index, path)\neditor.set_pad_mode(index, mode)\neditor.move_pad(source, target)\n\n# SetManagerService - Manages sample sets\nset_manager.open_set(path)\nset_manager.save_set(set_obj, path)\nset_manager.create_from_directory(path)\n\n# Player - Manages playback\nplayer.trigger_pad(index)\nplayer.stop_pad(index)\nplayer.set_master_volume(volume)\n</code></pre> <p>Benefits: - \u2705 Testable - Services have clear inputs/outputs - \u2705 Reusable - Same services for TUI and LED UI - \u2705 Maintainable - Business logic in one place</p>"},{"location":"architecture/overview/#device-abstraction","title":"Device Abstraction","text":"<p>Hardware is abstracted behind protocols:</p> <pre><code>class DeviceInput(Protocol):\n    \"\"\"Generic MIDI input device.\"\"\"\n    def parse_input(msg: mido.Message) -&gt; Optional[tuple[str, int]]:\n        ...\n\nclass LaunchpadInput(DeviceInput):\n    \"\"\"Launchpad-specific implementation.\"\"\"\n    # Handles Launchpad MIDI quirks\n</code></pre> <p>Benefits: - \u2705 Hardware-agnostic - Easy to support new devices - \u2705 Testable - Mock devices for testing - \u2705 Flexible - Switch devices at runtime</p>"},{"location":"architecture/overview/#threading-model","title":"Threading Model","text":"<p>LaunchSampler uses three threads for real-time performance:</p> <pre><code>graph LR\n    subgraph \"UI Thread\"\n        A[Textual Event Loop]\n        B[TUI Rendering]\n        C[User Input]\n    end\n\n    subgraph \"MIDI Thread\"\n        D[MIDI Polling]\n        E[Pad Press/Release]\n    end\n\n    subgraph \"Audio Thread\"\n        F[Audio Callback]\n        G[Sample Mixing]\n        H[Lock-Free Queue]\n    end\n\n    C --&gt; D\n    E --&gt; H\n    H --&gt; F\n    F --&gt; G\n\n    style F fill:#e91e63,color:#fff\n    style H fill:#ff5722,color:#fff</code></pre>"},{"location":"architecture/overview/#thread-details","title":"Thread Details","text":"Thread Purpose Locks Priority UI Thread User interface, editing Standard locks Normal MIDI Thread Hardware input polling Lock-free queue High Audio Thread Real-time audio rendering No locks! Real-time"},{"location":"architecture/overview/#lock-free-audio-path","title":"Lock-Free Audio Path","text":"<p>The audio callback is completely lock-free for minimal latency:</p> <pre><code># Audio callback (real-time thread)\ndef _audio_callback(self, outdata, frames, time, status):\n    # NO LOCKS - just pop from lock-free queue\n    while not self._trigger_queue.empty():\n        action, pad_index = self._trigger_queue.get()\n        self._process_action(action, pad_index)\n\n    # Mix audio from active pads\n    self._render_audio(outdata, frames)\n</code></pre> <p>Key Insight: Triggers go through a lock-free queue, so the audio thread never blocks.</p>"},{"location":"architecture/overview/#state-management","title":"State Management","text":""},{"location":"architecture/overview/#single-source-of-truth","title":"Single Source of Truth","text":"<p>Each piece of state has one authoritative source:</p> State Source Observers Pad data <code>Launchpad.pads</code> TUI, LED, Player Playing pads <code>SamplerStateMachine</code> TUI, LED, Editor Current set <code>Orchestrator.current_set</code> TUI, SetManager Audio state <code>SamplerEngine</code> Player, State Machine"},{"location":"architecture/overview/#no-state-duplication","title":"No State Duplication","text":"<p>Components query canonical sources instead of caching:</p> <pre><code># \u274c BAD: Duplicate state cache\nclass LEDService:\n    def __init__(self):\n        self._playing_pads = set()  # Duplicate!\n\n# \u2705 GOOD: Query canonical source\nclass LEDService:\n    def _is_pad_playing(self, pad_index: int) -&gt; bool:\n        return self.state_machine.is_pad_playing(pad_index)\n</code></pre>"},{"location":"architecture/overview/#event-flow-example","title":"Event Flow Example","text":"<p>Here's how an edit operation flows through the system:</p> <pre><code>sequenceDiagram\n    participant User\n    participant TUI\n    participant Editor\n    participant Player\n    participant Engine\n    participant LED\n\n    User-&gt;&gt;TUI: Press 'B' to browse\n    TUI-&gt;&gt;Editor: assign_sample(index, path)\n    Editor-&gt;&gt;Editor: Update pad.sample\n    Editor-&gt;&gt;TUI: EditEvent.PAD_ASSIGNED\n    Editor-&gt;&gt;Player: EditEvent.PAD_ASSIGNED\n    Editor-&gt;&gt;LED: EditEvent.PAD_ASSIGNED\n    Player-&gt;&gt;Engine: load_sample(index, sample)\n    TUI-&gt;&gt;TUI: Update pad widget\n    LED-&gt;&gt;LED: Update LED color</code></pre>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Design Principles - Deep dive into SOLID</li> <li>Components - Detailed component documentation</li> <li>Event System - Event types and observers</li> <li>Threading Model - Thread safety details</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>LaunchSampler uses a JSON configuration file to store settings. The config is automatically created on first run.</p>"},{"location":"getting-started/configuration/#configuration-file-location","title":"Configuration File Location","text":"Linux / macOSWindows <pre><code>~/.launchsampler/config.json\n</code></pre> <pre><code>%USERPROFILE%\\.launchsampler\\config.json\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":"Field Type Default Description Notes Path Settings <code>sets_dir</code> <code>string</code> <code>~/.launchsampler/sets</code> Default directory for saving/loading sets Set: <code>--sets-dir &lt;path&gt;</code> Audio Settings <code>default_audio_device</code> <code>int \\| null</code> <code>null</code> Audio output device ID (null = system default) Set: <code>config set -a &lt;id&gt;</code>Reset: <code>config reset default_audio_device --yes</code>List devices: <code>audio list</code>\u26a0\ufe0f Auto-fallback on invalid device <code>default_buffer_size</code> <code>int</code> <code>512</code> Audio buffer size in frames Set: <code>config set -b &lt;size&gt;</code>Common: <code>128</code>, <code>256</code>, <code>512</code>, <code>1024</code>, <code>2048</code>Lower = less latency, higher CPU MIDI Settings <code>midi_poll_interval</code> <code>float</code> <code>2.0</code> MIDI device polling interval (seconds) Set: <code>--midi-poll-interval &lt;float&gt;</code> <code>panic_button_cc_control</code> <code>int</code> <code>19</code> MIDI CC control for panic button Set: <code>--panic-button-cc-control &lt;int&gt;</code> <code>panic_button_cc_value</code> <code>int</code> <code>127</code> MIDI CC value to trigger panic Set: <code>--panic-button-cc-value &lt;int&gt;</code> Session Settings <code>last_set</code> <code>string \\| null</code> <code>null</code> Last loaded set name (auto-updated) Set: <code>--last-set &lt;name&gt;</code> <code>auto_save</code> <code>bool</code> <code>true</code> Auto-save changes to sets Set: <code>--auto-save &lt;true\\|false&gt;</code>"},{"location":"getting-started/configuration/#managing-configuration","title":"Managing Configuration","text":""},{"location":"getting-started/configuration/#cli-commands","title":"CLI Commands","text":"<p>The <code>config</code> command provides a complete interface for managing configuration:</p>"},{"location":"getting-started/configuration/#view-configuration","title":"View Configuration","text":"<pre><code># Show all configuration values (default)\nlaunchsampler config\n\n# Show specific field\nlaunchsampler config --field default_buffer_size\n</code></pre>"},{"location":"getting-started/configuration/#set-configuration-values","title":"Set Configuration Values","text":"<pre><code># Set one field\nlaunchsampler config set -b 256\n\n# Set multiple fields at once\nlaunchsampler config set -a 3 -b 256 --auto-save false\n</code></pre>"},{"location":"getting-started/configuration/#validate-configuration","title":"Validate Configuration","text":"<pre><code># Validate entire configuration with detailed report\nlaunchsampler config validate\n\n# Validate specific fields\nlaunchsampler config validate default_audio_device default_buffer_size\n\n# Output shows [OK] or [FAIL] with type information\n</code></pre> <p>Example output: <pre><code>[OK] default_audio_device         Optional        = None\n    Default audio output device ID\n[OK] default_buffer_size          int             = 512\n    Default audio buffer size in frames\n</code></pre></p>"},{"location":"getting-started/configuration/#reset-configuration","title":"Reset Configuration","text":"<pre><code># Reset all fields to defaults (prompts for confirmation)\nlaunchsampler config reset\n\n# Reset specific fields\nlaunchsampler config reset default_buffer_size midi_poll_interval\n\n# Skip confirmation prompt\nlaunchsampler config reset default_buffer_size --yes\n</code></pre>"},{"location":"getting-started/configuration/#listing-available-devices","title":"Listing Available Devices","text":""},{"location":"getting-started/configuration/#list-audio-devices","title":"List Audio Devices","text":"<p>List low-latency audio devices only (default):</p> <pre><code>launchsampler audio list\n</code></pre> <p>Output example: <pre><code>Available low-latency audio output devices (ASIO/WASAPI):\n\n[2] Speakers (Realtek)  [Default]\n    Host API: Windows WASAPI\n    Channels: 2 out\n    Sample Rate: 48000.0 Hz\n    Latency: 3.0 ms\n\n[3] Headphones (USB Audio)\n    Host API: Windows WASAPI\n    Channels: 2 out\n    Sample Rate: 48000.0 Hz\n    Latency: 3.0 ms\n</code></pre></p> <p>List all audio devices (including non-low-latency):</p> <pre><code>launchsampler audio list --all\n</code></pre> <p>Output example: <pre><code>Available Audio APIs:\n  - MME (default)\n  - DirectSound\n  - Windows WASAPI\n\nMME Devices:\n  [0] Speakers (Realtek High Definition Audio)  [Default]\n  [1] Headphones (USB Audio Device)\n\nDirectSound Devices:\n  [4] Speakers (Realtek)\n  [5] Headphones (USB Audio)\n\nWindows WASAPI Devices:\n  [2] Speakers (Realtek)  [Default]\n  [3] Headphones (USB Audio)\n</code></pre></p> <p>List all audio devices with detailed information:</p> <pre><code>launchsampler audio list --all --detailed\n</code></pre> <p>Output example: <pre><code>Available Audio APIs:\n  - MME (default)\n  - DirectSound\n  - Windows WASAPI\n\nMME Devices:\n  [0] Speakers (Realtek High Definition Audio)  [Default]\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 10.0 ms\n  [1] Headphones (USB Audio Device)\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 10.0 ms\n\nDirectSound Devices:\n  [4] Speakers (Realtek)\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 8.0 ms\n  [5] Headphones (USB Audio)\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 8.0 ms\n\nWindows WASAPI Devices:\n  [2] Speakers (Realtek)  [Default]\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 3.0 ms\n  [3] Headphones (USB Audio)\n      Channels: 2 out\n      Sample Rate: 48000.0 Hz\n      Latency: 3.0 ms\n</code></pre></p>"},{"location":"getting-started/configuration/#list-midi-devices","title":"List MIDI Devices","text":"<pre><code>launchsampler --list-midi\n</code></pre> <p>Output example: <pre><code>Available MIDI Input Devices:\n  [0] Launchpad Mini MK3 MIDI In\n  [1] MIDI Keyboard In\n\nAvailable MIDI Output Devices:\n  [0] Launchpad Mini MK3 MIDI Out\n  [1] MIDI Keyboard Out\n</code></pre></p>"},{"location":"getting-started/configuration/#logging","title":"Logging","text":"<p>LaunchSampler provides flexible logging options to help you troubleshoot issues and monitor application behavior.</p>"},{"location":"getting-started/configuration/#log-file-locations","title":"Log File Locations","text":"<p>By default, logs are stored in your config directory:</p> Linux / macOSWindows <pre><code>~/.launchsampler/logs/launchsampler.log\n</code></pre> <pre><code>%USERPROFILE%\\.launchsampler\\logs\\launchsampler.log\n</code></pre>"},{"location":"getting-started/configuration/#logging-options","title":"Logging Options","text":"Command Log Level Log File Use Case <code>launchsampler</code> WARNING <code>~/.launchsampler/logs/launchsampler.log</code> Default - only warnings and errors are logged <code>launchsampler -v</code> INFO <code>~/.launchsampler/logs/launchsampler.log</code> Includes informational messages <code>launchsampler -vv</code> DEBUG <code>~/.launchsampler/logs/launchsampler.log</code> Includes detailed debug information <code>launchsampler --debug</code> DEBUG <code>./launchsampler-debug.log</code> (current directory) Troubleshooting - creates log file in current directory for easy access <code>launchsampler --log-file ./my-session.log</code> INFO (default) Custom path specified Recording specific sessions <code>launchsampler --log-file ./session.log --log-level DEBUG</code> DEBUG, INFO, WARNING, or ERROR Custom path specified Fine-tune logging detail for custom log files"},{"location":"getting-started/configuration/#log-rotation","title":"Log Rotation","text":"<p>Logs are automatically rotated to prevent excessive disk usage:</p> <ul> <li>Maximum file size: 10 MB</li> <li>Backup files kept: 5</li> <li>Files: <code>launchsampler.log</code>, <code>launchsampler.log.1</code>, ..., <code>launchsampler.log.5</code></li> </ul>"},{"location":"getting-started/configuration/#reading-log-files","title":"Reading Log Files","text":"<p>Log entries follow this format:</p> <pre><code>2024-01-15 14:30:22 - launchsampler.player - INFO - Starting audio playback\n2024-01-15 14:30:22 - launchsampler.midi - WARNING - MIDI device disconnected\n2024-01-15 14:30:23 - launchsampler.audio - ERROR - Audio buffer underrun\n</code></pre> <p>Each line contains:</p> <ol> <li>Timestamp: When the event occurred</li> <li>Logger name: Which component generated the log</li> <li>Level: Severity (DEBUG, INFO, WARNING, ERROR)</li> <li>Message: Description of the event</li> </ol>"},{"location":"getting-started/configuration/#viewing-logs-in-real-time","title":"Viewing Logs in Real-Time","text":"<p>While the TUI is running, logs are only written to files. To monitor logs in real-time:</p> Linux / macOSWindows (PowerShell) <pre><code># In another terminal\ntail -f ~/.launchsampler/logs/launchsampler.log\n</code></pre> <pre><code># In another terminal\nGet-Content $env:USERPROFILE\\.launchsampler\\logs\\launchsampler.log -Wait\n</code></pre>"},{"location":"getting-started/configuration/#troubleshooting-with-logs","title":"Troubleshooting with Logs","text":"<p>When reporting issues or debugging problems:</p> <ol> <li> <p>Enable debug logging: <pre><code>launchsampler --debug\n</code></pre></p> </li> <li> <p>Reproduce the issue while the app is running</p> </li> <li> <p>Check the log file: <pre><code>cat launchsampler-debug.log\n</code></pre></p> </li> <li> <p>Look for ERROR or WARNING messages near the time of the issue</p> </li> <li> <p>Share relevant log sections when asking for help</p> </li> </ol> <p>Performance Impact</p> <p>DEBUG logging has minimal performance impact for most use cases. Only in very high-throughput scenarios (many simultaneous samples) should you consider using WARNING level.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>LaunchSampler can be installed using pip or uv. We recommend using <code>uv</code> for faster dependency resolution and installation.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.12 or higher</li> <li>Audio output device (soundcard)</li> <li>Optional: Novation Launchpad (Mini MK3, Pro MK3, X, or compatible device)</li> </ul>"},{"location":"getting-started/installation/#supported-platforms","title":"Supported Platforms","text":"<ul> <li>\u2705 Windows</li> <li>\u2705 macOS</li> <li>\u2705 Linux</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":"Using pipx (Recommended for CLI usage)Using uvx (Faster, but requires full command) <p>Install once, use anywhere. After installation, simply run <code>launchsampler</code> from any directory.</p> <pre><code># Install pipx (if not already installed)\npip install pipx\npipx ensurepath\n\n# Install launchsampler\npipx install git+https://github.com/jacobanana/launchsampler\n</code></pre> <p>After installation, verify that LaunchSampler is installed correctly:</p> <pre><code># Check version\nlaunchsampler --version\n\n# Show help\nlaunchsampler --help\n</code></pre> <p>uv is significantly faster but requires the full git URL each time.</p> <pre><code># Install uv (if not already installed)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Run directly (no installation needed)\nuvx git+https://github.com/jacobanana/launchsampler\n</code></pre> <p>After installation, verify that LaunchSampler is installed correctly:</p> <pre><code># Check version\nuvx git+https://github.com/jacobanana/launchsampler --version\n\n# Show help\nuvx git+https://github.com/jacobanana/launchsampler --help\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development, install uv and clone the repository and install with development dependencies:</p> <pre><code># Install uv (if not already installed)\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone the repository\ngit clone https://github.com/jacobanana/launchsampler.git\ncd launchsampler\n\n# Install with development dependencies using uv\nuv sync\n\n# Run tests to verify\nuv run pytest\n\n# Run app\nuv run launchsampler\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Learn the basics</li> <li>Configuration - Customize your setup</li> <li>User Guide - Master all features</li> <li>Troubleshooting - Figure out why something's not working</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get up and running with LaunchSampler in just a few minutes!</p>"},{"location":"getting-started/quick-start/#1-launch-the-application","title":"1. Launch the Application","text":"<pre><code>launchsampler\n</code></pre> <p>The application will start in Play Mode with an empty set.</p> <p>First Run</p> <p>On first run, LaunchSampler creates a config file at <code>~/.launchsampler/config.json</code></p>"},{"location":"getting-started/quick-start/#2-switch-to-edit-mode","title":"2. Switch to Edit Mode","text":"<p>Press E to switch to Edit Mode, where you can build your sample set.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Edit Mode: Untitled Set                   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 [8x8 Grid]  \u2502  Pad Details Panel          \u2502\n\u2502             \u2502  - Sample name              \u2502\n\u2502             \u2502  - Playback mode            \u2502\n\u2502             \u2502  - Volume                   \u2502\n\u2502             \u2502  - Move controls            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"getting-started/quick-start/#3-load-samples","title":"3. Load Samples","text":""},{"location":"getting-started/quick-start/#option-a-load-from-directory","title":"Option A: Load from Directory","text":"<p>Press Ctrl+L to load all samples from a directory:</p> <ol> <li>Navigate to your samples folder</li> <li>Select the directory</li> <li>LaunchSampler automatically assigns first 64 samples to pads</li> </ol>"},{"location":"getting-started/quick-start/#option-b-assign-individual-samples","title":"Option B: Assign Individual Samples","text":"<ol> <li>Click a pad or use arrow keys to select it</li> <li>Press B to browse for a sample</li> <li>Select your audio file (WAV, MP3, FLAC, etc.)</li> </ol>"},{"location":"getting-started/quick-start/#4-configure-pads","title":"4. Configure Pads","text":"<p>For each pad, you can configure:</p>"},{"location":"getting-started/quick-start/#playback-mode","title":"Playback Mode","text":"<p>Press number keys to set playback mode:</p> <ul> <li>1 - One-Shot: Play sample once from start to end</li> <li>2 - Hold: Play while pad is held, stop when released</li> <li>3 - Loop: Loop continuously until the pad is released</li> <li>4 - Loop Toggle: Toggle loop on/off with each press</li> </ul>"},{"location":"getting-started/quick-start/#sample-name","title":"Sample name","text":"<ul> <li>Set a name for your pad, defaults to file name</li> </ul>"},{"location":"getting-started/quick-start/#adjust-volume","title":"Adjust Volume","text":"<ul> <li>You can edit the volume with the volume field</li> </ul>"},{"location":"getting-started/quick-start/#test-playback","title":"Test Playback","text":"<ul> <li>Press the associated pad on your MIDI controller</li> <li>Or Press Space to test the selected pad</li> </ul>"},{"location":"getting-started/quick-start/#5-save-your-set","title":"5. Save Your Set","text":"<p>Press Ctrl+S to save your set:</p> <ol> <li>Choose a location (defaults to <code>~/.launchsampler/sets/</code>)</li> <li>Enter a name for your set</li> <li>Your set is saved as a <code>.json</code> file</li> </ol>"},{"location":"getting-started/quick-start/#6-switch-to-play-mode","title":"6. Switch to Play Mode","text":"<p>Press P to switch to Play Mode for live performance:</p> <ul> <li>MIDI Input: Your Launchpad is now active - press pads to trigger samples</li> <li>Keyboard Input: You can still test pads with Space</li> <li>No Editing: Edit operations are disabled to prevent accidents during performance</li> </ul>"},{"location":"getting-started/quick-start/#common-workflows","title":"Common Workflows","text":""},{"location":"getting-started/quick-start/#organize-samples","title":"Organize Samples","text":"<p>Use directional operations to arrange your pads:</p> <pre><code>Alt + Arrow    : Duplicate pad in direction\nCtrl + Arrow   : Move pad in direction\nC              : Copy pad\nX              : Cut pad\nV              : Paste pad\nD              : Delete pad\n</code></pre>"},{"location":"getting-started/quick-start/#set-management","title":"Set Management","text":"<pre><code>Ctrl + O       : Open saved set\nCtrl + L       : Load from directory\nCtrl + S       : Save current set\n</code></pre>"},{"location":"getting-started/quick-start/#navigation","title":"Navigation","text":"<pre><code>Arrow Keys     : Navigate between pads (Edit Mode)\nE              : Switch to Edit Mode\nP              : Switch to Play Mode\nEsc            : Stop all audio (Panic)\nCtrl + Q       : Quit application\n</code></pre>"},{"location":"getting-started/quick-start/#example-session","title":"Example Session","text":"<p>Here's a typical workflow:</p> <ol> <li>Start in Edit Mode - E</li> <li>Load samples - Ctrl+L \u2192 Select \"Drums\" folder</li> <li>Configure pads:</li> <li>Pad 0 (Kick): One-shot (1)</li> <li>Pad 1 (Snare): One-shot (1)</li> <li>Pad 8 (Hi-hat): Loop (3)</li> <li>Pad 16 (Bass): Hold (2)</li> <li>Test your set - Select pads and press Space</li> <li>Save - Ctrl+S \u2192 Name it \"Drums Kit\"</li> <li>Perform - P to switch to Play Mode</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Customize audio/MIDI settings</li> <li>User Guide - Learn all features in depth</li> <li>Keyboard Shortcuts - Complete shortcut reference</li> </ul>"},{"location":"user-guide/overview/","title":"User Guide Overview","text":"<p>This section covers all features of LaunchSampler in detail.</p>"},{"location":"user-guide/overview/#contents","title":"Contents","text":"<ul> <li>Edit Mode - Build and configure sample sets</li> <li>Play Mode - Live performance mode</li> <li>Keyboard Shortcuts - Complete shortcut reference</li> <li>MIDI Integration - MIDI setup and usage</li> <li>Sample Management - Organize your samples</li> </ul> <p>Documentation in Progress</p> <p>This documentation is being actively developed. Check back soon for complete guides.</p>"}]}